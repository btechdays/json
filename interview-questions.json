{
  "java": [
    {
      "id": 1,
      "category": "Java Basics",
      "question": "What is Java?",
      "answer": "Java is a high-level, class-based, object-oriented programming language designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let application developers write once, run anywhere (WORA)."
    },
    {
      "id": 2,
      "category": "Java Basics",
      "question": "What are the main features of Java?",
      "answer": "The main features of Java include:\n• Platform Independence (Write Once, Run Anywhere)\n• Object-Oriented Programming\n• Simple and Easy to Learn\n• Secure\n• Architecture Neutral\n• Portable\n• Robust\n• Multithreaded\n• High Performance\n• Distributed"
    },
    {
      "id": 3,
      "category": "Java Basics",
      "question": "What is JVM, JRE, and JDK?",
      "answer": "JVM (Java Virtual Machine): An abstract machine that provides the runtime environment to execute Java bytecode.\n\nJRE (Java Runtime Environment): Provides libraries, JVM, and other components to run Java applications. It doesn't contain development tools.\n\nJDK (Java Development Kit): Contains JRE plus development tools like compiler, debugger, etc."
    },
    {
      "id": 4,
      "category": "OOP Concepts",
      "question": "What are the four pillars of Object-Oriented Programming?",
      "answer": "The four pillars of OOP are:\n\n1. Encapsulation: Bundling data and methods that operate on that data within a single unit (class)\n\n2. Inheritance: Mechanism where a new class inherits properties and behaviors from an existing class\n\n3. Polymorphism: Ability of objects to take on multiple forms (method overloading and overriding)\n\n4. Abstraction: Hiding complex implementation details and showing only essential features"
    },
    {
      "id": 5,
      "category": "OOP Concepts",
      "question": "What is the difference between Abstract Class and Interface?",
      "answer": "Abstract Class:\n• Can have abstract and non-abstract methods\n• Can have constructors\n• Can have instance variables\n• Uses 'extends' keyword\n• Supports single inheritance\n• Can have access modifiers\n\nInterface:\n• All methods are abstract by default (before Java 8)\n• Cannot have constructors\n• Only static and final variables\n• Uses 'implements' keyword\n• Supports multiple inheritance\n• Methods are public by default"
    },
    {
      "id": 6,
      "category": "Collections",
      "question": "What is the difference between ArrayList and LinkedList?",
      "answer": "ArrayList:\n• Uses dynamic array internally\n• Better for storing and accessing data\n• Slower manipulation (add/remove in middle)\n• Less memory overhead\n• Random access is O(1)\n\nLinkedList:\n• Uses doubly linked list internally\n• Better for manipulating data\n• Faster manipulation (add/remove in middle)\n• More memory overhead (stores references)\n• Random access is O(n)"
    },
    {
      "id": 7,
      "category": "Collections",
      "question": "What is the difference between HashMap and HashTable?",
      "answer": "HashMap:\n• Not synchronized (not thread-safe)\n• Allows one null key and multiple null values\n• Fast performance\n• Iterator is fail-fast\n• Introduced in Java 1.2\n\nHashTable:\n• Synchronized (thread-safe)\n• Does not allow null keys or values\n• Slower performance\n• Enumerator is fail-safe\n• Legacy class"
    },
    {
      "id": 8,
      "category": "Exception Handling",
      "question": "What is the difference between Checked and Unchecked Exceptions?",
      "answer": "Checked Exceptions:\n• Checked at compile-time\n• Must be handled or declared\n• Extend Exception class\n• Examples: IOException, SQLException\n\nUnchecked Exceptions:\n• Checked at runtime\n• Not required to handle\n• Extend RuntimeException class\n• Examples: NullPointerException, ArrayIndexOutOfBoundsException"
    },
    {
      "id": 9,
      "category": "Multithreading",
      "question": "What is the difference between Thread and Runnable?",
      "answer": "Thread:\n• A class that implements thread functionality\n• Extends Thread class\n• Cannot extend other classes (single inheritance)\n• More overhead\n\nRunnable:\n• An interface for thread execution\n• Implements Runnable interface\n• Can extend other classes\n• Preferred approach for thread creation\n• More flexible and reusable"
    },
    {
      "id": 10,
      "category": "Java 8 Features",
      "question": "What are Lambda Expressions in Java 8?",
      "answer": "Lambda expressions are a concise way to represent anonymous functions. They enable functional programming in Java.\n\nSyntax: (parameters) -> expression or (parameters) -> { statements; }\n\nExample:\n// Old way\nRunnable r1 = new Runnable() {\n    public void run() {\n        System.out.println(\"Hello\");\n    }\n};\n\n// Lambda way\nRunnable r2 = () -> System.out.println(\"Hello\");"
    }
  ],
  "springboot": [
    {
      "id": 1,
      "category": "Basics of Spring & Spring Boot",
      "question": "What is Spring Boot?",
      "answer": "Spring Boot is an open-source Java-based framework used to create stand-alone, production-grade Spring-based applications with minimal configuration. It simplifies the development of Spring applications by providing auto-configuration, embedded servers, and production-ready features out of the box."
    },
    {
      "id": 2,
      "category": "Basics of Spring & Spring Boot",
      "question": "What is the difference between Spring and Spring Boot?",
      "answer": "Spring:\n• Requires extensive XML/annotation configuration\n• Manual dependency management\n• Requires external server\n• More time for setup\n• XML configuration required for many features\n• Requires additional setup for production\n\nSpring Boot:\n• Auto-configuration available\n• Starter dependencies simplify management\n• Embedded servers (Tomcat, Jetty)\n• Faster development and setup\n• Minimal or no XML needed\n• Built-in production-ready features"
    },
    {
      "id": 3,
      "category": "Basics of Spring & Spring Boot",
      "question": "What are the advantages of using Spring and Spring Boot?",
      "answer": "Advantages of Spring:\n• Lightweight and modular\n• Dependency Injection and IoC\n• Aspect-Oriented Programming (AOP)\n• Transaction Management\n• Integration with other frameworks\n\nAdvantages of Spring Boot:\n• Auto-configuration\n• Standalone applications\n• Embedded servers\n• Production-ready features (metrics, health checks)\n• Reduced boilerplate code\n• Easy dependency management with starters\n• Microservices development support"
    },
    {
      "id": 4,
      "category": "Basics of Spring & Spring Boot",
      "question": "What are the main features of Spring Boot?",
      "answer": "Main features of Spring Boot:\n\n1. Auto-Configuration: Automatically configures Spring application based on dependencies\n2. Starter Dependencies: Pre-configured dependency descriptors\n3. Embedded Servers: Tomcat, Jetty, or Undertow embedded\n4. Spring Boot CLI: Command-line tool for rapid development\n5. Actuator: Production-ready features (metrics, health checks)\n6. No XML Configuration: Convention over configuration\n7. Easy Dependency Management: Simplified Maven/Gradle configuration\n8. Microservices Support: Easy to create microservices architecture\n9. Developer Tools: Auto-restart, live reload\n10. External Configuration: Properties files, YAML files, environment variables"
    },
    {
      "id": 5,
      "category": "Basics of Spring & Spring Boot",
      "question": "Why is Spring Boot preferred over other frameworks/languages?",
      "answer": "Spring Boot is preferred because:\n\n• Rapid Development: Quick setup and minimal configuration\n• Production Ready: Built-in monitoring and health checks\n• Microservices: Best suited for microservices architecture\n• Community Support: Large community and extensive documentation\n• Integration: Easy integration with databases, messaging queues, etc.\n• Testing Support: Comprehensive testing framework\n• Scalability: Highly scalable applications\n• Enterprise Ready: Used by major enterprises worldwide\n• Cloud Native: Easy deployment to cloud platforms\n• Flexibility: Works with various databases and technologies"
    },
    {
      "id": 6,
      "category": "Basics of Spring & Spring Boot",
      "question": "What is the role of POM.xml in Spring Boot?",
      "answer": "POM.xml (Project Object Model) is the fundamental unit of work in Maven. In Spring Boot:\n\n• Dependency Management: Defines all project dependencies\n• Parent POM: Inherits from spring-boot-starter-parent\n• Version Management: Manages versions of dependencies\n• Build Configuration: Defines build plugins and goals\n• Project Information: Contains project metadata\n• Starter Dependencies: Includes spring-boot-starter-* dependencies\n• Plugin Configuration: Configures Maven plugins like spring-boot-maven-plugin\n\nExample:\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>3.0.0</version>\n</parent>"
    },
    {
      "id": 7,
      "category": "Basics of Spring & Spring Boot",
      "question": "What are starter dependencies in Spring Boot?",
      "answer": "Starter dependencies are pre-configured dependency descriptors that simplify dependency management in Spring Boot.\n\nCommon Starters:\n• spring-boot-starter-web: Web applications with Spring MVC\n• spring-boot-starter-data-jpa: JPA with Hibernate\n• spring-boot-starter-security: Spring Security\n• spring-boot-starter-test: Testing libraries\n• spring-boot-starter-actuator: Production monitoring\n• spring-boot-starter-thymeleaf: Thymeleaf template engine\n\nBenefits:\n• Simplified dependency management\n• Compatible versions bundled together\n• Reduced configuration\n• Quick project setup"
    },
    {
      "id": 8,
      "category": "Basics of Spring & Spring Boot",
      "question": "What is auto-configuration in Spring Boot?",
      "answer": "Auto-configuration is a feature that automatically configures Spring application based on the dependencies present in the classpath.\n\nKey Points:\n• Reduces manual configuration\n• Uses @EnableAutoConfiguration or @SpringBootApplication\n• Conditional configuration based on classpath\n• Can be customized or disabled\n• Configuration classes in spring-boot-autoconfigure module\n\nExample:\nIf H2 database is in classpath, Spring Boot automatically:\n• Configures DataSource\n• Sets up JPA EntityManager\n• Creates transaction manager\n\nDisabling specific auto-configuration:\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})"
    },
    {
      "id": 9,
      "category": "Basics of Spring & Spring Boot",
      "question": "What are properties in Spring Boot?",
      "answer": "Properties in Spring Boot are configuration values stored in external files that can be accessed throughout the application.\n\nTypes:\n1. application.properties (key=value format)\n2. application.yml (YAML format)\n\nUsage:\n• Database configuration\n• Server port settings\n• Logging levels\n• Custom application settings\n\nExample (application.properties):\nserver.port=8081\nspring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\n\nAccessing in code:\n@Value(\"${server.port}\")\nprivate int serverPort;"
    },
    {
      "id": 10,
      "category": "Basics of Spring & Spring Boot",
      "question": "What is the need for a properties file in Spring Boot?",
      "answer": "Properties file is needed for:\n\n• Externalized Configuration: Separate configuration from code\n• Environment-Specific Settings: Different configs for dev, test, prod\n• Easy Modification: Change settings without recompiling\n• Security: Keep sensitive data separate from source code\n• Flexibility: Override defaults easily\n• Maintainability: Centralized configuration management\n• Profile-Based Configuration: Use different properties for different profiles\n\nProfile-specific properties:\n• application-dev.properties\n• application-prod.properties\n• application-test.properties"
    },
    {
      "id": 11,
      "category": "Basics of Spring & Spring Boot",
      "question": "What is the default server port in Spring Boot?",
      "answer": "The default server port in Spring Boot is 8080.\n\nTo change the port, add to application.properties:\nserver.port=8081\n\nOr in application.yml:\nserver:\n  port: 8081\n\nTo use a random port:\nserver.port=0"
    },
    {
      "id": 12,
      "category": "Basics of Spring & Spring Boot",
      "question": "What servers are supported by Spring Boot?",
      "answer": "Spring Boot supports three main embedded servers:\n\n1. Apache Tomcat (Default):\n   • Most widely used\n   • Included in spring-boot-starter-web\n   • Supports Servlet and JSP\n\n2. Jetty:\n   • Lightweight and fast\n   • Good for microservices\n   • Better for WebSocket applications\n\n3. Undertow:\n   • High performance\n   • Low memory footprint\n   • Good for high-concurrency applications\n\nSwitching servers (exclude Tomcat, include Jetty):\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jetty</artifactId>\n</dependency>"
    },
    {
      "id": 13,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "What is Dependency Injection in Spring Boot, and what are its types?",
      "answer": "Dependency Injection (DI) is a design pattern where objects receive their dependencies from external sources rather than creating them.\n\nTypes of DI:\n\n1. Constructor Injection (Recommended):\n@Autowired\npublic UserService(UserRepository userRepository) {\n    this.userRepository = userRepository;\n}\n\n2. Setter Injection:\n@Autowired\npublic void setUserRepository(UserRepository userRepository) {\n    this.userRepository = userRepository;\n}\n\n3. Field Injection (Not recommended):\n@Autowired\nprivate UserRepository userRepository;\n\nBenefits:\n• Loose coupling\n• Easy testing\n• Maintainable code\n• Reusability"
    },
    {
      "id": 14,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "What is the role of the IoC Container in Spring Boot?",
      "answer": "IoC (Inversion of Control) Container is the core of Spring Framework that manages the lifecycle and configuration of application objects (beans).\n\nKey Responsibilities:\n• Creating objects (beans)\n• Managing object lifecycle\n• Injecting dependencies\n• Configuring beans\n• Wiring beans together\n\nTypes of IoC Containers:\n1. BeanFactory: Basic container\n2. ApplicationContext: Advanced container (commonly used)\n\nApplicationContext types:\n• AnnotationConfigApplicationContext\n• ClassPathXmlApplicationContext\n• FileSystemXmlApplicationContext\n• WebApplicationContext\n\nBenefits:\n• Centralized configuration\n• Loose coupling\n• Easy testing\n• Lifecycle management"
    },
    {
      "id": 15,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "What are Spring Beans?",
      "answer": "Spring Beans are objects that are managed by the Spring IoC container. They form the backbone of a Spring application.\n\nKey Points:\n• Created, configured, and managed by Spring Container\n• Defined using annotations or XML\n• Default scope is singleton\n• Can have lifecycle callbacks\n\nCreating Beans:\n\n1. Using @Component:\n@Component\npublic class UserService { }\n\n2. Using @Bean:\n@Configuration\npublic class AppConfig {\n    @Bean\n    public UserService userService() {\n        return new UserService();\n    }\n}\n\n3. Stereotype Annotations:\n• @Service\n• @Repository\n• @Controller\n• @RestController"
    },
    {
      "id": 16,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "What are the different bean scopes in Spring Boot?",
      "answer": "Bean scopes define the lifecycle and visibility of beans in the Spring container.\n\nScopes:\n\n1. Singleton (Default):\n   • One instance per Spring container\n   • Shared across the application\n   @Scope(\"singleton\")\n\n2. Prototype:\n   • New instance every time requested\n   • Not cached\n   @Scope(\"prototype\")\n\n3. Request (Web):\n   • One instance per HTTP request\n   @Scope(\"request\")\n\n4. Session (Web):\n   • One instance per HTTP session\n   @Scope(\"session\")\n\n5. Application (Web):\n   • One instance per ServletContext\n   @Scope(\"application\")\n\n6. WebSocket:\n   • One instance per WebSocket session\n   @Scope(\"websocket\")"
    },
    {
      "id": 17,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "Where do we use Application scope in Spring Boot?",
      "answer": "Application scope is used in web applications where you need one instance of a bean per ServletContext (entire web application).\n\nUse Cases:\n• Application-wide configuration\n• Shared cache across all users\n• Application-level counters/statistics\n• Global application state\n• Shared resources like thread pools\n\nExample:\n@Bean\n@Scope(value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic AppConfig appConfig() {\n    return new AppConfig();\n}\n\nDifference from Singleton:\n• Singleton: One per Spring ApplicationContext\n• Application: One per ServletContext\n• In most cases, they behave similarly\n• Application scope is specifically for web applications"
    },
    {
      "id": 18,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "What is the difference between @Component and @Bean annotations in Spring?",
      "answer": "@Component:\n• Class-level annotation\n• Used for auto-detection by component scanning\n• Creates bean automatically\n• You don't control bean creation\n• Used when you have source code access\n• Example:\n  @Component\n  public class UserService { }\n\n@Bean:\n• Method-level annotation\n• Used in @Configuration classes\n• Explicit bean creation\n• Full control over bean creation\n• Used when you don't have source code (third-party libraries)\n• Example:\n  @Configuration\n  public class AppConfig {\n      @Bean\n      public RestTemplate restTemplate() {\n          return new RestTemplate();\n      }\n  }\n\nWhen to use:\n• @Component: Your own classes\n• @Bean: Third-party classes, complex initialization"
    },
    {
      "id": 19,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "What is the difference between @Component and @Controller?",
      "answer": "@Component:\n• Generic stereotype annotation\n• Can be used in any layer\n• Base annotation for component scanning\n• Use case: General Spring beans\n• Return type: Any\n• Request mapping: No\n• View resolution: No\n\n@Controller:\n• Specialized for web controllers\n• Used in presentation layer\n• Specialized version of @Component\n• Use case: Web MVC controllers\n• Return type: Views, Model objects\n• Request mapping: Yes, works with @RequestMapping\n• View resolution: Yes, resolves views\n\nNote: @Controller = @Component + web-specific features\n\nExample:\n@Component\npublic class EmailService { }\n\n@Controller\npublic class UserController {\n    @RequestMapping(\"/users\")\n    public String getUsers() {\n        return \"users\";\n    }\n}"
    },
    {
      "id": 20,
      "category": "Spring Boot Architecture and Core Concepts",
      "question": "What is the difference between @Mock and @InjectMocks annotations in testing?",
      "answer": "@Mock:\n• Purpose: Creates mock object\n• Usage: For dependencies\n• Injection: Doesn't inject\n• Implementation: Creates proxy/stub\n• Dependencies: No\n\n@InjectMocks:\n• Purpose: Creates object and injects mocks into it\n• Usage: For class under test\n• Injection: Injects @Mock objects\n• Implementation: Creates actual instance\n• Dependencies: Yes, needs @Mock dependencies\n\nExample:\npublic class UserServiceTest {\n    @Mock\n    private UserRepository userRepository; // Mock dependency\n    \n    @InjectMocks\n    private UserService userService; // Test object with injected mocks\n    \n    @BeforeEach\n    void setUp() {\n        MockitoAnnotations.openMocks(this);\n    }\n    \n    @Test\n    void testGetUser() {\n        when(userRepository.findById(1L)).thenReturn(Optional.of(new User()));\n        User user = userService.getUser(1L);\n        assertNotNull(user);\n    }\n}"
    },
    {
      "id": 21,
      "category": "Spring Boot Configuration & Profiles",
      "question": "What is the use of Profiles in Spring Boot?",
      "answer": "Profiles in Spring Boot allow you to segregate parts of your application configuration and make it available only in certain environments.\n\nKey Uses:\n• Environment-specific configuration (dev, test, prod)\n• Different database configurations per environment\n• Enable/disable features based on environment\n• Load different beans for different profiles\n• Separate logging configurations\n• Different external service endpoints\n\nCreating Profile-Specific Properties:\n• application-dev.properties\n• application-test.properties\n• application-prod.properties\n\nActivating Profiles:\n• application.properties: spring.profiles.active=dev\n• Command line: java -jar app.jar --spring.profiles.active=prod\n• Environment variable: SPRING_PROFILES_ACTIVE=dev\n• In IDE: Set active profiles in run configuration\n\nProfile-Specific Beans:\n@Component\n@Profile(\"dev\")\npublic class DevDataSource { }\n\n@Component\n@Profile(\"prod\")\npublic class ProdDataSource { }"
    },
    {
      "id": 22,
      "category": "Spring Boot Configuration & Profiles",
      "question": "What is the @Configuration annotation in Spring Boot?",
      "answer": "@Configuration is a class-level annotation that indicates a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions.\n\nKey Points:\n• Marks class as source of bean definitions\n• Alternative to XML configuration\n• Contains @Bean annotated methods\n• Processed at container initialization\n• Can be combined with @ComponentScan\n• Supports dependency injection\n\nExample:\n@Configuration\npublic class AppConfig {\n    \n    @Bean\n    public DataSource dataSource() {\n        DriverManagerDataSource dataSource = new DriverManagerDataSource();\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/mydb\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"password\");\n        return dataSource;\n    }\n    \n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n\nBenefits:\n• Type-safe configuration\n• Refactoring-friendly\n• IDE support\n• Full programmatic control\n• Easy to test"
    },
    {
      "id": 23,
      "category": "Spring Boot Configuration & Profiles",
      "question": "What is the use of the Profile annotation with example?",
      "answer": "The @Profile annotation is used to indicate that a component or configuration is eligible for registration only when specific profiles are active.\n\nUse Cases:\n• Environment-specific beans\n• Different implementations per environment\n• Feature toggles\n• Test vs production configurations\n\nExample 1 - Database Configuration:\n@Configuration\n@Profile(\"dev\")\npublic class DevDatabaseConfig {\n    @Bean\n    public DataSource dataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdDatabaseConfig {\n    @Bean\n    public DataSource dataSource() {\n        DriverManagerDataSource ds = new DriverManagerDataSource();\n        ds.setUrl(\"jdbc:mysql://prod-server:3306/mydb\");\n        ds.setUsername(\"prod_user\");\n        ds.setPassword(\"prod_password\");\n        return ds;\n    }\n}\n\nExample 2 - Service Implementations:\n@Service\n@Profile(\"dev\")\npublic class MockEmailService implements EmailService {\n    public void sendEmail(String to, String message) {\n        System.out.println(\"Mock: Sending email to \" + to);\n    }\n}\n\n@Service\n@Profile(\"prod\")\npublic class RealEmailService implements EmailService {\n    public void sendEmail(String to, String message) {\n        // Actual email sending logic\n    }\n}\n\nMultiple Profiles:\n@Profile({\"dev\", \"test\"})\npublic class DevTestConfig { }\n\nNegation:\n@Profile(\"!prod\")\npublic class NonProdConfig { }"
    },
    {
      "id": 24,
      "category": "Spring Boot Configuration & Profiles",
      "question": "How to use two databases simultaneously in Spring Boot?",
      "answer": "To use two databases simultaneously in Spring Boot, you need to configure multiple DataSource beans and separate EntityManagerFactory and TransactionManager for each database.\n\nSteps:\n\n1. Add dependencies in pom.xml:\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.postgresql</groupId>\n    <artifactId>postgresql</artifactId>\n</dependency>\n\n2. Configure in application.properties:\n# Primary Database (MySQL)\nspring.datasource.primary.url=jdbc:mysql://localhost:3306/db1\nspring.datasource.primary.username=root\nspring.datasource.primary.password=password\nspring.datasource.primary.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# Secondary Database (PostgreSQL)\nspring.datasource.secondary.url=jdbc:postgresql://localhost:5432/db2\nspring.datasource.secondary.username=postgres\nspring.datasource.secondary.password=password\nspring.datasource.secondary.driver-class-name=org.postgresql.Driver\n\n3. Create Primary DataSource Configuration:\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n    basePackages = \"com.example.primary.repository\",\n    entityManagerFactoryRef = \"primaryEntityManagerFactory\",\n    transactionManagerRef = \"primaryTransactionManager\"\n)\npublic class PrimaryDataSourceConfig {\n    \n    @Primary\n    @Bean(name = \"primaryDataSource\")\n    @ConfigurationProperties(prefix = \"spring.datasource.primary\")\n    public DataSource primaryDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n    \n    @Primary\n    @Bean(name = \"primaryEntityManagerFactory\")\n    public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(\n            EntityManagerFactoryBuilder builder,\n            @Qualifier(\"primaryDataSource\") DataSource dataSource) {\n        return builder\n                .dataSource(dataSource)\n                .packages(\"com.example.primary.entity\")\n                .persistenceUnit(\"primary\")\n                .build();\n    }\n    \n    @Primary\n    @Bean(name = \"primaryTransactionManager\")\n    public PlatformTransactionManager primaryTransactionManager(\n            @Qualifier(\"primaryEntityManagerFactory\") EntityManagerFactory factory) {\n        return new JpaTransactionManager(factory);\n    }\n}\n\n4. Create Secondary DataSource Configuration:\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n    basePackages = \"com.example.secondary.repository\",\n    entityManagerFactoryRef = \"secondaryEntityManagerFactory\",\n    transactionManagerRef = \"secondaryTransactionManager\"\n)\npublic class SecondaryDataSourceConfig {\n    // Similar configuration for secondary database\n}\n\n5. Package Structure:\ncom.example.primary.entity - Primary database entities\ncom.example.primary.repository - Primary database repositories\ncom.example.secondary.entity - Secondary database entities\ncom.example.secondary.repository - Secondary database repositories\n\nKey Points:\n• Use @Primary for default datasource\n• Separate package structure for each database\n• Separate EntityManagerFactory for each database\n• Separate TransactionManager for each database\n• Use @Qualifier to inject specific datasource"
    },
    {
      "id": 25,
      "category": "Spring Boot Configuration & Profiles",
      "question": "How does JPA know which database to use when there are two databases?",
      "answer": "JPA determines which database to use based on the configuration of EntityManagerFactory and the package structure of repositories and entities.\n\nHow It Works:\n\n1. EntityManagerFactory Configuration:\n• Each database has its own EntityManagerFactory\n• EntityManagerFactory is configured with specific DataSource\n• @EnableJpaRepositories specifies which repositories use which EntityManagerFactory\n\n2. Package-Based Separation:\n• Primary DB: basePackages = \"com.example.primary.repository\"\n• Secondary DB: basePackages = \"com.example.secondary.repository\"\n• JPA scans these packages and associates them with respective EntityManagerFactory\n\n3. Entity Manager Factory Reference:\n@EnableJpaRepositories(\n    basePackages = \"com.example.primary.repository\",\n    entityManagerFactoryRef = \"primaryEntityManagerFactory\",\n    transactionManagerRef = \"primaryTransactionManager\"\n)\n• This tells JPA that all repositories in this package use primaryEntityManagerFactory\n• primaryEntityManagerFactory is configured with primary DataSource\n\n4. Repository Usage:\n// This automatically uses primary database\n@Repository\npackage com.example.primary.repository;\npublic interface UserRepository extends JpaRepository<User, Long> { }\n\n// This automatically uses secondary database\n@Repository\npackage com.example.secondary.repository;\npublic interface OrderRepository extends JpaRepository<Order, Long> { }\n\n5. Transaction Management:\n• Each database has its own TransactionManager\n• When you use @Transactional on service methods, specify which transaction manager:\n@Transactional(transactionManager = \"primaryTransactionManager\")\n@Transactional(transactionManager = \"secondaryTransactionManager\")\n\nKey Points:\n• Package structure determines database routing\n• EntityManagerFactory acts as database selector\n• @Primary annotation defines default database\n• No runtime selection - determined at configuration time\n• Repositories automatically use correct database based on package"
    },
    {
      "id": 26,
      "category": "Spring MVC Layer",
      "question": "What is the MVC framework in Spring Boot?",
      "answer": "MVC (Model-View-Controller) is a design pattern that separates application into three interconnected components, promoting organized code and separation of concerns.\n\nComponents:\n\n1. Model:\n• Represents data and business logic\n• Entity classes, DTOs\n• Holds application state\n• Independent of UI\n• Example: User.java, Product.java\n\n2. View:\n• Presentation layer\n• Displays data to user\n• HTML, JSP, Thymeleaf templates\n• Receives user input\n• Example: user-list.html\n\n3. Controller:\n• Handles user requests\n• Processes input\n• Invokes business logic\n• Returns appropriate view\n• Uses @Controller or @RestController\n\nSpring MVC Architecture:\n• DispatcherServlet: Front controller\n• HandlerMapping: Maps requests to controllers\n• Controller: Handles requests\n• Service Layer: Business logic\n• Repository Layer: Data access\n• ViewResolver: Resolves view names\n\nFlow:\n1. Client sends request\n2. DispatcherServlet receives request\n3. HandlerMapping finds appropriate controller\n4. Controller processes request\n5. Controller returns ModelAndView\n6. ViewResolver resolves view\n7. View renders response\n8. Response sent to client\n\nBenefits:\n• Separation of concerns\n• Easy testing\n• Maintainable code\n• Reusable components\n• Parallel development"
    },
    {
      "id": 27,
      "category": "Spring MVC Layer",
      "question": "How does a typical API flow from Controller to Service to DAO work in Spring Boot? (one API example)",
      "answer": "A typical API flow in Spring Boot follows the layered architecture pattern: Controller → Service → Repository (DAO) → Database.\n\nComplete Example - Get User By ID:\n\n1. Entity Layer (Model):\n@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    private String email;\n    // Getters and setters\n}\n\n2. Repository Layer (DAO):\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    Optional<User> findByEmail(String email);\n}\n\n3. Service Layer (Business Logic):\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public User getUserById(Long id) {\n        return userRepository.findById(id)\n            .orElseThrow(() -> new UserNotFoundException(\"User not found with id: \" + id));\n    }\n    \n    public User createUser(User user) {\n        // Business validations\n        if (userRepository.findByEmail(user.getEmail()).isPresent()) {\n            throw new DuplicateEmailException(\"Email already exists\");\n        }\n        return userRepository.save(user);\n    }\n}\n\n4. Controller Layer (API Endpoints):\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUserById(@PathVariable Long id) {\n        User user = userService.getUserById(id);\n        return ResponseEntity.ok(user);\n    }\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@RequestBody User user) {\n        User createdUser = userService.createUser(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);\n    }\n}\n\nAPI Flow for GET /api/users/1:\n\n1. Client Request:\n   GET http://localhost:8080/api/users/1\n\n2. Controller Layer:\n   • @GetMapping(\"/{id}\") receives request\n   • @PathVariable extracts id = 1\n   • Calls userService.getUserById(1)\n\n3. Service Layer:\n   • getUserById() method executes\n   • Contains business logic and validations\n   • Calls userRepository.findById(1)\n\n4. Repository Layer:\n   • JpaRepository method findById(1)\n   • Generates SQL: SELECT * FROM users WHERE id = 1\n   • Executes query against database\n\n5. Database:\n   • Returns user data\n\n6. Return Flow:\n   • Repository returns Optional<User> to Service\n   • Service unwraps Optional, throws exception if empty\n   • Service returns User object to Controller\n   • Controller wraps in ResponseEntity\n   • Returns JSON response to client\n\n7. Client Response:\n{\n    \"id\": 1,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\"\n}\n\nLayered Architecture Benefits:\n• Separation of concerns\n• Each layer has single responsibility\n• Easy to test each layer independently\n• Maintainable and scalable\n• Business logic isolated in service layer"
    },
    {
      "id": 28,
      "category": "Spring MVC Layer",
      "question": "What are the main annotations used in Spring Boot REST APIs?",
      "answer": "Main annotations used in Spring Boot REST APIs:\n\n1. Controller Annotations:\n• @RestController: Marks class as REST controller (combines @Controller + @ResponseBody)\n• @Controller: Marks class as Spring MVC controller\n• @RequestMapping: Maps HTTP requests to handler methods\n• @ResponseBody: Converts return value to HTTP response body\n\n2. Request Mapping Annotations:\n• @GetMapping: Maps HTTP GET requests\n• @PostMapping: Maps HTTP POST requests\n• @PutMapping: Maps HTTP PUT requests\n• @DeleteMapping: Maps HTTP DELETE requests\n• @PatchMapping: Maps HTTP PATCH requests\n\n3. Parameter Annotations:\n• @RequestBody: Binds HTTP request body to method parameter\n• @PathVariable: Extracts values from URI path\n• @RequestParam: Extracts query parameters\n• @RequestHeader: Extracts HTTP headers\n• @RequestPart: Used for multipart requests\n\n4. Response Annotations:\n• @ResponseStatus: Specifies HTTP status code\n• ResponseEntity: Represents entire HTTP response (status, headers, body)\n\n5. Validation Annotations:\n• @Valid: Enables validation for request body\n• @Validated: Spring's variant of @Valid\n\n6. Exception Handling:\n• @ExceptionHandler: Handles specific exceptions\n• @ControllerAdvice: Global exception handling\n• @RestControllerAdvice: Combines @ControllerAdvice + @ResponseBody\n\n7. Configuration Annotations:\n• @Configuration: Marks configuration class\n• @Bean: Declares a bean\n• @Value: Injects values from properties\n• @ConfigurationProperties: Binds properties to bean\n\nExample:\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        return ResponseEntity.ok(user);\n    }\n    \n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public User createUser(@Valid @RequestBody User user) {\n        return userService.save(user);\n    }\n    \n    @GetMapping\n    public List<User> getUsers(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"10\") int size) {\n        return userService.getUsers(page, size);\n    }\n    \n    @GetMapping(\"/header-demo\")\n    public String headerDemo(@RequestHeader(\"User-Agent\") String userAgent) {\n        return \"User-Agent: \" + userAgent;\n    }\n}"
    },
    {
      "id": 29,
      "category": "Spring MVC Layer",
      "question": "What are the different request mappings in Spring Boot? (GET, POST, PUT, DELETE)",
      "answer": "Spring Boot provides different request mapping annotations for various HTTP methods:\n\n1. @GetMapping (HTTP GET):\n• Purpose: Retrieve/read resources\n• Idempotent: Yes (multiple calls produce same result)\n• Request Body: No\n• Use Case: Fetch data, list resources\n• Example:\n@GetMapping(\"/users\")\npublic List<User> getAllUsers() {\n    return userService.findAll();\n}\n\n@GetMapping(\"/users/{id}\")\npublic User getUserById(@PathVariable Long id) {\n    return userService.findById(id);\n}\n\n2. @PostMapping (HTTP POST):\n• Purpose: Create new resources\n• Idempotent: No (multiple calls create multiple resources)\n• Request Body: Yes\n• Use Case: Create new record\n• Example:\n@PostMapping(\"/users\")\npublic ResponseEntity<User> createUser(@RequestBody User user) {\n    User created = userService.save(user);\n    return ResponseEntity.status(HttpStatus.CREATED).body(created);\n}\n\n3. @PutMapping (HTTP PUT):\n• Purpose: Update existing resource (complete replacement)\n• Idempotent: Yes\n• Request Body: Yes (complete object)\n• Use Case: Update entire record\n• Example:\n@PutMapping(\"/users/{id}\")\npublic User updateUser(@PathVariable Long id, @RequestBody User user) {\n    user.setId(id);\n    return userService.update(user);\n}\n\n4. @DeleteMapping (HTTP DELETE):\n• Purpose: Delete resources\n• Idempotent: Yes\n• Request Body: No\n• Use Case: Remove record\n• Example:\n@DeleteMapping(\"/users/{id}\")\npublic ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n    userService.delete(id);\n    return ResponseEntity.noContent().build();\n}\n\n5. @PatchMapping (HTTP PATCH):\n• Purpose: Partial update of resource\n• Idempotent: Yes\n• Request Body: Yes (partial object)\n• Use Case: Update specific fields\n• Example:\n@PatchMapping(\"/users/{id}\")\npublic User partialUpdate(@PathVariable Long id, @RequestBody Map<String, Object> updates) {\n    return userService.partialUpdate(id, updates);\n}\n\nComplete CRUD Example:\n@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n    \n    @Autowired\n    private ProductService productService;\n    \n    // CREATE\n    @PostMapping\n    public ResponseEntity<Product> create(@RequestBody Product product) {\n        return ResponseEntity.status(HttpStatus.CREATED)\n            .body(productService.save(product));\n    }\n    \n    // READ - All\n    @GetMapping\n    public List<Product> getAll() {\n        return productService.findAll();\n    }\n    \n    // READ - By ID\n    @GetMapping(\"/{id}\")\n    public Product getById(@PathVariable Long id) {\n        return productService.findById(id);\n    }\n    \n    // UPDATE - Complete\n    @PutMapping(\"/{id}\")\n    public Product update(@PathVariable Long id, @RequestBody Product product) {\n        return productService.update(id, product);\n    }\n    \n    // UPDATE - Partial\n    @PatchMapping(\"/{id}\")\n    public Product partialUpdate(@PathVariable Long id, @RequestBody Map<String, Object> fields) {\n        return productService.partialUpdate(id, fields);\n    }\n    \n    // DELETE\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> delete(@PathVariable Long id) {\n        productService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n}"
    },
    {
      "id": 30,
      "category": "Spring MVC Layer",
      "question": "What is the difference between POST and PUT?",
      "answer": "POST:\n• Purpose: Create new resource\n• Resource Location: Server decides the URI of created resource\n• Idempotent: No (multiple calls create multiple resources)\n• URI: Collection URI (e.g., /users)\n• Request Body: Required (new resource data)\n• Response: Returns created resource with new ID\n• Status Code: 201 Created\n• Multiple Calls: Creates multiple resources\n• Example: POST /users creates a new user each time\n\nPUT:\n• Purpose: Update existing resource or create at specific URI\n• Resource Location: Client specifies the URI\n• Idempotent: Yes (multiple identical calls produce same result)\n• URI: Specific resource URI (e.g., /users/123)\n• Request Body: Required (complete resource data)\n• Response: Returns updated resource\n• Status Code: 200 OK or 204 No Content\n• Multiple Calls: Same result every time\n• Example: PUT /users/123 updates the same user each time\n\nDetailed Comparison:\n\nScenario 1 - Creating Resources:\n• POST /users (body: {name: \"John\"})\n  → Creates user with ID 1\n• POST /users (body: {name: \"John\"})\n  → Creates another user with ID 2\n  → Two different users created\n\n• PUT /users/100 (body: {id: 100, name: \"John\"})\n  → Creates/updates user with ID 100\n• PUT /users/100 (body: {id: 100, name: \"John\"})\n  → Same user, no duplicate\n  → Idempotent operation\n\nScenario 2 - Updating Resources:\n• POST /users (body: {id: 1, name: \"John Updated\"})\n  → Not typically used for updates\n  → Might create new resource instead\n\n• PUT /users/1 (body: {id: 1, name: \"John Updated\", email: \"john@example.com\"})\n  → Replaces entire resource\n  → All fields must be provided\n  → Missing fields become null\n\nCode Examples:\n\n// POST - Create\n@PostMapping(\"/users\")\npublic ResponseEntity<User> createUser(@RequestBody User user) {\n    User created = userService.save(user);\n    // Server generates ID\n    URI location = ServletUriComponentsBuilder\n        .fromCurrentRequest()\n        .path(\"/{id}\")\n        .buildAndExpand(created.getId())\n        .toUri();\n    return ResponseEntity.created(location).body(created);\n}\n\n// PUT - Update\n@PutMapping(\"/users/{id}\")\npublic ResponseEntity<User> updateUser(\n    @PathVariable Long id,\n    @RequestBody User user) {\n    \n    user.setId(id); // Use ID from path\n    User updated = userService.update(user);\n    return ResponseEntity.ok(updated);\n}\n\nWhen to Use:\n• Use POST: When creating resources and server should assign ID\n• Use PUT: When updating entire resource or creating with client-specified ID\n• Use PATCH: When updating partial fields only"
    },
    {
      "id": 31,
      "category": "Spring MVC Layer",
      "question": "What is the use of Swagger in Spring Boot?",
      "answer": "Swagger is a tool for designing, building, documenting, and consuming REST APIs. In Spring Boot, it automatically generates interactive API documentation.\n\nKey Uses:\n\n1. API Documentation:\n• Automatically generates API documentation\n• Lists all endpoints, methods, parameters\n• Shows request/response models\n• Describes error responses\n• No manual documentation needed\n\n2. Interactive API Testing:\n• Try out APIs directly from browser\n• Execute requests without Postman\n• See responses in real-time\n• Test different parameters\n• Validate API behavior\n\n3. API Discovery:\n• Developers can explore available APIs\n• Understand request/response structure\n• See required vs optional parameters\n• View authentication requirements\n\n4. Client Code Generation:\n• Generate client SDKs\n• Support for multiple languages\n• Consistent API contracts\n\n5. API Design First:\n• Design APIs before implementation\n• Define contracts\n• Team collaboration\n\nImplementation in Spring Boot:\n\n1. Add Dependencies (SpringDoc OpenAPI):\n<dependency>\n    <groupId>org.springdoc</groupId>\n    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>\n    <version>2.0.0</version>\n</dependency>\n\n2. Basic Configuration:\n@Configuration\npublic class SwaggerConfig {\n    @Bean\n    public OpenAPI customOpenAPI() {\n        return new OpenAPI()\n            .info(new Info()\n                .title(\"User Management API\")\n                .version(\"1.0\")\n                .description(\"API for managing users\")\n                .contact(new Contact()\n                    .name(\"Support Team\")\n                    .email(\"support@example.com\")));\n    }\n}\n\n3. Annotating Controllers:\n@RestController\n@RequestMapping(\"/api/users\")\n@Tag(name = \"User Management\", description = \"APIs for user operations\")\npublic class UserController {\n    \n    @Operation(summary = \"Get user by ID\", description = \"Returns a single user\")\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"User found\"),\n        @ApiResponse(responseCode = \"404\", description = \"User not found\")\n    })\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(\n        @Parameter(description = \"ID of user to retrieve\")\n        @PathVariable Long id) {\n        return ResponseEntity.ok(userService.findById(id));\n    }\n    \n    @Operation(summary = \"Create new user\")\n    @PostMapping\n    public ResponseEntity<User> createUser(\n        @io.swagger.v3.oas.annotations.parameters.RequestBody(\n            description = \"User object to create\",\n            required = true)\n        @RequestBody User user) {\n        return ResponseEntity.status(HttpStatus.CREATED)\n            .body(userService.save(user));\n    }\n}\n\n4. Model Annotations:\n@Schema(description = \"User entity\")\npublic class User {\n    \n    @Schema(description = \"Unique identifier\", example = \"1\")\n    private Long id;\n    \n    @Schema(description = \"User's full name\", required = true, example = \"John Doe\")\n    private String name;\n    \n    @Schema(description = \"Email address\", required = true, example = \"john@example.com\")\n    private String email;\n}\n\n5. Access Swagger UI:\n• URL: http://localhost:8080/swagger-ui.html\n• Or: http://localhost:8080/swagger-ui/index.html\n• OpenAPI JSON: http://localhost:8080/v3/api-docs\n\nBenefits:\n• Reduces documentation effort\n• Always up-to-date documentation\n• Improves API usability\n• Facilitates testing\n• Better collaboration between teams\n• Standardized API documentation"
    },
    {
      "id": 32,
      "category": "Spring MVC Layer",
      "question": "Does Spring Boot 3 support Swagger?",
      "answer": "Yes, Spring Boot 3 supports Swagger through SpringDoc OpenAPI 3, but there are important changes from Spring Boot 2.\n\nKey Points:\n\n1. Migration Required:\n• Old: Springfox (discontinued, doesn't work with Spring Boot 3)\n• New: SpringDoc OpenAPI (actively maintained)\n• Spring Boot 3 requires SpringDoc OpenAPI v2.x\n\n2. Why SpringDoc Instead of Springfox:\n• Springfox is not compatible with Spring Boot 3\n• Springfox development has stopped\n• SpringDoc is actively maintained\n• SpringDoc supports Jakarta EE (Spring Boot 3 uses Jakarta instead of javax)\n\n3. Dependencies for Spring Boot 3:\n<dependency>\n    <groupId>org.springdoc</groupId>\n    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>\n    <version>2.3.0</version>\n</dependency>\n\n4. Configuration in application.properties:\nspringdoc.api-docs.path=/api-docs\nspringdoc.swagger-ui.path=/swagger-ui.html\nspringdoc.swagger-ui.enabled=true\n\n5. Basic Setup:\n@Configuration\npublic class OpenAPIConfig {\n    \n    @Bean\n    public OpenAPI customOpenAPI() {\n        return new OpenAPI()\n            .info(new Info()\n                .title(\"My API\")\n                .version(\"3.0\")\n                .description(\"API Documentation for Spring Boot 3\")\n                .license(new License()\n                    .name(\"Apache 2.0\")\n                    .url(\"http://springdoc.org\")));\n    }\n}\n\n6. Controller Example:\n@RestController\n@RequestMapping(\"/api/users\")\n@Tag(name = \"Users\", description = \"User management APIs\")\npublic class UserController {\n    \n    @Operation(\n        summary = \"Get all users\",\n        description = \"Retrieves a list of all users in the system\"\n    )\n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n}\n\n7. Access URLs:\n• Swagger UI: http://localhost:8080/swagger-ui/index.html\n• API Docs: http://localhost:8080/v3/api-docs\n• API Docs YAML: http://localhost:8080/v3/api-docs.yaml\n\nMigration from Spring Boot 2 to Spring Boot 3:\n\nOld (Spring Boot 2 with Springfox):\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-boot-starter</artifactId>\n    <version>3.0.0</version>\n</dependency>\n\nAnnotations changed:\n• @Api → @Tag\n• @ApiOperation → @Operation\n• @ApiParam → @Parameter\n• @ApiModel → @Schema\n• @ApiModelProperty → @Schema\n\nNew (Spring Boot 3 with SpringDoc):\n<dependency>\n    <groupId>org.springdoc</groupId>\n    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>\n    <version>2.3.0</version>\n</dependency>\n\nAnnotations:\n• Use io.swagger.v3.oas.annotations package\n• Same annotations as OpenAPI 3 specification\n\nCommon Issues and Solutions:\n\n1. Jakarta EE Migration:\n• Spring Boot 3 uses jakarta.* instead of javax.*\n• Ensure all dependencies are compatible\n• Update imports from javax to jakarta\n\n2. Path Configuration:\n• Default Swagger UI path changed\n• Configure in application.properties if needed\n\n3. Security Configuration:\n• If using Spring Security, allow Swagger endpoints\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n    http.authorizeHttpRequests(auth ->\n        auth.requestMatchers(\"/swagger-ui/**\", \"/v3/api-docs/**\").permitAll()\n            .anyRequest().authenticated()\n    );\n    return http.build();\n}\n\nConclusion:\n• Yes, Spring Boot 3 fully supports Swagger\n• Use SpringDoc OpenAPI v2.x (not Springfox)\n• Migration required from Spring Boot 2\n• Better features and active maintenance\n• Full OpenAPI 3.0 specification support"
    },
    {
      "id": 33,
      "category": "Spring Data & JPA",
      "question": "What is JPA, and how is it used internally?",
      "answer": "JPA (Java Persistence API) is a specification for object-relational mapping (ORM) in Java. It provides a standard way to manage relational data in Java applications.\n\nWhat is JPA:\n• Specification, not implementation\n• Standard API for ORM\n• Part of Java EE (now Jakarta EE)\n• Defines how Java objects map to database tables\n• Provides CRUD operations without SQL\n\nInternal Working:\n\n1. Entity Mapping:\n• @Entity annotation marks Java class as database table\n• @Table specifies table name\n• @Column maps fields to columns\n• @Id marks primary key\n• JPA creates mapping metadata at startup\n\n2. EntityManager:\n• Core interface of JPA\n• Manages entity lifecycle\n• Performs CRUD operations\n• Creates and executes queries\n• Manages persistence context\n\n3. Persistence Context:\n• First-level cache\n• Stores entity instances\n• Tracks changes to entities\n• Ensures one entity instance per ID\n• Synchronizes changes to database\n\n4. Entity Lifecycle States:\n• New/Transient: Not associated with persistence context\n• Managed/Persistent: Associated with persistence context\n• Detached: Was managed, now disconnected\n• Removed: Marked for deletion\n\n5. Internal Process Flow:\n\nStep 1 - Configuration:\n• Read persistence.xml or Spring Boot properties\n• Load entity classes\n• Create EntityManagerFactory\n• Set up database connection\n\nStep 2 - Entity Manager Creation:\n• EntityManagerFactory creates EntityManager\n• EntityManager manages persistence context\n• One EntityManager per transaction (typically)\n\nStep 3 - CRUD Operations:\n\n// Save/Persist\nUser user = new User(\"John\");\nentityManager.persist(user);\n// JPA tracks this entity\n// INSERT generated at transaction commit\n\n// Find\nUser user = entityManager.find(User.class, 1L);\n// SELECT query executed\n// Entity stored in persistence context\n// Future calls return cached entity\n\n// Update\nUser user = entityManager.find(User.class, 1L);\nuser.setName(\"John Updated\");\n// No explicit update call needed\n// JPA detects changes (dirty checking)\n// UPDATE generated at transaction commit\n\n// Delete\nUser user = entityManager.find(User.class, 1L);\nentityManager.remove(user);\n// DELETE generated at transaction commit\n\nStep 4 - Query Generation:\n• JPA translates method names to SQL\n• Uses metamodel to build queries\n• Applies where clauses, joins, sorting\n• Example: findByNameAndEmail → SELECT * FROM user WHERE name = ? AND email = ?\n\nStep 5 - Transaction Management:\n• Transaction begins\n• Operations tracked in persistence context\n• At commit:\n  - JPA detects all changes (dirty checking)\n  - Generates SQL statements\n  - Executes in order\n  - Flushes to database\n  - Commits transaction\n\nStep 6 - Caching:\n• First-Level Cache (Persistence Context): Automatic, per EntityManager\n• Second-Level Cache (Optional): Shared across EntityManagers\n• Query Cache: Caches query results\n\n6. Key Components:\n\n• Persistence Unit: Configuration of entity classes and database\n• EntityManagerFactory: Creates EntityManager instances\n• EntityManager: Manages entities and persistence context\n• Entity: Java class mapped to database table\n• Query API: JPQL, Criteria API, Native SQL\n\n7. JPA Providers (Implementations):\n• Hibernate (most popular)\n• EclipseLink\n• OpenJPA\n• DataNucleus\n\nExample Internal Flow:\n\n// 1. Spring Boot creates EntityManagerFactory at startup\n// 2. For each transaction, creates EntityManager\n\n@Transactional\npublic void updateUser(Long id, String newName) {\n    // 3. EntityManager created\n    // 4. Begin transaction\n    \n    User user = userRepository.findById(id).get();\n    // 5. SELECT executed\n    // 6. Entity loaded into persistence context\n    \n    user.setName(newName);\n    // 7. Change tracked by JPA (dirty checking)\n    // 8. No explicit save needed\n    \n    // 9. Transaction commits\n    // 10. JPA detects changes\n    // 11. UPDATE SQL generated and executed\n    // 12. Persistence context cleared\n}\n\nBenefits:\n• Database independence\n• Reduced boilerplate code\n• Automatic SQL generation\n• Object-oriented data access\n• Caching support\n• Lazy loading\n• Transaction management"
    },
    {
      "id": 34,
      "category": "Spring Data & JPA",
      "question": "What is the difference between JPA and Hibernate?",
      "answer": "JPA (Java Persistence API):\n• Specification/Standard: Defines rules and interfaces\n• Provider-independent: Can work with any ORM implementation\n• Interfaces only: No implementation code\n• Part of: Jakarta EE specification\n• Package: javax.persistence.* (Java EE) or jakarta.persistence.* (Jakarta EE)\n• Defines: Annotations, EntityManager, Query API\n• Flexibility: Can switch implementations\n• Example: Just defines @Entity, @Table, but doesn't implement them\n\nHibernate:\n• Implementation: Actual ORM framework\n• JPA Provider: Implements JPA specification\n• Standalone: Can be used without JPA\n• Developed by: Red Hat\n• Package: org.hibernate.*\n• Provides: Complete ORM functionality\n• Additional Features: Beyond JPA specification\n• Example: Implements JPA annotations and adds its own like @Formula, @Type\n\nKey Differences:\n\n1. Nature:\n• JPA: Interface/contract (like JDBC)\n• Hibernate: Implementation (like MySQL driver)\n\n2. Features:\n• JPA: Standard features only\n• Hibernate: JPA features + additional proprietary features\n\n3. Annotations:\n• JPA: @Entity, @Table, @Column, @Id, @GeneratedValue, @ManyToOne, etc.\n• Hibernate: All JPA + @Formula, @Type, @Cache, @DynamicUpdate, etc.\n\n4. Usage:\n• JPA: Use EntityManager\n• Hibernate: Can use EntityManager or Session (Hibernate's own API)\n\n5. Portability:\n• JPA: Portable across different providers\n• Hibernate-specific code: Locked to Hibernate\n\n6. Caching:\n• JPA: Defines caching concept\n• Hibernate: Implements first-level and second-level caching\n\n7. Query Language:\n• JPA: JPQL (Java Persistence Query Language)\n• Hibernate: HQL (Hibernate Query Language) - superset of JPQL\n\n8. Configuration:\n• JPA: persistence.xml\n• Hibernate: hibernate.cfg.xml or hibernate.properties\n\nCode Examples:\n\nJPA Standard Code:\n@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"user_name\")\n    private String name;\n}\n\n// Using EntityManager (JPA)\n@PersistenceContext\nprivate EntityManager entityManager;\n\npublic User findUser(Long id) {\n    return entityManager.find(User.class, id);\n}\n\nHibernate-Specific Code:\n@Entity\n@Table(name = \"users\")\n@DynamicUpdate // Hibernate-specific\n@Cache(usage = CacheConcurrencyStrategy.READ_WRITE) // Hibernate-specific\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Formula(\"upper(user_name)\") // Hibernate-specific\n    private String upperName;\n}\n\n// Using Session (Hibernate)\n@Autowired\nprivate SessionFactory sessionFactory;\n\npublic User findUser(Long id) {\n    Session session = sessionFactory.getCurrentSession();\n    return session.get(User.class, id);\n}\n\nDependency Comparison:\n\nJPA only (won't work alone):\n<dependency>\n    <groupId>jakarta.persistence</groupId>\n    <artifactId>jakarta.persistence-api</artifactId>\n    <version>3.0.0</version>\n</dependency>\n\nHibernate (includes JPA):\n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-core</artifactId>\n    <version>6.1.0.Final</version>\n</dependency>\n\nSpring Boot (uses Hibernate as default JPA provider):\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\nRelationship Analogy:\n• JPA is like JDBC (specification)\n• Hibernate is like MySQL Driver (implementation)\n• Just as JDBC needs a driver, JPA needs an implementation like Hibernate\n\nOther JPA Implementations:\n• EclipseLink (Reference implementation)\n• OpenJPA\n• DataNucleus\n\nWhen to Use What:\n\nUse JPA annotations when:\n• Want portability across providers\n• Standard features are sufficient\n• May switch ORM in future\n\nUse Hibernate-specific features when:\n• Need advanced features\n• Performance optimization required\n• Not planning to switch ORM\n• Need second-level caching\n\nBest Practice:\n• Write most code using JPA standard\n• Use Hibernate-specific features only when necessary\n• Keep Hibernate dependencies isolated\n• Makes future migration easier"
    },
    {
      "id": 35,
      "category": "Spring Data & JPA",
      "question": "What are the steps to integrate Hibernate with Spring Boot?",
      "answer": "Spring Boot makes Hibernate integration very simple with auto-configuration. Here are the steps:\n\nStep 1 - Add Dependencies:\n\nIn pom.xml:\n<dependencies>\n    <!-- Spring Boot JPA Starter (includes Hibernate) -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    \n    <!-- Database Driver (choose one) -->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    \n    <!-- OR PostgreSQL -->\n    <dependency>\n        <groupId>org.postgresql</groupId>\n        <artifactId>postgresql</artifactId>\n    </dependency>\n    \n    <!-- OR H2 for testing -->\n    <dependency>\n        <groupId>com.h2database</groupId>\n        <artifactId>h2</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n\nStep 2 - Configure Database in application.properties:\n\n# Database Connection\nspring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\nspring.datasource.password=password\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# Hibernate Properties\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect\nspring.jpa.properties.hibernate.format_sql=true\n\n# Additional Hibernate Settings (optional)\nspring.jpa.properties.hibernate.use_sql_comments=true\nspring.jpa.properties.hibernate.jdbc.batch_size=10\nspring.jpa.properties.hibernate.order_inserts=true\nspring.jpa.properties.hibernate.order_updates=true\n\nHibernate DDL Auto Options:\n• create: Drop and create tables on startup\n• create-drop: Create tables on startup, drop on shutdown\n• update: Update schema without dropping data\n• validate: Only validate schema\n• none: No schema management\n\nStep 3 - Create Entity Classes:\n\n@Entity\n@Table(name = \"users\")\npublic class User {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"user_name\", nullable = false, length = 100)\n    private String name;\n    \n    @Column(unique = true, nullable = false)\n    private String email;\n    \n    @Column(name = \"created_date\")\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date createdDate;\n    \n    // Relationships\n    @OneToMany(mappedBy = \"user\", cascade = CascadeType.ALL)\n    private List<Order> orders;\n    \n    // Constructors, Getters, Setters\n}\n\n@Entity\n@Table(name = \"orders\")\npublic class Order {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"user_id\", nullable = false)\n    private User user;\n    \n    private Double amount;\n    \n    // Constructors, Getters, Setters\n}\n\nStep 4 - Create Repository Interfaces:\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    // Spring Data JPA generates implementation automatically\n    Optional<User> findByEmail(String email);\n    \n    List<User> findByNameContaining(String name);\n    \n    @Query(\"SELECT u FROM User u WHERE u.email = :email\")\n    User findUserByEmail(@Param(\"email\") String email);\n    \n    @Query(value = \"SELECT * FROM users WHERE user_name LIKE %:name%\", nativeQuery = true)\n    List<User> searchByName(@Param(\"name\") String name);\n}\n\nStep 5 - Create Service Layer:\n\n@Service\n@Transactional\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public User saveUser(User user) {\n        user.setCreatedDate(new Date());\n        return userRepository.save(user);\n    }\n    \n    @Transactional(readOnly = true)\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    @Transactional(readOnly = true)\n    public Optional<User> getUserById(Long id) {\n        return userRepository.findById(id);\n    }\n    \n    public User updateUser(Long id, User userDetails) {\n        User user = userRepository.findById(id)\n            .orElseThrow(() -> new RuntimeException(\"User not found\"));\n        user.setName(userDetails.getName());\n        user.setEmail(userDetails.getEmail());\n        return userRepository.save(user);\n    }\n    \n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n}\n\nStep 6 - Create Controller:\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@RequestBody User user) {\n        return ResponseEntity.ok(userService.saveUser(user));\n    }\n    \n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.getAllUsers();\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUserById(@PathVariable Long id) {\n        return userService.getUserById(id)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @PutMapping(\"/{id}\")\n    public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody User user) {\n        return ResponseEntity.ok(userService.updateUser(id, user));\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteUser(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n\nStep 7 - Main Application Class:\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\nStep 8 - Optional Advanced Configuration:\n\nCreate configuration class for advanced Hibernate settings:\n\n@Configuration\n@EnableTransactionManagement\npublic class HibernateConfig {\n    \n    @Bean\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory(\n            DataSource dataSource) {\n        \n        LocalContainerEntityManagerFactoryBean em = \n            new LocalContainerEntityManagerFactoryBean();\n        em.setDataSource(dataSource);\n        em.setPackagesToScan(\"com.example.entity\");\n        \n        JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();\n        em.setJpaVendorAdapter(vendorAdapter);\n        em.setJpaProperties(hibernateProperties());\n        \n        return em;\n    }\n    \n    private Properties hibernateProperties() {\n        Properties properties = new Properties();\n        properties.put(\"hibernate.dialect\", \"org.hibernate.dialect.MySQL8Dialect\");\n        properties.put(\"hibernate.show_sql\", \"true\");\n        properties.put(\"hibernate.format_sql\", \"true\");\n        properties.put(\"hibernate.hbm2ddl.auto\", \"update\");\n        properties.put(\"hibernate.jdbc.batch_size\", \"10\");\n        properties.put(\"hibernate.cache.use_second_level_cache\", \"true\");\n        properties.put(\"hibernate.cache.region.factory_class\", \n            \"org.hibernate.cache.jcache.JCacheRegionFactory\");\n        return properties;\n    }\n}\n\nThat's it! Spring Boot auto-configures Hibernate when it detects:\n• spring-boot-starter-data-jpa dependency\n• Database driver in classpath\n• Database properties in application.properties\n\nNo additional configuration needed unless you need advanced customization."
    },
    {
      "id": 36,
      "category": "Spring Data & JPA",
      "question": "What does a Repository do in Spring Boot?",
      "answer": "Repository in Spring Boot is an interface that provides data access abstraction and eliminates boilerplate code for database operations.\n\nKey Functions:\n\n1. Data Access Layer:\n• Acts as bridge between service layer and database\n• Encapsulates data access logic\n• Provides CRUD operations\n• Executes queries\n• Manages database transactions\n\n2. Spring Data JPA Features:\n• Automatically implements repository interfaces\n• Generates SQL from method names\n• Provides built-in CRUD methods\n• Supports custom queries\n• Pagination and sorting support\n\n3. Repository Hierarchy:\n\nRepository (Base interface)\n└── CrudRepository (CRUD operations)\n    └── PagingAndSortingRepository (Pagination + Sorting)\n        └── JpaRepository (JPA specific + all above)\n\nRepository Types:\n\n1. JpaRepository (Most commonly used):\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Inherits all methods\n}\n\nProvides:\n• save(entity)\n• saveAll(entities)\n• findById(id)\n• findAll()\n• count()\n• deleteById(id)\n• delete(entity)\n• deleteAll()\n• flush()\n• saveAndFlush(entity)\n• And more...\n\n2. CrudRepository:\npublic interface ProductRepository extends CrudRepository<Product, Long> {\n    // Basic CRUD only\n}\n\n3. PagingAndSortingRepository:\npublic interface OrderRepository extends PagingAndSortingRepository<Order, Long> {\n    // CRUD + Pagination + Sorting\n}\n\nRepository Capabilities:\n\n1. Built-in Methods:\nList<User> users = userRepository.findAll();\nOptional<User> user = userRepository.findById(1L);\nUser saved = userRepository.save(newUser);\nuserRepository.deleteById(1L);\nlong count = userRepository.count();\nboolean exists = userRepository.existsById(1L);\n\n2. Query Derivation (Method Name Queries):\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    // Find by single field\n    List<User> findByName(String name);\n    \n    // Find by multiple fields\n    List<User> findByNameAndEmail(String name, String email);\n    \n    // Like queries\n    List<User> findByNameContaining(String keyword);\n    List<User> findByNameStartingWith(String prefix);\n    \n    // Comparison\n    List<User> findByAgeGreaterThan(int age);\n    List<User> findByAgeLessThanEqual(int age);\n    \n    // Sorting\n    List<User> findByNameOrderByAgeDesc(String name);\n    \n    // Top/First\n    User findFirstByOrderByCreatedDateDesc();\n    List<User> findTop5ByOrderByAgeDesc();\n    \n    // Exists\n    boolean existsByEmail(String email);\n    \n    // Count\n    long countByStatus(String status);\n    \n    // Delete\n    void deleteByName(String name);\n}\n\n3. Custom JPQL Queries:\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    @Query(\"SELECT u FROM User u WHERE u.email = :email\")\n    User findByEmailAddress(@Param(\"email\") String email);\n    \n    @Query(\"SELECT u FROM User u WHERE u.age BETWEEN :minAge AND :maxAge\")\n    List<User> findByAgeRange(@Param(\"minAge\") int min, @Param(\"maxAge\") int max);\n    \n    @Query(\"SELECT u FROM User u JOIN u.orders o WHERE o.amount > :amount\")\n    List<User> findUsersWithOrdersGreaterThan(@Param(\"amount\") Double amount);\n}\n\n4. Native SQL Queries:\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    @Query(value = \"SELECT * FROM users WHERE user_name LIKE %:name%\", nativeQuery = true)\n    List<User> searchByName(@Param(\"name\") String name);\n    \n    @Query(value = \"SELECT COUNT(*) FROM users WHERE status = :status\", nativeQuery = true)\n    int countUsersByStatus(@Param(\"status\") String status);\n}\n\n5. Modifying Queries:\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    @Modifying\n    @Transactional\n    @Query(\"UPDATE User u SET u.status = :status WHERE u.id = :id\")\n    int updateUserStatus(@Param(\"id\") Long id, @Param(\"status\") String status);\n    \n    @Modifying\n    @Transactional\n    @Query(\"DELETE FROM User u WHERE u.status = :status\")\n    void deleteByStatus(@Param(\"status\") String status);\n}\n\n6. Pagination and Sorting:\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    Page<User> findByStatus(String status, Pageable pageable);\n    \n    List<User> findByAgeGreaterThan(int age, Sort sort);\n}\n\n// Usage in Service:\nPageable pageable = PageRequest.of(0, 10, Sort.by(\"name\").ascending());\nPage<User> users = userRepository.findByStatus(\"ACTIVE\", pageable);\n\n7. Projections:\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    @Query(\"SELECT u.name as name, u.email as email FROM User u\")\n    List<UserProjection> findAllProjections();\n}\n\ninterface UserProjection {\n    String getName();\n    String getEmail();\n}\n\nUsage Example:\n\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    public Optional<User> getUserById(Long id) {\n        return userRepository.findById(id);\n    }\n    \n    public User saveUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n    \n    public List<User> searchUsers(String keyword) {\n        return userRepository.findByNameContaining(keyword);\n    }\n    \n    public Page<User> getUsersPaginated(int page, int size) {\n        Pageable pageable = PageRequest.of(page, size);\n        return userRepository.findAll(pageable);\n    }\n}\n\nBenefits:\n• No boilerplate code\n• Type-safe queries\n• Automatic implementation\n• Easy to test\n• Built-in pagination and sorting\n• Database-independent\n• Consistent API across entities"
    },
    {
      "id": 37,
      "category": "Spring Data & JPA",
      "question": "What is the difference between Spring Data JPA and Hibernate?",
      "answer": "Spring Data JPA:\n• Abstraction Layer: Built on top of JPA\n• Purpose: Simplifies data access layer\n• Repository Interface: Provides repository pattern implementation\n• Boilerplate Reduction: Eliminates repetitive DAO code\n• Query Generation: Generates queries from method names\n• Not an ORM: Doesn't handle object-relational mapping directly\n• Uses: JPA provider underneath (like Hibernate)\n• Package: org.springframework.data.jpa\n• Configuration: Spring-based configuration\n\nHibernate:\n• ORM Framework: Implements JPA specification\n• Purpose: Maps Java objects to database tables\n• Session/EntityManager: Core APIs for persistence\n• Full ORM: Handles complete object-relational mapping\n• SQL Generation: Generates SQL for CRUD operations\n• Standalone: Can work without Spring\n• Provider: JPA provider implementation\n• Package: org.hibernate\n• Configuration: hibernate.cfg.xml or properties\n\nKey Differences:\n\n1. Level of Abstraction:\n• Spring Data JPA: High-level abstraction over JPA\n• Hibernate: Lower-level ORM implementation\n• Relationship: Spring Data JPA → JPA → Hibernate → Database\n\n2. Primary Purpose:\n• Spring Data JPA: Simplify repository layer\n• Hibernate: Object-Relational Mapping\n\n3. Code Examples:\n\nSpring Data JPA:\npublic interface UserRepository extends JpaRepository<User, Long> {\n    List<User> findByName(String name); // No implementation needed!\n}\n\n// Usage\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<User> getUsers() {\n        return userRepository.findAll(); // Spring Data JPA method\n    }\n}\n\nHibernate (Without Spring Data JPA):\n@Repository\npublic class UserDao {\n    @PersistenceContext\n    private EntityManager entityManager;\n    \n    public List<User> findByName(String name) {\n        return entityManager\n            .createQuery(\"FROM User WHERE name = :name\", User.class)\n            .setParameter(\"name\", name)\n            .getResultList();\n    }\n    \n    public List<User> findAll() {\n        return entityManager\n            .createQuery(\"FROM User\", User.class)\n            .getResultList();\n    }\n}\n\n4. Features:\n\nSpring Data JPA Provides:\n• Repository interfaces (JpaRepository, CrudRepository)\n• Query derivation from method names\n• @Query annotation for custom queries\n• Pagination and sorting\n• Auditing support\n• Specifications for dynamic queries\n• Projections\n• No implementation code needed\n\nHibernate Provides:\n• Entity mapping (@Entity, @Table)\n• Relationship mapping (@OneToMany, @ManyToOne)\n• Lazy/Eager loading\n• Caching (first-level, second-level)\n• HQL (Hibernate Query Language)\n• Session management\n• Transaction management\n• Dirty checking\n• Automatic SQL generation\n\n5. Dependencies:\n\nSpring Data JPA:\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n<!-- This includes Hibernate as default JPA provider -->\n\nHibernate Only:\n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-core</artifactId>\n</dependency>\n\n6. Query Methods:\n\nSpring Data JPA - Method Name Queries:\npublic interface UserRepository extends JpaRepository<User, Long> {\n    List<User> findByEmailAndStatus(String email, String status);\n    List<User> findByAgeGreaterThan(int age);\n    List<User> findByNameContaining(String keyword);\n}\n// Spring Data JPA generates implementation automatically\n\nHibernate - Manual Queries:\npublic class UserDao {\n    public List<User> findByEmailAndStatus(String email, String status) {\n        return entityManager.createQuery(\n            \"FROM User WHERE email = :email AND status = :status\", User.class)\n            .setParameter(\"email\", email)\n            .setParameter(\"status\", status)\n            .getResultList();\n    }\n}\n// You write the query manually\n\n7. Working Together:\n\nSpring Boot Application typically uses both:\n\n@Entity // Hibernate annotation (JPA standard)\n@Table(name = \"users\") // Hibernate annotation\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    // Hibernate handles this mapping\n}\n\n@Repository // Spring annotation\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Spring Data JPA provides implementation\n    // Hibernate executes the actual queries\n    List<User> findByName(String name);\n}\n\nFlow:\n1. Spring Data JPA receives method call\n2. Parses method name and creates query\n3. Delegates to JPA EntityManager\n4. Hibernate (JPA provider) executes SQL\n5. Returns mapped entities\n\n8. When to Use What:\n\nUse Spring Data JPA when:\n• Building Spring Boot applications\n• Want to reduce boilerplate code\n• Need simple CRUD operations\n• Want query method derivation\n• Need pagination and sorting\n\nUse Hibernate Directly when:\n• Complex queries not supported by Spring Data JPA\n• Need Hibernate-specific features\n• Working without Spring framework\n• Need fine-grained control\n• Performance optimization required\n\nRelationship Summary:\n• Spring Data JPA is built on top of JPA\n• Hibernate implements JPA\n• Spring Data JPA uses Hibernate (by default) underneath\n• They complement each other\n• Most Spring Boot apps use both together"
    },
    {
      "id": 38,
      "category": "Spring Data & JPA",
      "question": "How do you connect Spring Boot with JPA?",
      "answer": "Connecting Spring Boot with JPA involves adding dependencies, configuring database properties, and creating entities and repositories. Here's a complete guide:\n\nStep 1 - Add Dependencies:\n\n<dependencies>\n    <!-- Spring Boot JPA Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    \n    <!-- Database Driver (MySQL example) -->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n\nStep 2 - Configure Database in application.properties:\n\n# DataSource Configuration\nspring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\nspring.datasource.password=password\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# JPA Configuration\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect\nspring.jpa.properties.hibernate.format_sql=true\n\n# Connection Pool Settings (optional)\nspring.datasource.hikari.maximum-pool-size=10\nspring.datasource.hikari.minimum-idle=5\n\nOr using YAML (application.yml):\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n    properties:\n      hibernate:\n        dialect: org.hibernate.dialect.MySQL8Dialect\n        format_sql: true\n\nStep 3 - Create Entity Class:\n\npackage com.example.entity;\n\nimport javax.persistence.*;\nimport java.util.Date;\n\n@Entity\n@Table(name = \"users\")\npublic class User {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"full_name\", nullable = false, length = 100)\n    private String name;\n    \n    @Column(unique = true, nullable = false)\n    private String email;\n    \n    @Column(name = \"phone_number\")\n    private String phone;\n    \n    @Temporal(TemporalType.TIMESTAMP)\n    @Column(name = \"created_at\")\n    private Date createdAt;\n    \n    // Constructors\n    public User() {\n    }\n    \n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n        this.createdAt = new Date();\n    }\n    \n    // Getters and Setters\n    public Long getId() {\n        return id;\n    }\n    \n    public void setId(Long id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getEmail() {\n        return email;\n    }\n    \n    public void setEmail(String email) {\n        this.email = email;\n    }\n    \n    // Other getters and setters...\n}\n\nStep 4 - Create Repository Interface:\n\npackage com.example.repository;\n\nimport com.example.entity.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\nimport java.util.Optional;\nimport java.util.List;\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    // Custom query methods\n    Optional<User> findByEmail(String email);\n    \n    List<User> findByNameContaining(String keyword);\n    \n    boolean existsByEmail(String email);\n}\n\nStep 5 - Create Service Layer:\n\npackage com.example.service;\n\nimport com.example.entity.User;\nimport com.example.repository.UserRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\n@Transactional\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public User createUser(User user) {\n        if (userRepository.existsByEmail(user.getEmail())) {\n            throw new RuntimeException(\"Email already exists\");\n        }\n        return userRepository.save(user);\n    }\n    \n    @Transactional(readOnly = true)\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    @Transactional(readOnly = true)\n    public Optional<User> getUserById(Long id) {\n        return userRepository.findById(id);\n    }\n    \n    @Transactional(readOnly = true)\n    public Optional<User> getUserByEmail(String email) {\n        return userRepository.findByEmail(email);\n    }\n    \n    public User updateUser(Long id, User userDetails) {\n        User user = userRepository.findById(id)\n            .orElseThrow(() -> new RuntimeException(\"User not found\"));\n        \n        user.setName(userDetails.getName());\n        user.setEmail(userDetails.getEmail());\n        user.setPhone(userDetails.getPhone());\n        \n        return userRepository.save(user);\n    }\n    \n    public void deleteUser(Long id) {\n        if (!userRepository.existsById(id)) {\n            throw new RuntimeException(\"User not found\");\n        }\n        userRepository.deleteById(id);\n    }\n    \n    @Transactional(readOnly = true)\n    public List<User> searchUsers(String keyword) {\n        return userRepository.findByNameContaining(keyword);\n    }\n}\n\nStep 6 - Create REST Controller:\n\npackage com.example.controller;\n\nimport com.example.entity.User;\nimport com.example.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@RequestBody User user) {\n        User created = userService.createUser(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(created);\n    }\n    \n    @GetMapping\n    public ResponseEntity<List<User>> getAllUsers() {\n        return ResponseEntity.ok(userService.getAllUsers());\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUserById(@PathVariable Long id) {\n        return userService.getUserById(id)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @GetMapping(\"/email/{email}\")\n    public ResponseEntity<User> getUserByEmail(@PathVariable String email) {\n        return userService.getUserByEmail(email)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @PutMapping(\"/{id}\")\n    public ResponseEntity<User> updateUser(\n        @PathVariable Long id,\n        @RequestBody User user) {\n        return ResponseEntity.ok(userService.updateUser(id, user));\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteUser(id);\n        return ResponseEntity.noContent().build();\n    }\n    \n    @GetMapping(\"/search\")\n    public ResponseEntity<List<User>> searchUsers(@RequestParam String keyword) {\n        return ResponseEntity.ok(userService.searchUsers(keyword));\n    }\n}\n\nStep 7 - Main Application Class:\n\npackage com.example;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\nStep 8 - Test the Application:\n\n1. Create User:\nPOST http://localhost:8080/api/users\nBody: {\"name\": \"John Doe\", \"email\": \"john@example.com\"}\n\n2. Get All Users:\nGET http://localhost:8080/api/users\n\n3. Get User by ID:\nGET http://localhost:8080/api/users/1\n\n4. Update User:\nPUT http://localhost:8080/api/users/1\nBody: {\"name\": \"John Updated\", \"email\": \"john.updated@example.com\"}\n\n5. Delete User:\nDELETE http://localhost:8080/api/users/1\n\nKey Points:\n• Spring Boot auto-configures JPA when dependencies are present\n• No XML configuration needed\n• Hibernate is default JPA provider\n• Entity classes map to database tables\n• Repositories provide data access methods\n• @Transactional manages transactions automatically\n• Connection pooling handled by HikariCP (default)"
    },
    {
      "id": 39,
      "category": "Transaction Management",
      "question": "What is transaction management in Spring Boot applications?",
      "answer": "Transaction management in Spring Boot ensures data consistency and integrity by treating a group of database operations as a single unit of work that either completes fully or rolls back entirely.\n\nKey Concepts:\n\n• ACID Properties: Atomicity, Consistency, Isolation, Durability\n• All-or-Nothing: All operations succeed or all fail\n• Data Integrity: Maintains database consistency\n• Rollback Support: Automatic rollback on exceptions\n• Spring manages transactions declaratively or programmatically\n\nTypes of Transaction Management:\n\n1. Declarative (using @Transactional):\n• Annotation-based\n• Non-invasive\n• Preferred approach\n• Uses AOP (Aspect-Oriented Programming)\n\n2. Programmatic:\n• Manual transaction control\n• More control but verbose\n• Uses TransactionTemplate or PlatformTransactionManager\n\nHow It Works:\n\n• Spring creates proxy around @Transactional methods\n• Transaction begins when method starts\n• Operations execute within transaction\n• Commit on successful completion\n• Rollback on unchecked exceptions\n\nTransaction Attributes:\n\n• Propagation: How transactions relate to each other\n• Isolation: Level of data visibility between transactions\n• Timeout: Maximum time for transaction\n• ReadOnly: Optimization for read-only operations\n• RollbackFor: Which exceptions trigger rollback\n\nExample:\n\n@Service\npublic class PaymentService {\n    \n    @Autowired\n    private AccountRepository accountRepository;\n    \n    @Autowired\n    private TransactionRepository transactionRepository;\n    \n    @Transactional\n    public void transferMoney(Long fromAccount, Long toAccount, Double amount) {\n        // All operations in single transaction\n        Account from = accountRepository.findById(fromAccount).get();\n        Account to = accountRepository.findById(toAccount).get();\n        \n        from.setBalance(from.getBalance() - amount);\n        to.setBalance(to.getBalance() + amount);\n        \n        accountRepository.save(from);\n        accountRepository.save(to);\n        \n        Transaction txn = new Transaction(fromAccount, toAccount, amount);\n        transactionRepository.save(txn);\n        \n        // If any operation fails, all rollback\n    }\n}\n\nBenefits:\n\n• Ensures data consistency\n• Automatic rollback on errors\n• Simplified error handling\n• Improved application reliability\n• Database independence\n• Supports distributed transactions"
    },
    {
      "id": 40,
      "category": "Transaction Management",
      "question": "What is the purpose of the @Transactional annotation in Spring Boot?",
      "answer": "The @Transactional annotation in Spring Boot provides declarative transaction management, allowing you to manage database transactions without writing explicit transaction handling code.\n\nCore Purpose:\n\n• Automatically begins a transaction when the method starts\n• Commits the transaction if the method completes successfully\n• Rolls back the transaction if an exception occurs\n• Eliminates boilerplate transaction management code\n• Provides AOP-based proxy mechanism for transaction handling\n\nKey Features:\n\n• Declarative Approach: Add annotation instead of manual transaction code\n• Automatic Commit/Rollback: Based on method execution outcome\n• Exception Handling: Rolls back on RuntimeException by default\n• Propagation Control: Defines how transactions interact with each other\n• Isolation Levels: Controls concurrent transaction behavior\n• Read-Only Optimization: Improves performance for read operations\n\nCommon Attributes:\n\n• propagation: Defines transaction propagation behavior\n• isolation: Sets isolation level for concurrent transactions\n• timeout: Maximum seconds a transaction can run\n• readOnly: Optimizes for read-only operations\n• rollbackFor: Specifies exceptions that trigger rollback\n• noRollbackFor: Specifies exceptions that don't trigger rollback\n\nBasic Example:\n\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private InventoryRepository inventoryRepository;\n    \n    @Transactional\n    public Order createOrder(OrderRequest request) {\n        // All operations happen in single transaction\n        Order order = new Order();\n        order.setProduct(request.getProduct());\n        order.setQuantity(request.getQuantity());\n        \n        // Save order\n        Order savedOrder = orderRepository.save(order);\n        \n        // Update inventory\n        Inventory inventory = inventoryRepository.findByProduct(request.getProduct());\n        inventory.setQuantity(inventory.getQuantity() - request.getQuantity());\n        inventoryRepository.save(inventory);\n        \n        return savedOrder;\n        // If any operation fails, both rollback\n    }\n}\n\nAdvanced Example with Attributes:\n\n@Service\npublic class PaymentService {\n    \n    @Transactional(\n        propagation = Propagation.REQUIRED,\n        isolation = Isolation.READ_COMMITTED,\n        timeout = 30,\n        rollbackFor = {SQLException.class, CustomException.class},\n        noRollbackFor = {NotFoundException.class}\n    )\n    public Payment processPayment(PaymentRequest request) {\n        // Transaction with custom configuration\n        Payment payment = new Payment();\n        payment.setAmount(request.getAmount());\n        payment.setStatus(\"PROCESSING\");\n        \n        paymentRepository.save(payment);\n        \n        // Call external payment gateway\n        boolean success = paymentGateway.charge(request);\n        \n        if (success) {\n            payment.setStatus(\"SUCCESS\");\n        } else {\n            payment.setStatus(\"FAILED\");\n            throw new PaymentFailedException(\"Payment processing failed\");\n        }\n        \n        return paymentRepository.save(payment);\n    }\n    \n    @Transactional(readOnly = true)\n    public List<Payment> getPaymentHistory(Long userId) {\n        // Read-only transaction for better performance\n        return paymentRepository.findByUserId(userId);\n    }\n}\n\nWhere to Use:\n\n• Class Level: Applies to all public methods in the class\n• Method Level: Applies to specific method only\n• Method annotation overrides class-level annotation\n\nClass Level Example:\n\n@Service\n@Transactional // Applied to all methods\npublic class UserService {\n    \n    public User createUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    @Transactional(readOnly = true) // Override for this method\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n}\n\nDefault Rollback Behavior:\n\n• Rolls back on: RuntimeException and Error (unchecked exceptions)\n• Does NOT roll back on: Checked exceptions (Exception and subclasses)\n• Can be customized using rollbackFor and noRollbackFor attributes\n\nCustom Rollback Example:\n\n@Service\npublic class AccountService {\n    \n    @Transactional(rollbackFor = Exception.class)\n    public void updateAccount(Account account) throws Exception {\n        // Will rollback even for checked exceptions\n        accountRepository.save(account);\n        \n        if (account.getBalance() < 0) {\n            throw new Exception(\"Insufficient balance\");\n            // This will trigger rollback\n        }\n    }\n}\n\nBenefits:\n\n• Cleaner Code: No explicit transaction management code\n• Consistency: Ensures ACID properties automatically\n• Error Handling: Automatic rollback on failures\n• Declarative: Separation of business logic and transaction logic\n• Flexible: Highly configurable for various scenarios\n• Testable: Easy to test with or without transactions\n\nImportant Notes:\n\n• Only works on public methods\n• Self-invocation doesn't work (calling @Transactional method from same class)\n• Requires proxy mechanism (AOP)\n• Spring creates proxy around the annotated bean\n• Must be called from outside the bean for proxy to intercept"
    },
    {
      "id": 41,
      "category": "Transaction Management",
      "question": "Can we use try-catch inside @Transactional(rollbackFor = {SQLException.class, CustomException.class})?",
      "answer": "Yes, you can use try-catch inside a @Transactional method, but it has important implications for transaction rollback behavior. Understanding how try-catch interacts with @Transactional is crucial for proper transaction management.\n\nKey Concept:\n\n• If you catch an exception inside @Transactional method, Spring won't see it\n• Spring only rolls back if exception propagates out of the method\n• Catching and handling exception prevents automatic rollback\n• You must manually trigger rollback if needed\n\nScenario 1 - Exception Caught, No Rollback:\n\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private InventoryService inventoryService;\n    \n    @Transactional(rollbackFor = {SQLException.class})\n    public String createOrder(Order order) {\n        try {\n            orderRepository.save(order);\n            inventoryService.updateInventory(order);\n            return \"Order created successfully\";\n        } catch (SQLException e) {\n            // Exception caught here - NO ROLLBACK HAPPENS\n            // Transaction will commit even though error occurred\n            System.out.println(\"Error: \" + e.getMessage());\n            return \"Order creation failed\";\n        }\n        // Order saved in DB even though exception occurred!\n    }\n}\n\nScenario 2 - Exception Re-thrown, Rollback Happens:\n\n@Service\npublic class OrderService {\n    \n    @Transactional(rollbackFor = {SQLException.class, CustomException.class})\n    public String createOrder(Order order) throws CustomException {\n        try {\n            orderRepository.save(order);\n            inventoryService.updateInventory(order);\n            return \"Order created successfully\";\n        } catch (SQLException e) {\n            // Log the error\n            log.error(\"SQL Error occurred: {}\", e.getMessage());\n            \n            // Re-throw to trigger rollback\n            throw new CustomException(\"Failed to create order\", e);\n            // Now rollback will happen\n        }\n    }\n}\n\nScenario 3 - Manual Rollback Using TransactionAspectSupport:\n\n@Service\npublic class PaymentService {\n    \n    @Transactional(rollbackFor = {SQLException.class})\n    public PaymentResponse processPayment(Payment payment) {\n        try {\n            paymentRepository.save(payment);\n            \n            boolean result = externalPaymentGateway.charge(payment);\n            \n            if (!result) {\n                throw new SQLException(\"Payment gateway failed\");\n            }\n            \n            return new PaymentResponse(\"SUCCESS\", payment.getId());\n            \n        } catch (SQLException e) {\n            // Manually mark transaction for rollback\n            TransactionAspectSupport.currentTransactionStatus()\n                .setRollbackOnly();\n            \n            // Log error and return response\n            log.error(\"Payment failed: {}\", e.getMessage());\n            return new PaymentResponse(\"FAILED\", null);\n            // Transaction will rollback but method returns normally\n        }\n    }\n}\n\nScenario 4 - Partial Error Handling:\n\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private EmailService emailService;\n    \n    @Transactional(rollbackFor = {SQLException.class})\n    public User registerUser(User user) throws SQLException {\n        try {\n            // Critical database operation\n            User savedUser = userRepository.save(user);\n            \n            try {\n                // Non-critical operation\n                emailService.sendWelcomeEmail(user.getEmail());\n            } catch (EmailException e) {\n                // Log email failure but don't rollback user creation\n                log.warn(\"Failed to send welcome email: {}\", e.getMessage());\n                // Transaction continues, user still saved\n            }\n            \n            return savedUser;\n            \n        } catch (SQLException e) {\n            // Critical error - re-throw to rollback\n            log.error(\"Failed to save user: {}\", e.getMessage());\n            throw e; // Rollback happens\n        }\n    }\n}\n\nScenario 5 - Catch Specific, Let Others Propagate:\n\n@Service\npublic class AccountService {\n    \n    @Transactional(rollbackFor = {SQLException.class, InsufficientFundsException.class})\n    public void transferMoney(Long fromId, Long toId, Double amount) \n            throws InsufficientFundsException, SQLException {\n        try {\n            Account from = accountRepository.findById(fromId).get();\n            Account to = accountRepository.findById(toId).get();\n            \n            if (from.getBalance() < amount) {\n                throw new InsufficientFundsException(\"Not enough balance\");\n            }\n            \n            from.setBalance(from.getBalance() - amount);\n            to.setBalance(to.getBalance() + amount);\n            \n            accountRepository.save(from);\n            accountRepository.save(to);\n            \n        } catch (InsufficientFundsException e) {\n            // Business exception - log and re-throw\n            log.warn(\"Transfer failed: {}\", e.getMessage());\n            throw e; // Rollback happens\n            \n        } catch (Exception e) {\n            // Unexpected exception - wrap and throw\n            log.error(\"Unexpected error: {}\", e.getMessage());\n            throw new SQLException(\"Transfer failed\", e); // Rollback happens\n        }\n    }\n}\n\nBest Practices:\n\n• Let exceptions propagate if you want rollback to happen\n• Use TransactionAspectSupport.currentTransactionStatus().setRollbackOnly() if you catch exception but need rollback\n• Catch and suppress only non-critical exceptions\n• Always re-throw exceptions for critical operations\n• Log exceptions before re-throwing for debugging\n• Don't catch RuntimeException unless you have good reason\n• Document your exception handling strategy clearly\n\nWhen to Catch Exceptions:\n\n• To add logging or custom error messages\n• To convert exception types\n• To handle non-critical failures gracefully\n• To perform cleanup operations\n• To return user-friendly error responses\n\nWhen NOT to Catch:\n\n• If you want automatic rollback to happen\n• Unless you manually trigger rollback\n• For critical operations where consistency is required\n• When you don't have specific handling logic\n\nImportant Rules:\n\n• Caught exception = No automatic rollback\n• Re-thrown exception = Rollback happens\n• Manual setRollbackOnly() = Rollback even if caught\n• Transaction commits unless explicitly marked for rollback or exception propagates"
    },
    {
      "id": 42,
      "category": "Transaction Management",
      "question": "What is transaction propagation? (in short)",
      "answer": "Transaction propagation defines how transactions relate to each other when one transactional method calls another transactional method. It determines whether the called method should run within the existing transaction, create a new one, or execute without a transaction.\n\nCore Concept:\n\n• Controls transaction behavior when methods call each other\n• Specified using propagation attribute in @Transactional\n• Default is REQUIRED\n• Affects how nested method calls handle transactions\n\nSimple Explanation:\n\n• When Method A (with transaction) calls Method B (with transaction)\n• Propagation decides: Should B use A's transaction or create its own?\n\nCommon Scenarios:\n\nPropagation.REQUIRED (Default):\n• Use existing transaction if present\n• Create new transaction if none exists\n• Most commonly used\n\nPropagation.REQUIRES_NEW:\n• Always create a new transaction\n• Suspend the current transaction if exists\n• Inner transaction independent of outer\n\nPropagation.NESTED:\n• Create nested transaction within existing one\n• Inner transaction can rollback without affecting outer\n• Outer rollback affects inner\n\nQuick Example:\n\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private PaymentService paymentService;\n    \n    @Transactional\n    public void createOrder(Order order) {\n        // Transaction T1 starts here\n        orderRepository.save(order);\n        \n        // Calls another transactional method\n        paymentService.processPayment(order.getPayment());\n        \n        // How does payment transaction behave?\n        // Depends on propagation setting\n    }\n}\n\n@Service\npublic class PaymentService {\n    \n    // REQUIRED: Uses same transaction as createOrder\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void processPayment(Payment payment) {\n        paymentRepository.save(payment);\n    }\n    \n    // REQUIRES_NEW: Creates new independent transaction\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void logPaymentAttempt(Payment payment) {\n        logRepository.save(new PaymentLog(payment));\n        // Saved even if createOrder rolls back\n    }\n}\n\nKey Points:\n\n• Determines transaction boundaries in method call chains\n• Affects commit and rollback behavior\n• Critical for nested transactional operations\n• Default REQUIRED works for most cases\n• Use REQUIRES_NEW for independent operations (like logging)\n• Important for maintaining data consistency"
    },
    {
      "id": 43,
      "category": "Transaction Management",
      "question": "What are the different propagation levels in Spring transactions?",
      "answer": "Spring provides seven transaction propagation levels that define how transactions behave when transactional methods call each other. Each level controls whether to use an existing transaction, create a new one, or execute without a transaction.\n\n1. REQUIRED (Default):\n\n• Most commonly used propagation level\n• Joins existing transaction if present\n• Creates new transaction if none exists\n• Both methods share same transaction\n• If inner fails, outer also rolls back\n\nExample:\n\n@Service\npublic class OrderService {\n    \n    @Transactional(propagation = Propagation.REQUIRED)\n    public void createOrder(Order order) {\n        orderRepository.save(order);\n        inventoryService.updateStock(order); // Uses same transaction\n    }\n}\n\n@Service\npublic class InventoryService {\n    \n    @Transactional(propagation = Propagation.REQUIRED)\n    public void updateStock(Order order) {\n        // Uses transaction from createOrder\n        inventoryRepository.updateQuantity(order.getProductId());\n    }\n}\n\n2. REQUIRES_NEW:\n\n• Always creates a new transaction\n• Suspends current transaction if exists\n• Inner and outer transactions are independent\n• Inner transaction commits/rolls back independently\n• Useful for logging or audit operations\n\nExample:\n\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @Transactional\n    public void createOrder(Order order) {\n        orderRepository.save(order);\n        \n        // Even if this fails, audit log is saved\n        auditService.logOrderCreation(order);\n    }\n}\n\n@Service\npublic class AuditService {\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void logOrderCreation(Order order) {\n        // New independent transaction\n        AuditLog log = new AuditLog();\n        log.setAction(\"ORDER_CREATED\");\n        log.setOrderId(order.getId());\n        auditRepository.save(log);\n        // Commits immediately, independent of outer transaction\n    }\n}\n\n3. NESTED:\n\n• Creates nested transaction within existing transaction\n• Uses savepoints to allow partial rollback\n• Inner transaction can rollback without affecting outer\n• Outer transaction rollback affects inner transaction\n• Requires JDBC 3.0+ savepoint support\n\nExample:\n\n@Service\npublic class PaymentService {\n    \n    @Transactional\n    public void processPayment(Payment payment) {\n        paymentRepository.save(payment);\n        \n        try {\n            notificationService.sendPaymentNotification(payment);\n        } catch (Exception e) {\n            // Notification fails but payment still saved\n        }\n    }\n}\n\n@Service\npublic class NotificationService {\n    \n    @Transactional(propagation = Propagation.NESTED)\n    public void sendPaymentNotification(Payment payment) {\n        // Nested transaction with savepoint\n        notificationRepository.save(new Notification(payment));\n    }\n}\n\n4. SUPPORTS:\n\n• Executes with transaction if one exists\n• Executes without transaction if none exists\n• Flexible, non-transactional behavior\n• Used for read operations that can work with or without transactions\n\nExample:\n\n@Service\npublic class ReportService {\n    \n    @Transactional(propagation = Propagation.SUPPORTS)\n    public Report generateReport(Long orderId) {\n        // If called from transactional method: uses that transaction\n        // If called standalone: runs without transaction\n        return reportRepository.findByOrderId(orderId);\n    }\n}\n\n5. NOT_SUPPORTED:\n\n• Always executes without transaction\n• Suspends current transaction if exists\n• Runs as non-transactional code\n• Used for operations that shouldn't be in transactions\n\nExample:\n\n@Service\npublic class EmailService {\n    \n    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public void sendEmail(String to, String subject, String body) {\n        // Runs without transaction\n        // Even if called from transactional method\n        emailClient.send(to, subject, body);\n    }\n}\n\n6. MANDATORY:\n\n• Requires an existing transaction\n• Throws exception if no transaction exists\n• Forces method to be called only from transactional context\n• Used for methods that must run within a transaction\n\nExample:\n\n@Service\npublic class PaymentService {\n    \n    @Transactional(propagation = Propagation.MANDATORY)\n    public void processRefund(Long paymentId) {\n        // Must be called from transactional method\n        // Throws exception if no transaction exists\n        Payment payment = paymentRepository.findById(paymentId).get();\n        payment.setStatus(\"REFUNDED\");\n        paymentRepository.save(payment);\n    }\n}\n\n@Service\npublic class OrderService {\n    \n    @Transactional\n    public void cancelOrder(Long orderId) {\n        Order order = orderRepository.findById(orderId).get();\n        order.setStatus(\"CANCELLED\");\n        orderRepository.save(order);\n        \n        // This works because we're in a transaction\n        paymentService.processRefund(order.getPaymentId());\n    }\n}\n\n7. NEVER:\n\n• Must execute without transaction\n• Throws exception if transaction exists\n• Ensures method never runs within transaction\n• Used for operations that must be non-transactional\n\nExample:\n\n@Service\npublic class CacheService {\n    \n    @Transactional(propagation = Propagation.NEVER)\n    public void updateCache(String key, Object value) {\n        // Must not be in transaction\n        // Throws exception if called from transactional method\n        cache.put(key, value);\n    }\n}\n\nComparison Summary:\n\n• REQUIRED: Use existing or create new (most common)\n• REQUIRES_NEW: Always create new, suspend existing\n• NESTED: Create nested with savepoint\n• SUPPORTS: Use if exists, else run without\n• NOT_SUPPORTED: Never use transaction, suspend if exists\n• MANDATORY: Must have existing transaction\n• NEVER: Must not have transaction\n\nCommon Use Cases:\n\n• REQUIRED: Default for most business operations\n• REQUIRES_NEW: Logging, auditing, independent operations\n• NESTED: Partial rollback scenarios\n• SUPPORTS: Read-only operations\n• NOT_SUPPORTED: External API calls, email sending\n• MANDATORY: Critical operations requiring transaction context\n• NEVER: Cache operations, non-transactional utilities\n\nBehavior with Rollback:\n\n• REQUIRED: Inner failure rolls back entire transaction\n• REQUIRES_NEW: Inner and outer rollback independently\n• NESTED: Inner can rollback without outer rolling back\n• SUPPORTS/NOT_SUPPORTED: No rollback behavior\n• MANDATORY/NEVER: Validation at method invocation"
    },
    {
      "id": 44,
      "category": "Transaction Management",
      "question": "What happens when we use PESSIMISTIC_WRITE locking in JPA?",
      "answer": "PESSIMISTIC_WRITE locking in JPA is a database-level locking mechanism that prevents other transactions from reading, updating, or deleting a locked record until the current transaction completes. It acquires an exclusive lock on the database row.\n\nCore Concept:\n\n• Locks database row immediately when entity is read\n• Other transactions must wait until lock is released\n• Lock released when transaction commits or rolls back\n• Prevents concurrent modifications\n• Uses database's row-level locking mechanism (SELECT FOR UPDATE)\n\nHow It Works:\n\n• Transaction A reads entity with PESSIMISTIC_WRITE lock\n• Database places exclusive lock on that row\n• Transaction B tries to read/update same row\n• Transaction B waits/blocks until Transaction A completes\n• After Transaction A commits/rolls back, Transaction B proceeds\n\nBasic Example:\n\n@Repository\npublic interface AccountRepository extends JpaRepository<Account, Long> {\n    \n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @Query(\"SELECT a FROM Account a WHERE a.id = :id\")\n    Optional<Account> findByIdWithLock(@Param(\"id\") Long id);\n}\n\n@Service\npublic class TransferService {\n    \n    @Autowired\n    private AccountRepository accountRepository;\n    \n    @Transactional\n    public void transferMoney(Long fromId, Long toId, Double amount) {\n        // Acquires exclusive lock on both accounts\n        Account fromAccount = accountRepository.findByIdWithLock(fromId).get();\n        Account toAccount = accountRepository.findByIdWithLock(toId).get();\n        \n        // No other transaction can modify these accounts now\n        fromAccount.setBalance(fromAccount.getBalance() - amount);\n        toAccount.setBalance(toAccount.getBalance() + amount);\n        \n        accountRepository.save(fromAccount);\n        accountRepository.save(toAccount);\n        \n        // Locks released after transaction commits\n    }\n}\n\nGenerated SQL:\n\n• For MySQL: SELECT * FROM account WHERE id = 1 FOR UPDATE;\n• For PostgreSQL: SELECT * FROM account WHERE id = 1 FOR UPDATE;\n• For Oracle: SELECT * FROM account WHERE id = 1 FOR UPDATE;\n• Database locks the row until transaction ends\n\nScenario Example - Banking Transfer:\n\nThread 1:\n\n@Transactional\npublic void transfer() {\n    // T1: 10:00:00.000 - Acquires lock on account 123\n    Account account = accountRepository.findByIdWithLock(123L).get();\n    \n    // T1: 10:00:00.100 - Processing...\n    account.setBalance(account.getBalance() - 100);\n    \n    // T1: 10:00:02.000 - Saves and commits\n    accountRepository.save(account);\n    // Lock released here\n}\n\nThread 2:\n\n@Transactional\npublic void withdraw() {\n    // T2: 10:00:00.500 - Tries to acquire lock on account 123\n    // BLOCKS HERE - Waits for Thread 1 to release lock\n    Account account = accountRepository.findByIdWithLock(123L).get();\n    \n    // T2: 10:00:02.001 - Finally gets lock after Thread 1 completes\n    account.setBalance(account.getBalance() - 50);\n    accountRepository.save(account);\n    // Lock released\n}\n\nAdvanced Example with Timeout:\n\n@Repository\npublic interface ProductRepository extends JpaRepository<Product, Long> {\n    \n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @QueryHints({\n        @QueryHint(name = \"javax.persistence.lock.timeout\", value = \"5000\")\n    })\n    @Query(\"SELECT p FROM Product p WHERE p.id = :id\")\n    Optional<Product> findByIdWithLock(@Param(\"id\") Long id);\n}\n\n@Service\npublic class InventoryService {\n    \n    @Transactional\n    public void updateStock(Long productId, int quantity) {\n        try {\n            // Waits maximum 5 seconds for lock\n            Product product = productRepository.findByIdWithLock(productId).get();\n            product.setStock(product.getStock() - quantity);\n            productRepository.save(product);\n            \n        } catch (LockTimeoutException e) {\n            // Lock not acquired within 5 seconds\n            throw new ServiceException(\"Product is being updated by another user\");\n        }\n    }\n}\n\nUsing EntityManager:\n\n@Service\npublic class OrderService {\n    \n    @PersistenceContext\n    private EntityManager entityManager;\n    \n    @Transactional\n    public void processOrder(Long orderId) {\n        // Acquire pessimistic write lock\n        Order order = entityManager.find(\n            Order.class,\n            orderId,\n            LockModeType.PESSIMISTIC_WRITE\n        );\n        \n        // Process order\n        order.setStatus(\"PROCESSING\");\n        entityManager.merge(order);\n    }\n    \n    @Transactional\n    public void processOrderWithTimeout(Long orderId) {\n        // With timeout\n        Map<String, Object> properties = new HashMap<>();\n        properties.put(\"javax.persistence.lock.timeout\", 3000);\n        \n        Order order = entityManager.find(\n            Order.class,\n            orderId,\n            LockModeType.PESSIMISTIC_WRITE,\n            properties\n        );\n        \n        order.setStatus(\"PROCESSING\");\n        entityManager.merge(order);\n    }\n}\n\nWhat Happens:\n\n• Database Row Locking: Actual row in database table is locked\n• Blocking: Other transactions wait/block when trying to access locked row\n• Transaction Scope: Lock held for entire transaction duration\n• Automatic Release: Lock released when transaction commits/rolls back\n• Deadlock Risk: Multiple locks can cause deadlocks\n• Performance Impact: Blocking reduces concurrency\n\nAdvantages:\n\n• Prevents Lost Updates: No concurrent modifications\n• Data Consistency: Guaranteed exclusive access\n• Simple to Implement: Just add annotation\n• Database-Level: Enforced by database, not application\n• Immediate Locking: Lock acquired before any processing\n\nDisadvantages:\n\n• Performance: Reduces concurrent access\n• Blocking: Threads wait for lock release\n• Deadlock Risk: Multiple locks can cause deadlocks\n• Scalability: Not suitable for high-concurrency systems\n• Database Dependent: Behavior varies by database\n\nWhen to Use:\n\n• Banking transactions (money transfers)\n• Inventory management (stock updates)\n• Booking systems (seat reservation)\n• Any scenario where concurrent modification causes issues\n• When data consistency is more important than performance\n\nWhen NOT to Use:\n\n• High-concurrency read operations\n• Long-running transactions\n• When optimistic locking is sufficient\n• Distributed systems across multiple databases\n• Applications requiring high throughput\n\nAlternative - Optimistic Locking:\n\n• Better for high-concurrency scenarios\n• No blocking, faster performance\n• Uses version field to detect conflicts\n• Throws exception if conflict detected\n• Suitable when conflicts are rare\n\nComparison Example:\n\n// Pessimistic - Locks immediately\n@Lock(LockModeType.PESSIMISTIC_WRITE)\nAccount findById(Long id);\n\n// Optimistic - No lock, checks version on save\n@Entity\npublic class Account {\n    @Id\n    private Long id;\n    \n    @Version\n    private Long version; // Auto-managed by JPA\n    \n    private Double balance;\n}\n\nBest Practices:\n\n• Always set lock timeout to avoid indefinite blocking\n• Keep transactions short to minimize lock duration\n• Lock in consistent order to prevent deadlocks\n• Handle LockTimeoutException gracefully\n• Use pessimistic locking only when necessary\n• Monitor database for lock contention\n• Consider optimistic locking as alternative"
    },
    {
      "id": 45,
      "category": "Transaction Management",
      "question": "What is the locking strategy in JPA (Optimistic vs Pessimistic)?",
      "answer": "JPA provides two main locking strategies to handle concurrent access to database records: Optimistic Locking and Pessimistic Locking. Each has different approaches, use cases, and trade-offs.\n\nOptimistic Locking:\n\nConcept:\n• Assumes conflicts are rare\n• No database locks during read\n• Conflict detection happens at commit time\n• Uses version field to detect concurrent modifications\n• If version mismatch found, throws OptimisticLockException\n• Non-blocking approach\n\nHow It Works:\n\n• Entity has @Version field (version number or timestamp)\n• When reading entity, JPA records current version\n• When updating, JPA includes version in WHERE clause\n• If version changed by another transaction, update fails\n• Application must handle OptimisticLockException\n\nImplementation:\n\n@Entity\n@Table(name = \"products\")\npublic class Product {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String name;\n    \n    private Double price;\n    \n    private Integer stock;\n    \n    @Version // Optimistic locking version field\n    private Long version;\n    \n    // Getters and setters\n}\n\n@Service\npublic class ProductService {\n    \n    @Autowired\n    private ProductRepository productRepository;\n    \n    @Transactional\n    public void updatePrice(Long productId, Double newPrice) {\n        try {\n            Product product = productRepository.findById(productId).get();\n            // Version = 1 at this point\n            \n            product.setPrice(newPrice);\n            productRepository.save(product);\n            // JPA generates: UPDATE products SET price = ?, version = 2\n            // WHERE id = ? AND version = 1\n            \n            // If another transaction already updated (version = 2),\n            // this update affects 0 rows -> OptimisticLockException\n            \n        } catch (OptimisticLockException e) {\n            // Handle conflict - retry or inform user\n            throw new ConcurrentUpdateException(\"Product was modified by another user\");\n        }\n    }\n}\n\nGenerated SQL:\n\n-- Read: version is 1\nSELECT id, name, price, stock, version FROM products WHERE id = 1;\n\n-- Update: checks version hasn't changed\nUPDATE products \nSET name = ?, price = ?, stock = ?, version = 2 \nWHERE id = 1 AND version = 1;\n\n-- If version already changed to 2, update affects 0 rows\n-- OptimisticLockException thrown\n\nPessimistic Locking:\n\nConcept:\n• Assumes conflicts are common\n• Acquires database lock during read\n• Prevents other transactions from accessing locked records\n• Lock held until transaction completes\n• Blocking approach - other transactions wait\n• No version checking needed\n\nTypes:\n\n• PESSIMISTIC_READ: Shared lock - others can read but not write\n• PESSIMISTIC_WRITE: Exclusive lock - others cannot read or write\n• PESSIMISTIC_FORCE_INCREMENT: Lock and increment version\n\nImplementation:\n\n@Repository\npublic interface AccountRepository extends JpaRepository<Account, Long> {\n    \n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @Query(\"SELECT a FROM Account a WHERE a.id = :id\")\n    Optional<Account> findByIdWithPessimisticLock(@Param(\"id\") Long id);\n}\n\n@Service\npublic class BankingService {\n    \n    @Autowired\n    private AccountRepository accountRepository;\n    \n    @Transactional\n    public void transferMoney(Long fromId, Long toId, Double amount) {\n        // Acquires database lock immediately\n        Account fromAccount = accountRepository\n            .findByIdWithPessimisticLock(fromId).get();\n        Account toAccount = accountRepository\n            .findByIdWithPessimisticLock(toId).get();\n        \n        // Other transactions trying to access these accounts will wait\n        \n        fromAccount.setBalance(fromAccount.getBalance() - amount);\n        toAccount.setBalance(toAccount.getBalance() + amount);\n        \n        accountRepository.save(fromAccount);\n        accountRepository.save(toAccount);\n        \n        // Locks released when transaction commits\n    }\n}\n\nUsing EntityManager:\n\n@Service\npublic class OrderService {\n    \n    @PersistenceContext\n    private EntityManager entityManager;\n    \n    @Transactional\n    public void processOrder(Long orderId) {\n        // Pessimistic write lock with timeout\n        Map<String, Object> properties = new HashMap<>();\n        properties.put(\"javax.persistence.lock.timeout\", 5000);\n        \n        Order order = entityManager.find(\n            Order.class,\n            orderId,\n            LockModeType.PESSIMISTIC_WRITE,\n            properties\n        );\n        \n        order.setStatus(\"PROCESSING\");\n        entityManager.merge(order);\n    }\n}\n\nGenerated SQL:\n\n-- Acquires exclusive lock on row\nSELECT * FROM accounts WHERE id = 1 FOR UPDATE;\n\n-- Other transactions trying same row will block\n-- Lock released when transaction commits/rolls back\n\nKey Differences:\n\n• Locking Time:\n  - Optimistic: No lock until update\n  - Pessimistic: Lock acquired immediately on read\n\n• Conflict Detection:\n  - Optimistic: At commit time using version\n  - Pessimistic: Prevented by database lock\n\n• Performance:\n  - Optimistic: Better for high concurrency\n  - Pessimistic: Can cause blocking and reduced throughput\n\n• When Conflicts Occur:\n  - Optimistic: Application handles exception, retry logic needed\n  - Pessimistic: No conflicts, but waiting/blocking occurs\n\n• Database Load:\n  - Optimistic: Lower - no locks maintained\n  - Pessimistic: Higher - locks consume resources\n\n• Use Case:\n  - Optimistic: Read-heavy, rare updates\n  - Pessimistic: Write-heavy, frequent conflicts\n\nScenario Comparison:\n\nScenario: Two users updating same product\n\nWith Optimistic Locking:\n\nUser A (Thread 1):\n• T1: Reads Product (version=1, price=100)\n• T2: Updates price to 120\n• T3: Saves (version=2, price=120) - SUCCESS\n\nUser B (Thread 2):\n• T1: Reads Product (version=1, price=100)\n• T4: Updates price to 130\n• T5: Saves (version=2?) - FAILS! OptimisticLockException\n• User B must retry with latest data\n\nWith Pessimistic Locking:\n\nUser A (Thread 1):\n• T1: Reads Product WITH LOCK (price=100)\n• T2: Updates price to 120\n• T3: Saves and releases lock\n\nUser B (Thread 2):\n• T1: Tries to read Product - BLOCKS/WAITS\n• T3: Gets lock after User A releases\n• T4: Reads Product (price=120)\n• T5: Updates price to 130\n• T6: Saves and releases lock\n\nWhen to Use Optimistic Locking:\n\n• High read, low write scenarios\n• Conflicts are rare\n• Long-running transactions\n• Better scalability required\n• Multiple disconnected clients\n• Web applications with form submissions\n• Read-heavy REST APIs\n\nExample Use Cases:\n• Blog post editing\n• User profile updates\n• Product catalog management\n• Document editing\n\nWhen to Use Pessimistic Locking:\n\n• High write, frequent conflicts\n• Critical operations requiring guaranteed consistency\n• Short transactions\n• Banking and financial operations\n• Inventory management\n• Seat booking systems\n• Scenarios where retry is not acceptable\n\nExample Use Cases:\n• Money transfers\n• Stock quantity updates\n• Ticket booking\n• Sequential number generation\n\nCombining Both Strategies:\n\n@Entity\npublic class Order {\n    \n    @Id\n    private Long id;\n    \n    @Version // Still use version for optimistic checks\n    private Long version;\n    \n    private String status;\n    \n    private Double amount;\n}\n\n@Repository\npublic interface OrderRepository extends JpaRepository<Order, Long> {\n    \n    // Optimistic - normal read\n    Optional<Order> findById(Long id);\n    \n    // Pessimistic - critical updates\n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @Query(\"SELECT o FROM Order o WHERE o.id = :id\")\n    Optional<Order> findByIdForUpdate(@Param(\"id\") Long id);\n}\n\n@Service\npublic class OrderService {\n    \n    @Transactional(readOnly = true)\n    public Order getOrder(Long id) {\n        // Optimistic - just reading\n        return orderRepository.findById(id).get();\n    }\n    \n    @Transactional\n    public void processPayment(Long orderId) {\n        // Pessimistic - critical payment processing\n        Order order = orderRepository.findByIdForUpdate(orderId).get();\n        order.setStatus(\"PAID\");\n        orderRepository.save(order);\n    }\n}\n\nBest Practices:\n\n• Default to optimistic locking for most scenarios\n• Use pessimistic locking only when absolutely necessary\n• Keep pessimistic lock duration short\n• Always set timeout for pessimistic locks\n• Handle OptimisticLockException with retry logic\n• Monitor database for lock contention\n• Document locking strategy in code\n• Test concurrent scenarios thoroughly\n\nHandling Optimistic Lock Exceptions:\n\n@Service\npublic class ProductService {\n    \n    @Autowired\n    private ProductRepository productRepository;\n    \n    private static final int MAX_RETRIES = 3;\n    \n    public void updateStockWithRetry(Long productId, int quantity) {\n        int retries = 0;\n        \n        while (retries < MAX_RETRIES) {\n            try {\n                updateStock(productId, quantity);\n                return; // Success\n                \n            } catch (OptimisticLockException e) {\n                retries++;\n                if (retries >= MAX_RETRIES) {\n                    throw new ServiceException(\"Failed after \" + MAX_RETRIES + \" retries\");\n                }\n                // Wait before retry\n                Thread.sleep(100 * retries);\n            }\n        }\n    }\n    \n    @Transactional\n    private void updateStock(Long productId, int quantity) {\n        Product product = productRepository.findById(productId).get();\n        product.setStock(product.getStock() - quantity);\n        productRepository.save(product);\n    }\n}"
    },
    {
      "id": 46,
      "category": "Transaction Management",
      "question": "What is the use of Spring Transaction in Spring Boot?",
      "answer": "Spring Transaction management in Spring Boot provides a consistent abstraction for managing database transactions, ensuring data integrity, consistency, and reliability across different persistence technologies.\n\nPrimary Purpose:\n\n• Ensures ACID properties (Atomicity, Consistency, Isolation, Durability)\n• Manages transaction lifecycle automatically\n• Provides declarative transaction management\n• Simplifies transaction handling code\n• Supports both programmatic and declarative approaches\n• Works with multiple data sources and persistence technologies\n\nCore Benefits:\n\n1. Data Consistency:\n• Groups multiple database operations into single unit\n• All operations succeed together or fail together\n• Prevents partial updates\n• Maintains database integrity\n\n2. Automatic Rollback:\n• Automatically rolls back on exceptions\n• No need for manual rollback code\n• Configurable rollback rules\n• Ensures database remains consistent even on errors\n\n3. Declarative Management:\n• Simple @Transactional annotation\n• No boilerplate transaction code\n• Clean separation of business and transaction logic\n• Easier to read and maintain\n\n4. Multiple Operations as One Unit:\n• Combine multiple repository calls\n• Treat complex operations atomically\n• Either all succeed or all rollback\n\nCommon Use Cases:\n\nUse Case 1 - Banking Money Transfer:\n\n@Service\npublic class BankingService {\n    \n    @Autowired\n    private AccountRepository accountRepository;\n    \n    @Autowired\n    private TransactionHistoryRepository transactionHistoryRepository;\n    \n    @Transactional\n    public void transferMoney(Long fromAccountId, Long toAccountId, Double amount) {\n        // Operation 1: Debit from source account\n        Account fromAccount = accountRepository.findById(fromAccountId).get();\n        if (fromAccount.getBalance() < amount) {\n            throw new InsufficientBalanceException(\"Not enough balance\");\n        }\n        fromAccount.setBalance(fromAccount.getBalance() - amount);\n        accountRepository.save(fromAccount);\n        \n        // Operation 2: Credit to destination account\n        Account toAccount = accountRepository.findById(toAccountId).get();\n        toAccount.setBalance(toAccount.getBalance() + amount);\n        accountRepository.save(toAccount);\n        \n        // Operation 3: Create transaction record\n        TransactionHistory history = new TransactionHistory();\n        history.setFromAccount(fromAccountId);\n        history.setToAccount(toAccountId);\n        history.setAmount(amount);\n        history.setTimestamp(new Date());\n        transactionHistoryRepository.save(history);\n        \n        // If ANY operation fails, ALL operations rollback\n        // Money is never lost or duplicated\n    }\n}\n\nWithout @Transactional:\n• If Operation 2 fails, money deducted but not credited - LOST!\n• If Operation 3 fails, transfer happened but no record - INCONSISTENT!\n\nWith @Transactional:\n• If any operation fails, everything rolls back\n• Database remains consistent\n• No money lost or duplicated\n\nUse Case 2 - Order Processing:\n\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private InventoryRepository inventoryRepository;\n    \n    @Autowired\n    private PaymentRepository paymentRepository;\n    \n    @Transactional\n    public Order createOrder(OrderRequest request) {\n        // Step 1: Create order\n        Order order = new Order();\n        order.setCustomerId(request.getCustomerId());\n        order.setProductId(request.getProductId());\n        order.setQuantity(request.getQuantity());\n        order.setTotalAmount(request.getTotalAmount());\n        order.setStatus(\"PENDING\");\n        Order savedOrder = orderRepository.save(order);\n        \n        // Step 2: Reduce inventory\n        Inventory inventory = inventoryRepository\n            .findByProductId(request.getProductId());\n        \n        if (inventory.getStock() < request.getQuantity()) {\n            throw new OutOfStockException(\"Product out of stock\");\n            // Order creation rolls back automatically\n        }\n        \n        inventory.setStock(inventory.getStock() - request.getQuantity());\n        inventoryRepository.save(inventory);\n        \n        // Step 3: Process payment\n        Payment payment = new Payment();\n        payment.setOrderId(savedOrder.getId());\n        payment.setAmount(request.getTotalAmount());\n        payment.setStatus(\"COMPLETED\");\n        paymentRepository.save(payment);\n        \n        // Step 4: Update order status\n        savedOrder.setStatus(\"CONFIRMED\");\n        orderRepository.save(savedOrder);\n        \n        return savedOrder;\n        \n        // All 4 operations happen atomically\n        // If payment fails, order and inventory changes rollback\n    }\n}\n\nUse Case 3 - User Registration with Multiple Entities:\n\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private UserProfileRepository profileRepository;\n    \n    @Autowired\n    private UserRoleRepository roleRepository;\n    \n    @Autowired\n    private AuditLogRepository auditLogRepository;\n    \n    @Transactional\n    public User registerUser(UserRegistrationRequest request) {\n        // Check if email exists\n        if (userRepository.existsByEmail(request.getEmail())) {\n            throw new EmailAlreadyExistsException(\"Email already registered\");\n        }\n        \n        // Create user\n        User user = new User();\n        user.setEmail(request.getEmail());\n        user.setPassword(passwordEncoder.encode(request.getPassword()));\n        user.setCreatedAt(new Date());\n        User savedUser = userRepository.save(user);\n        \n        // Create user profile\n        UserProfile profile = new UserProfile();\n        profile.setUserId(savedUser.getId());\n        profile.setFirstName(request.getFirstName());\n        profile.setLastName(request.getLastName());\n        profile.setPhone(request.getPhone());\n        profileRepository.save(profile);\n        \n        // Assign default role\n        UserRole role = new UserRole();\n        role.setUserId(savedUser.getId());\n        role.setRole(\"USER\");\n        roleRepository.save(role);\n        \n        // Create audit log\n        AuditLog log = new AuditLog();\n        log.setAction(\"USER_REGISTERED\");\n        log.setUserId(savedUser.getId());\n        log.setTimestamp(new Date());\n        auditLogRepository.save(log);\n        \n        return savedUser;\n        \n        // If any step fails, complete registration rolls back\n        // No partial user records in database\n    }\n}\n\nUse Case 4 - Nested Service Calls:\n\n@Service\npublic class OrderProcessingService {\n    \n    @Autowired\n    private OrderService orderService;\n    \n    @Autowired\n    private NotificationService notificationService;\n    \n    @Autowired\n    private LoyaltyService loyaltyService;\n    \n    @Transactional\n    public void processCompleteOrder(OrderRequest request) {\n        // Create order (transactional)\n        Order order = orderService.createOrder(request);\n        \n        // Add loyalty points (transactional)\n        loyaltyService.addPoints(request.getCustomerId(), order.getTotalAmount());\n        \n        // Send notification (should use REQUIRES_NEW propagation)\n        notificationService.sendOrderConfirmation(order);\n        \n        // All operations in same transaction by default\n        // If notification fails, entire order process rolls back\n    }\n}\n\nTransaction Attributes:\n\n@Service\npublic class PaymentService {\n    \n    // Rollback on specific exceptions\n    @Transactional(rollbackFor = {SQLException.class, PaymentException.class})\n    public void processPayment(Payment payment) {\n        // Rolls back on SQLException or PaymentException\n    }\n    \n    // Read-only optimization\n    @Transactional(readOnly = true)\n    public List<Payment> getPaymentHistory(Long userId) {\n        // Read-only: better performance\n        return paymentRepository.findByUserId(userId);\n    }\n    \n    // Custom timeout\n    @Transactional(timeout = 30)\n    public void longRunningOperation() {\n        // Transaction rolls back if takes more than 30 seconds\n    }\n    \n    // Custom isolation level\n    @Transactional(isolation = Isolation.SERIALIZABLE)\n    public void criticalOperation() {\n        // Highest isolation level\n    }\n    \n    // Custom propagation\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void independentOperation() {\n        // Creates new transaction, independent of caller\n    }\n}\n\nKey Features:\n\n• Abstraction: Works with JPA, JDBC, Hibernate, JTA\n• Declarative: @Transactional annotation\n• Programmatic: TransactionTemplate for manual control\n• Propagation: Control nested transaction behavior\n• Isolation Levels: Control concurrent access\n• Rollback Rules: Configure which exceptions trigger rollback\n• Read-Only: Optimization for read operations\n• Timeout: Prevent long-running transactions\n\nWithout Transaction Management:\n\npublic void transferMoneyWithoutTransaction(Long from, Long to, Double amount) {\n    Account fromAccount = accountRepository.findById(from).get();\n    fromAccount.setBalance(fromAccount.getBalance() - amount);\n    accountRepository.save(fromAccount);\n    \n    // If application crashes here, money is lost!\n    // Deducted from source but not added to destination\n    \n    Account toAccount = accountRepository.findById(to).get();\n    toAccount.setBalance(toAccount.getBalance() + amount);\n    accountRepository.save(toAccount);\n}\n\nWith Transaction Management:\n\n@Transactional\npublic void transferMoneyWithTransaction(Long from, Long to, Double amount) {\n    Account fromAccount = accountRepository.findById(from).get();\n    fromAccount.setBalance(fromAccount.getBalance() - amount);\n    accountRepository.save(fromAccount);\n    \n    // If crash occurs here, entire transaction rolls back\n    // Both operations succeed or both fail\n    // Money never lost\n    \n    Account toAccount = accountRepository.findById(to).get();\n    toAccount.setBalance(toAccount.getBalance() + amount);\n    accountRepository.save(toAccount);\n}\n\nReal-World Benefits:\n\n• Prevents data corruption\n• Eliminates race conditions\n• Simplifies error handling\n• Improves code readability\n• Reduces development time\n• Increases application reliability\n• Supports complex business operations\n• Enables safe concurrent access\n\nConfiguration:\n\nSpring Boot auto-configures transactions:\n\n• @EnableTransactionManagement (auto-enabled in Spring Boot)\n• PlatformTransactionManager (auto-configured)\n• No XML configuration needed\n• Works out of the box with Spring Data JPA\n\nImportant Points:\n\n• Only works on public methods\n• Requires Spring proxy mechanism\n• Self-invocation doesn't trigger transaction\n• Default rollback on unchecked exceptions only\n• Can be customized for checked exceptions\n• Multiple transactions can be configured for multiple data sources"
    },
    {
      "id": 47,
      "category": "Exception Handling",
      "question": "Why do we need exception handling in Java/Spring Boot?",
      "answer": "Exception handling is crucial in Java/Spring Boot applications to gracefully manage errors, provide meaningful feedback to users, maintain application stability, and ensure a good user experience even when things go wrong.\n\nCore Reasons:\n\n1. Prevent Application Crashes:\n• Unhandled exceptions crash the application\n• Exception handling keeps application running\n• Graceful degradation instead of complete failure\n• Maintains service availability\n\n2. Provide User-Friendly Error Messages:\n• Technical stack traces confuse end users\n• Custom messages explain what went wrong\n• Improves user experience\n• Helps users take corrective action\n\n3. Maintain Application Stability:\n• Isolates failures to specific operations\n• Prevents error propagation\n• Allows partial functionality to continue\n• Protects critical system components\n\n4. Enable Logging and Debugging:\n• Captures error details for analysis\n• Helps identify root causes\n• Tracks error patterns\n• Facilitates troubleshooting\n\n5. Transaction Rollback:\n• Ensures data consistency\n• Reverts partial changes on errors\n• Maintains database integrity\n• Prevents data corruption\n\n6. Business Logic Control:\n• Handle expected error scenarios\n• Implement retry mechanisms\n• Provide alternative flows\n• Make business decisions based on errors\n\nWithout Exception Handling:\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // If user not found, application crashes\n        User user = userRepository.findById(id).get();\n        return user;\n        \n        // Response to client:\n        // HTTP 500 Internal Server Error\n        // Stack trace exposed (security risk)\n        // No meaningful message for user\n    }\n}\n\nWith Exception Handling:\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public ResponseEntity<?> getUser(@PathVariable Long id) {\n        try {\n            User user = userRepository.findById(id)\n                .orElseThrow(() -> new UserNotFoundException(\"User not found with id: \" + id));\n            return ResponseEntity.ok(user);\n            \n        } catch (UserNotFoundException e) {\n            // Return meaningful error response\n            ErrorResponse error = new ErrorResponse(\n                \"USER_NOT_FOUND\",\n                e.getMessage(),\n                LocalDateTime.now()\n            );\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n        }\n    }\n}\n\nCommon Exception Scenarios:\n\nScenario 1 - Resource Not Found:\n\n@Service\npublic class ProductService {\n    \n    public Product getProduct(Long id) {\n        return productRepository.findById(id)\n            .orElseThrow(() -> new ResourceNotFoundException(\n                \"Product not found with id: \" + id\n            ));\n    }\n}\n\nScenario 2 - Invalid Input Validation:\n\n@Service\npublic class OrderService {\n    \n    @Transactional\n    public Order createOrder(OrderRequest request) {\n        // Validate quantity\n        if (request.getQuantity() <= 0) {\n            throw new InvalidRequestException(\"Quantity must be greater than 0\");\n        }\n        \n        // Validate product exists\n        Product product = productRepository.findById(request.getProductId())\n            .orElseThrow(() -> new ResourceNotFoundException(\"Product not found\"));\n        \n        // Check stock availability\n        if (product.getStock() < request.getQuantity()) {\n            throw new OutOfStockException(\n                \"Insufficient stock. Available: \" + product.getStock()\n            );\n        }\n        \n        // Create order\n        Order order = new Order();\n        order.setProduct(product);\n        order.setQuantity(request.getQuantity());\n        return orderRepository.save(order);\n    }\n}\n\nScenario 3 - Database Errors:\n\n@Service\npublic class PaymentService {\n    \n    @Transactional(rollbackFor = {SQLException.class})\n    public Payment processPayment(PaymentRequest request) {\n        try {\n            Payment payment = new Payment();\n            payment.setAmount(request.getAmount());\n            payment.setStatus(\"PENDING\");\n            \n            Payment saved = paymentRepository.save(payment);\n            \n            // External payment gateway call\n            boolean success = paymentGateway.charge(request);\n            \n            if (!success) {\n                throw new PaymentFailedException(\"Payment gateway declined transaction\");\n            }\n            \n            saved.setStatus(\"SUCCESS\");\n            return paymentRepository.save(saved);\n            \n        } catch (DataAccessException e) {\n            log.error(\"Database error during payment: {}\", e.getMessage());\n            throw new DatabaseException(\"Failed to process payment due to database error\");\n        }\n    }\n}\n\nScenario 4 - External Service Failures:\n\n@Service\npublic class NotificationService {\n    \n    public void sendEmail(String to, String subject, String body) {\n        try {\n            emailClient.send(to, subject, body);\n            \n        } catch (EmailServiceException e) {\n            // Log but don't fail the entire operation\n            log.error(\"Failed to send email to {}: {}\", to, e.getMessage());\n            \n            // Store in retry queue\n            retryQueueService.addEmailToQueue(to, subject, body);\n            \n        } catch (Exception e) {\n            log.error(\"Unexpected error sending email: {}\", e.getMessage());\n        }\n    }\n}\n\nBenefits in Spring Boot:\n\n1. Centralized Error Handling:\n• @ControllerAdvice for global exception handling\n• Consistent error responses across application\n• Single place to manage all errors\n• Reduces code duplication\n\n2. Automatic HTTP Status Mapping:\n• Custom exceptions map to appropriate HTTP status codes\n• RESTful error responses\n• Better API design\n\n3. Transaction Rollback:\n• @Transactional integrates with exception handling\n• Automatic rollback on exceptions\n• Data consistency maintained\n\n4. Validation Integration:\n• @Valid triggers validation exceptions\n• MethodArgumentNotValidException handling\n• Bean validation integration\n\nGlobal Exception Handler Example:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"USER_NOT_FOUND\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(InvalidRequestException.class)\n    public ResponseEntity<ErrorResponse> handleInvalidRequest(InvalidRequestException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"INVALID_REQUEST\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"INTERNAL_ERROR\",\n            \"An unexpected error occurred\",\n            LocalDateTime.now()\n        );\n        // Log detailed error for developers\n        log.error(\"Unexpected error: \", ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n}\n\nError Response Model:\n\npublic class ErrorResponse {\n    private String errorCode;\n    private String message;\n    private LocalDateTime timestamp;\n    private List<String> details;\n    \n    // Constructors, getters, setters\n}\n\nReal-World Impact:\n\nWithout Proper Exception Handling:\n• Users see technical error messages\n• Application crashes frequently\n• Difficult to debug issues\n• Poor user experience\n• Security vulnerabilities (exposed stack traces)\n• Data inconsistency\n\nWith Proper Exception Handling:\n• Clean, user-friendly error messages\n• Application remains stable\n• Easy to track and fix issues\n• Better user experience\n• Secure (no sensitive information exposed)\n• Data consistency maintained\n\nBest Practices:\n\n• Use custom exceptions for domain-specific errors\n• Provide meaningful error messages\n• Log exceptions appropriately\n• Don't expose sensitive information\n• Use @ControllerAdvice for centralized handling\n• Return appropriate HTTP status codes\n• Include correlation IDs for tracking\n• Handle both checked and unchecked exceptions\n• Don't catch exceptions you can't handle\n• Use try-catch-finally for resource cleanup"
    },
    {
      "id": 48,
      "category": "Exception Handling",
      "question": "What is central exception handling in Spring Boot?",
      "answer": "Central exception handling in Spring Boot is a mechanism that allows you to handle all exceptions thrown by your application in a single, centralized location rather than handling them separately in each controller or service method.\n\nCore Concept:\n\n• Single place to handle all application exceptions\n• Uses @ControllerAdvice or @RestControllerAdvice annotation\n• Applies to all controllers globally\n• Eliminates duplicate exception handling code\n• Provides consistent error responses\n• Improves code maintainability\n\nKey Components:\n\n• @ControllerAdvice: Global exception handler for all controllers\n• @RestControllerAdvice: Combines @ControllerAdvice + @ResponseBody\n• @ExceptionHandler: Defines method to handle specific exception\n• ResponseEntityExceptionHandler: Base class with pre-defined handlers\n\nWithout Central Exception Handling:\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public ResponseEntity<?> getUser(@PathVariable Long id) {\n        try {\n            User user = userService.getUser(id);\n            return ResponseEntity.ok(user);\n        } catch (UserNotFoundException e) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                .body(new ErrorResponse(e.getMessage()));\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(new ErrorResponse(\"Internal error\"));\n        }\n    }\n    \n    @PostMapping(\"/users\")\n    public ResponseEntity<?> createUser(@RequestBody User user) {\n        try {\n            User created = userService.createUser(user);\n            return ResponseEntity.status(HttpStatus.CREATED).body(created);\n        } catch (DuplicateEmailException e) {\n            return ResponseEntity.status(HttpStatus.CONFLICT)\n                .body(new ErrorResponse(e.getMessage()));\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(new ErrorResponse(\"Internal error\"));\n        }\n    }\n    // Same exception handling repeated in every method!\n}\n\n@RestController\npublic class ProductController {\n    \n    @GetMapping(\"/products/{id}\")\n    public ResponseEntity<?> getProduct(@PathVariable Long id) {\n        try {\n            Product product = productService.getProduct(id);\n            return ResponseEntity.ok(product);\n        } catch (ProductNotFoundException e) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                .body(new ErrorResponse(e.getMessage()));\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(new ErrorResponse(\"Internal error\"));\n        }\n    }\n    // Duplicate exception handling again!\n}\n\nWith Central Exception Handling:\n\nControllers become clean:\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // No try-catch needed!\n        // Exception handling done centrally\n        return userService.getUser(id);\n    }\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@Valid @RequestBody User user) {\n        User created = userService.createUser(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(created);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteUser(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n    \n    @Autowired\n    private ProductService productService;\n    \n    @GetMapping(\"/{id}\")\n    public Product getProduct(@PathVariable Long id) {\n        // Clean code, no exception handling\n        return productService.getProduct(id);\n    }\n    \n    @PutMapping(\"/{id}\")\n    public Product updateProduct(@PathVariable Long id, @Valid @RequestBody Product product) {\n        return productService.updateProduct(id, product);\n    }\n}\n\nCentral Exception Handler:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    \n    // Handle specific custom exception\n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(LocalDateTime.now())\n            .status(HttpStatus.NOT_FOUND.value())\n            .error(\"Not Found\")\n            .message(ex.getMessage())\n            .build();\n        \n        log.warn(\"User not found: {}\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    // Handle another custom exception\n    @ExceptionHandler(DuplicateEmailException.class)\n    public ResponseEntity<ErrorResponse> handleDuplicateEmail(DuplicateEmailException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(LocalDateTime.now())\n            .status(HttpStatus.CONFLICT.value())\n            .error(\"Conflict\")\n            .message(ex.getMessage())\n            .build();\n        \n        log.warn(\"Duplicate email: {}\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);\n    }\n    \n    // Handle validation errors\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {\n        List<String> errors = ex.getBindingResult()\n            .getFieldErrors()\n            .stream()\n            .map(error -> error.getField() + \": \" + error.getDefaultMessage())\n            .collect(Collectors.toList());\n        \n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(LocalDateTime.now())\n            .status(HttpStatus.BAD_REQUEST.value())\n            .error(\"Validation Failed\")\n            .message(\"Invalid input provided\")\n            .details(errors)\n            .build();\n        \n        log.warn(\"Validation failed: {}\", errors);\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);\n    }\n    \n    // Handle resource not found (generic)\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(LocalDateTime.now())\n            .status(HttpStatus.NOT_FOUND.value())\n            .error(\"Not Found\")\n            .message(ex.getMessage())\n            .build();\n        \n        log.warn(\"Resource not found: {}\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    // Handle bad request\n    @ExceptionHandler(InvalidRequestException.class)\n    public ResponseEntity<ErrorResponse> handleInvalidRequest(InvalidRequestException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(LocalDateTime.now())\n            .status(HttpStatus.BAD_REQUEST.value())\n            .error(\"Bad Request\")\n            .message(ex.getMessage())\n            .build();\n        \n        log.warn(\"Invalid request: {}\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);\n    }\n    \n    // Handle database exceptions\n    @ExceptionHandler(DataAccessException.class)\n    public ResponseEntity<ErrorResponse> handleDatabaseException(DataAccessException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(LocalDateTime.now())\n            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())\n            .error(\"Database Error\")\n            .message(\"A database error occurred\")\n            .build();\n        \n        log.error(\"Database error: \", ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n    \n    // Handle all other exceptions\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(LocalDateTime.now())\n            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())\n            .error(\"Internal Server Error\")\n            .message(\"An unexpected error occurred\")\n            .build();\n        \n        log.error(\"Unexpected error: \", ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n}\n\nError Response Model:\n\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ErrorResponse {\n    private LocalDateTime timestamp;\n    private int status;\n    private String error;\n    private String message;\n    private List<String> details;\n    private String path;\n}\n\nCustom Exception Examples:\n\npublic class UserNotFoundException extends RuntimeException {\n    public UserNotFoundException(String message) {\n        super(message);\n    }\n}\n\npublic class DuplicateEmailException extends RuntimeException {\n    public DuplicateEmailException(String message) {\n        super(message);\n    }\n}\n\npublic class ResourceNotFoundException extends RuntimeException {\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n}\n\npublic class InvalidRequestException extends RuntimeException {\n    public InvalidRequestException(String message) {\n        super(message);\n    }\n}\n\nAdvantages:\n\n• Code Reusability: Single handler for all controllers\n• Consistency: Same error format throughout application\n• Maintainability: Changes in one place affect entire app\n• Clean Controllers: No cluttered try-catch blocks\n• Separation of Concerns: Business logic separate from error handling\n• Centralized Logging: All errors logged in one place\n• Easy Testing: Test exception handling separately\n• Better API Design: Consistent RESTful error responses\n\nAdditional Features:\n\nHandle Multiple Exceptions:\n\n@ExceptionHandler({UserNotFoundException.class, ProductNotFoundException.class})\npublic ResponseEntity<ErrorResponse> handleNotFound(RuntimeException ex) {\n    ErrorResponse error = new ErrorResponse(\n        LocalDateTime.now(),\n        HttpStatus.NOT_FOUND.value(),\n        \"Not Found\",\n        ex.getMessage()\n    );\n    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n}\n\nAccess Request Details:\n\n@ExceptionHandler(ResourceNotFoundException.class)\npublic ResponseEntity<ErrorResponse> handleResourceNotFound(\n        ResourceNotFoundException ex,\n        WebRequest request) {\n    \n    ErrorResponse error = ErrorResponse.builder()\n        .timestamp(LocalDateTime.now())\n        .status(HttpStatus.NOT_FOUND.value())\n        .error(\"Not Found\")\n        .message(ex.getMessage())\n        .path(request.getDescription(false).replace(\"uri=\", \"\"))\n        .build();\n    \n    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n}\n\nExtend ResponseEntityExceptionHandler:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler extends ResponseEntityExceptionHandler {\n    \n    // Override built-in exception handlers\n    @Override\n    protected ResponseEntity<Object> handleMethodArgumentNotValid(\n            MethodArgumentNotValidException ex,\n            HttpHeaders headers,\n            HttpStatus status,\n            WebRequest request) {\n        \n        // Custom handling for validation errors\n        ErrorResponse error = new ErrorResponse();\n        // ... populate error\n        \n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);\n    }\n    \n    // Add custom exception handlers\n    @ExceptionHandler(CustomException.class)\n    public ResponseEntity<ErrorResponse> handleCustomException(CustomException ex) {\n        // Custom handler\n    }\n}\n\nBest Practices:\n\n• Use @RestControllerAdvice for REST APIs\n• Create specific custom exceptions for different scenarios\n• Provide meaningful error messages\n• Include timestamp, status, and message in error response\n• Log errors appropriately (warn for client errors, error for server errors)\n• Don't expose sensitive information in error messages\n• Use appropriate HTTP status codes\n• Handle validation errors separately\n• Provide option to include request path in error\n• Consider internationalization for error messages"
    },
    {
      "id": 49,
      "category": "Exception Handling",
      "question": "What is @ControllerAdvice and how does it work?",
      "answer": "@ControllerAdvice is a specialized component annotation in Spring Boot that enables global exception handling, data binding, and model attribute initialization across all @Controller classes. It provides a centralized way to handle exceptions and apply cross-cutting concerns to multiple controllers.\n\nCore Concept:\n\n• Annotation for global controller configuration\n• Applies to all controllers in the application\n• Primary use: Centralized exception handling\n• Works through AOP (Aspect-Oriented Programming)\n• Can be combined with @ExceptionHandler, @InitBinder, @ModelAttribute\n• Creates a proxy that intercepts controller method calls\n\nHow It Works:\n\n• Spring scans for @ControllerAdvice annotated classes at startup\n• Creates an advice bean that wraps all controllers\n• When exception occurs in any controller, Spring delegates to @ControllerAdvice\n• Matching @ExceptionHandler method handles the exception\n• Returns appropriate error response to client\n• Acts as a global interceptor for controller exceptions\n\nBasic Implementation:\n\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"USER_NOT_FOUND\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"INTERNAL_ERROR\",\n            \"An unexpected error occurred\",\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n}\n\nWith @RestControllerAdvice:\n\n@RestControllerAdvice // Combines @ControllerAdvice + @ResponseBody\npublic class RestExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ErrorResponse handleResourceNotFound(ResourceNotFoundException ex) {\n        // Automatically serialized to JSON\n        return new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n    }\n}\n\nHow Exception Flow Works:\n\nStep 1 - Exception Occurs in Controller:\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // Exception thrown here\n        throw new UserNotFoundException(\"User not found: \" + id);\n    }\n}\n\nStep 2 - Spring Catches Exception:\n• Exception propagates from controller method\n• Spring's DispatcherServlet catches it\n• Looks for matching @ControllerAdvice\n• Searches for @ExceptionHandler that handles UserNotFoundException\n\nStep 3 - @ControllerAdvice Handles It:\n\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        // This method is invoked\n        ErrorResponse error = new ErrorResponse(\n            \"USER_NOT_FOUND\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n}\n\nStep 4 - Response Sent to Client:\n• HTTP 404 Not Found\n• JSON body with error details\n\nAdvanced Features:\n\nScope to Specific Packages:\n\n@ControllerAdvice(basePackages = \"com.example.controllers\")\npublic class PackageLevelExceptionHandler {\n    // Only applies to controllers in specified package\n}\n\nScope to Specific Controllers:\n\n@ControllerAdvice(assignableTypes = {UserController.class, ProductController.class})\npublic class SpecificControllerAdvice {\n    // Only applies to UserController and ProductController\n}\n\nScope with Annotations:\n\n@ControllerAdvice(annotations = RestController.class)\npublic class RestControllerAdvice {\n    // Only applies to @RestController classes\n}\n\nMultiple Exception Types:\n\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler({UserNotFoundException.class, ProductNotFoundException.class})\n    public ResponseEntity<ErrorResponse> handleNotFound(RuntimeException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"NOT_FOUND\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n}\n\nAccess Request Information:\n\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(InvalidRequestException.class)\n    public ResponseEntity<ErrorResponse> handleInvalidRequest(\n            InvalidRequestException ex,\n            WebRequest request) {\n        \n        ErrorResponse error = new ErrorResponse(\n            \"INVALID_REQUEST\",\n            ex.getMessage(),\n            LocalDateTime.now(),\n            request.getDescription(false) // Get request URI\n        );\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);\n    }\n}\n\nValidation Error Handling:\n\n@RestControllerAdvice\npublic class ValidationExceptionHandler {\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(\n            MethodArgumentNotValidException ex) {\n        \n        List<String> errors = ex.getBindingResult()\n            .getFieldErrors()\n            .stream()\n            .map(error -> error.getField() + \": \" + error.getDefaultMessage())\n            .collect(Collectors.toList());\n        \n        ValidationErrorResponse response = new ValidationErrorResponse(\n            \"VALIDATION_FAILED\",\n            \"Invalid input provided\",\n            errors,\n            LocalDateTime.now()\n        );\n        \n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);\n    }\n}\n\nOther Uses of @ControllerAdvice:\n\nGlobal Data Binding:\n\n@ControllerAdvice\npublic class GlobalControllerAdvice {\n    \n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        // Custom date format for all controllers\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));\n    }\n}\n\nGlobal Model Attributes:\n\n@ControllerAdvice\npublic class GlobalModelAttributes {\n    \n    @ModelAttribute(\"appName\")\n    public String appName() {\n        // Available in all controller views\n        return \"My Application\";\n    }\n    \n    @ModelAttribute(\"currentYear\")\n    public int currentYear() {\n        return LocalDateTime.now().getYear();\n    }\n}\n\nKey Differences:\n\n@ControllerAdvice vs @RestControllerAdvice:\n• @ControllerAdvice: Requires @ResponseBody on handler methods\n• @RestControllerAdvice: Automatically adds @ResponseBody\n• @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n• Use @RestControllerAdvice for REST APIs\n\nAdvantages:\n\n• Centralized exception handling\n• Code reusability across controllers\n• Consistent error responses\n• Clean controller code\n• Easy maintenance and updates\n• Separation of concerns\n• Single source of truth for error handling\n• Reduces boilerplate code\n\nBest Practices:\n\n• Use @RestControllerAdvice for REST APIs\n• Create custom exception classes for domain-specific errors\n• Provide meaningful error messages\n• Include timestamp and request path in error response\n• Log errors appropriately\n• Handle specific exceptions before generic ones\n• Don't expose sensitive information in error messages\n• Use appropriate HTTP status codes\n• Consider creating separate @ControllerAdvice for different modules\n• Extend ResponseEntityExceptionHandler for built-in Spring exception handling"
    },
    {
      "id": 50,
      "category": "Exception Handling",
      "question": "What is a Global Exception Handler in Spring Boot?",
      "answer": "A Global Exception Handler in Spring Boot is a centralized mechanism to handle all exceptions thrown by any controller in the application from a single place. It's implemented using @ControllerAdvice or @RestControllerAdvice annotations along with @ExceptionHandler methods.\n\nCore Purpose:\n\n• Handle exceptions from all controllers in one place\n• Provide consistent error responses across the application\n• Eliminate duplicate exception handling code\n• Improve code maintainability\n• Create uniform error response structure\n• Enable centralized logging of errors\n\nImplementation:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    \n    // Handle custom business exceptions\n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            \"User Not Found\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        log.warn(\"User not found: {}\", ex.getMessage());\n        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);\n    }\n    \n    @ExceptionHandler(DuplicateEmailException.class)\n    public ResponseEntity<ErrorResponse> handleDuplicateEmail(DuplicateEmailException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.CONFLICT.value(),\n            \"Duplicate Email\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        log.warn(\"Duplicate email: {}\", ex.getMessage());\n        return new ResponseEntity<>(error, HttpStatus.CONFLICT);\n    }\n    \n    // Handle validation errors\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(\n            MethodArgumentNotValidException ex) {\n        \n        List<String> errors = ex.getBindingResult()\n            .getFieldErrors()\n            .stream()\n            .map(error -> error.getField() + \": \" + error.getDefaultMessage())\n            .collect(Collectors.toList());\n        \n        ValidationErrorResponse response = new ValidationErrorResponse(\n            HttpStatus.BAD_REQUEST.value(),\n            \"Validation Failed\",\n            \"Invalid input provided\",\n            errors,\n            LocalDateTime.now()\n        );\n        \n        log.warn(\"Validation failed: {}\", errors);\n        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);\n    }\n    \n    // Handle access denied\n    @ExceptionHandler(AccessDeniedException.class)\n    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.FORBIDDEN.value(),\n            \"Access Denied\",\n            \"You don't have permission to access this resource\",\n            LocalDateTime.now()\n        );\n        log.warn(\"Access denied: {}\", ex.getMessage());\n        return new ResponseEntity<>(error, HttpStatus.FORBIDDEN);\n    }\n    \n    // Handle database errors\n    @ExceptionHandler(DataAccessException.class)\n    public ResponseEntity<ErrorResponse> handleDatabaseErrors(DataAccessException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Database Error\",\n            \"A database error occurred\",\n            LocalDateTime.now()\n        );\n        log.error(\"Database error: \", ex);\n        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n    \n    // Generic exception handler - catches all unhandled exceptions\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Internal Server Error\",\n            \"An unexpected error occurred\",\n            LocalDateTime.now()\n        );\n        log.error(\"Unexpected error: \", ex);\n        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n\nError Response Models:\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ErrorResponse {\n    private int status;\n    private String error;\n    private String message;\n    private LocalDateTime timestamp;\n    private String path; // Optional: request path\n}\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ValidationErrorResponse {\n    private int status;\n    private String error;\n    private String message;\n    private List<String> details;\n    private LocalDateTime timestamp;\n}\n\nCustom Exception Classes:\n\npublic class UserNotFoundException extends RuntimeException {\n    public UserNotFoundException(String message) {\n        super(message);\n    }\n    \n    public UserNotFoundException(Long id) {\n        super(\"User not found with id: \" + id);\n    }\n}\n\npublic class DuplicateEmailException extends RuntimeException {\n    public DuplicateEmailException(String email) {\n        super(\"Email already exists: \" + email);\n    }\n}\n\npublic class InvalidRequestException extends RuntimeException {\n    public InvalidRequestException(String message) {\n        super(message);\n    }\n}\n\npublic class ResourceNotFoundException extends RuntimeException {\n    public ResourceNotFoundException(String resource, String field, Object value) {\n        super(String.format(\"%s not found with %s: %s\", resource, field, value));\n    }\n}\n\nHow It Works in Real Application:\n\nController Layer (Clean, No Exception Handling):\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        // No try-catch needed!\n        User user = userService.getUser(id);\n        return ResponseEntity.ok(user);\n    }\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@Valid @RequestBody UserRequest request) {\n        // Validation errors automatically handled by GlobalExceptionHandler\n        User user = userService.createUser(request);\n        return ResponseEntity.status(HttpStatus.CREATED).body(user);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteUser(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n\nService Layer (Throws Exceptions):\n\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public User getUser(Long id) {\n        // Exception thrown, caught by GlobalExceptionHandler\n        return userRepository.findById(id)\n            .orElseThrow(() -> new UserNotFoundException(id));\n    }\n    \n    public User createUser(UserRequest request) {\n        // Check for duplicate email\n        if (userRepository.existsByEmail(request.getEmail())) {\n            throw new DuplicateEmailException(request.getEmail());\n        }\n        \n        User user = new User();\n        user.setEmail(request.getEmail());\n        user.setName(request.getName());\n        return userRepository.save(user);\n    }\n    \n    public void deleteUser(Long id) {\n        User user = getUser(id); // Reuses exception handling\n        userRepository.delete(user);\n    }\n}\n\nBenefits:\n\n• Centralized error handling across entire application\n• Consistent error response format for all APIs\n• Clean controller code without try-catch blocks\n• Easy to maintain and update error handling logic\n• Separation of concerns (business logic vs error handling)\n• Centralized logging of all errors\n• Improved code readability\n• Reduced code duplication\n• Better API documentation with consistent error responses\n• Easy to add new exception types\n\nCommon HTTP Status Codes Used:\n\n• 400 Bad Request: Validation errors, invalid input\n• 401 Unauthorized: Authentication required\n• 403 Forbidden: Access denied\n• 404 Not Found: Resource not found\n• 409 Conflict: Duplicate resource, constraint violation\n• 500 Internal Server Error: Unexpected errors, database errors\n• 503 Service Unavailable: External service failures\n\nBest Practices:\n\n• Always log exceptions at appropriate levels (warn for client errors, error for server errors)\n• Don't expose sensitive information in error messages\n• Use meaningful HTTP status codes\n• Create custom exception classes for domain-specific errors\n• Provide actionable error messages\n• Include timestamp in error response\n• Consider adding request ID or correlation ID for tracking\n• Handle validation errors separately with detailed field-level errors\n• Use generic exception handler as fallback\n• Test exception handling thoroughly\n• Document expected error responses in API documentation"
    },
    {
      "id": 51,
      "category": "Exception Handling",
      "question": "How does exception handling work with @ControllerAdvice and @ExceptionHandler?",
      "answer": "Exception handling with @ControllerAdvice and @ExceptionHandler provides a powerful mechanism in Spring Boot to handle exceptions globally across all controllers. Here's how they work together:\n\nCore Components:\n\n• @ControllerAdvice: Class-level annotation that makes the class a global exception handler\n• @ExceptionHandler: Method-level annotation that specifies which exception(s) the method handles\n• Together they create centralized exception handling\n\nHow They Work Together:\n\nStep 1 - Define Global Exception Handler Class:\n\n@RestControllerAdvice // or @ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    // Exception handler methods go here\n}\n\nStep 2 - Add @ExceptionHandler Methods:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    // Handles specific exception type\n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            \"User not found\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    // Handles another exception type\n    @ExceptionHandler(DuplicateEmailException.class)\n    public ResponseEntity<ErrorResponse> handleDuplicateEmail(DuplicateEmailException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.CONFLICT.value(),\n            \"Duplicate email\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);\n    }\n}\n\nExecution Flow:\n\nController throws exception:\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // Step 1: Exception is thrown\n        throw new UserNotFoundException(\"User not found with id: \" + id);\n    }\n}\n\nSpring catches and routes exception:\n\n1. Exception propagates from controller method\n2. Spring's DispatcherServlet intercepts it\n3. Looks for @ControllerAdvice classes\n4. Searches for @ExceptionHandler method matching the exception type\n5. Invokes the matching handler method\n6. Returns the response from handler\n\n@ExceptionHandler method handles it:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    // Step 2: This method is invoked\n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        // Step 3: Create error response\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            \"User not found\",\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        // Step 4: Return response to client\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n}\n\nComplete Working Example:\n\nCustom Exception Classes:\n\npublic class UserNotFoundException extends RuntimeException {\n    public UserNotFoundException(String message) {\n        super(message);\n    }\n}\n\npublic class DuplicateEmailException extends RuntimeException {\n    public DuplicateEmailException(String message) {\n        super(message);\n    }\n}\n\npublic class InvalidRequestException extends RuntimeException {\n    public InvalidRequestException(String message) {\n        super(message);\n    }\n}\n\nError Response Model:\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ErrorResponse {\n    private int status;\n    private String error;\n    private String message;\n    private LocalDateTime timestamp;\n    private String path;\n}\n\nGlobal Exception Handler:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    \n    // Handle single exception type\n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(\n            UserNotFoundException ex,\n            WebRequest request) {\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            \"Not Found\",\n            ex.getMessage(),\n            LocalDateTime.now(),\n            getPath(request)\n        );\n        \n        log.warn(\"User not found: {}\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    // Handle multiple exception types\n    @ExceptionHandler({DuplicateEmailException.class, DuplicateUsernameException.class})\n    public ResponseEntity<ErrorResponse> handleDuplicateResource(\n            RuntimeException ex,\n            WebRequest request) {\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.CONFLICT.value(),\n            \"Conflict\",\n            ex.getMessage(),\n            LocalDateTime.now(),\n            getPath(request)\n        );\n        \n        log.warn(\"Duplicate resource: {}\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);\n    }\n    \n    // Handle validation errors\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(\n            MethodArgumentNotValidException ex,\n            WebRequest request) {\n        \n        List<String> errors = ex.getBindingResult()\n            .getFieldErrors()\n            .stream()\n            .map(error -> error.getField() + \": \" + error.getDefaultMessage())\n            .collect(Collectors.toList());\n        \n        ValidationErrorResponse response = new ValidationErrorResponse(\n            HttpStatus.BAD_REQUEST.value(),\n            \"Validation Failed\",\n            \"Invalid input provided\",\n            errors,\n            LocalDateTime.now(),\n            getPath(request)\n        );\n        \n        log.warn(\"Validation failed: {}\", errors);\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);\n    }\n    \n    // Handle invalid request\n    @ExceptionHandler(InvalidRequestException.class)\n    public ResponseEntity<ErrorResponse> handleInvalidRequest(\n            InvalidRequestException ex,\n            WebRequest request) {\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.BAD_REQUEST.value(),\n            \"Bad Request\",\n            ex.getMessage(),\n            LocalDateTime.now(),\n            getPath(request)\n        );\n        \n        log.warn(\"Invalid request: {}\", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);\n    }\n    \n    // Handle database errors\n    @ExceptionHandler(DataAccessException.class)\n    public ResponseEntity<ErrorResponse> handleDatabaseErrors(\n            DataAccessException ex,\n            WebRequest request) {\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Database Error\",\n            \"A database error occurred\",\n            LocalDateTime.now(),\n            getPath(request)\n        );\n        \n        log.error(\"Database error: \", ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n    \n    // Generic exception handler - must be last\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(\n            Exception ex,\n            WebRequest request) {\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Internal Server Error\",\n            \"An unexpected error occurred\",\n            LocalDateTime.now(),\n            getPath(request)\n        );\n        \n        log.error(\"Unexpected error: \", ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n    \n    private String getPath(WebRequest request) {\n        return request.getDescription(false).replace(\"uri=\", \"\");\n    }\n}\n\nController Usage (Clean Code):\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    // No try-catch needed - exceptions handled globally\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        User user = userService.getUser(id);\n        return ResponseEntity.ok(user);\n    }\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@Valid @RequestBody UserRequest request) {\n        User user = userService.createUser(request);\n        return ResponseEntity.status(HttpStatus.CREATED).body(user);\n    }\n    \n    @PutMapping(\"/{id}\")\n    public ResponseEntity<User> updateUser(\n            @PathVariable Long id,\n            @Valid @RequestBody UserRequest request) {\n        User user = userService.updateUser(id, request);\n        return ResponseEntity.ok(user);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteUser(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n\nService Layer:\n\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public User getUser(Long id) {\n        // Exception thrown here is caught by GlobalExceptionHandler\n        return userRepository.findById(id)\n            .orElseThrow(() -> new UserNotFoundException(\"User not found with id: \" + id));\n    }\n    \n    public User createUser(UserRequest request) {\n        // Check for duplicate\n        if (userRepository.existsByEmail(request.getEmail())) {\n            throw new DuplicateEmailException(\"Email already exists: \" + request.getEmail());\n        }\n        \n        User user = new User();\n        user.setEmail(request.getEmail());\n        user.setName(request.getName());\n        return userRepository.save(user);\n    }\n    \n    public User updateUser(Long id, UserRequest request) {\n        User user = getUser(id);\n        user.setName(request.getName());\n        return userRepository.save(user);\n    }\n    \n    public void deleteUser(Long id) {\n        User user = getUser(id);\n        userRepository.delete(user);\n    }\n}\n\nKey Features:\n\nException Hierarchy:\n• Specific exceptions handled first\n• Generic Exception handler acts as fallback\n• Spring matches most specific handler\n\nMethod Parameters:\n• Exception object (required)\n• WebRequest (optional) - for request details\n• HttpServletRequest (optional)\n• HttpServletResponse (optional)\n\nReturn Types:\n• ResponseEntity<T> - full control over response\n• Direct object - uses @ResponseBody\n• ModelAndView - for view rendering\n• String - view name\n\nScoping:\n• Default: applies to all controllers\n• basePackages: specific packages\n• assignableTypes: specific controller classes\n• annotations: controllers with specific annotations\n\nAdvantages:\n\n• Centralized exception handling\n• Clean controller code\n• Consistent error responses\n• Easy to maintain\n• Reduced code duplication\n• Better separation of concerns\n• Simplified testing\n• Improved readability\n\nBest Practices:\n\n• Use @RestControllerAdvice for REST APIs\n• Create custom exceptions for domain-specific errors\n• Handle specific exceptions before generic ones\n• Log exceptions at appropriate levels\n• Include timestamp and request path in error response\n• Don't expose sensitive information\n• Use meaningful HTTP status codes\n• Provide actionable error messages\n• Handle validation errors with detailed field errors\n• Test exception handling thoroughly\n\nCommon Exception Types:\n\n• UserNotFoundException - 404 Not Found\n• DuplicateEmailException - 409 Conflict\n• InvalidRequestException - 400 Bad Request\n• AccessDeniedException - 403 Forbidden\n• MethodArgumentNotValidException - 400 Bad Request\n• DataAccessException - 500 Internal Server Error\n• Exception (generic) - 500 Internal Server Error"
    },
    {
      "id": 52,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "How do you enable async methods in Spring Boot?",
      "answer": "• Add @EnableAsync annotation to your configuration class or main application class\n• Annotate methods you want to execute asynchronously with @Async\n• The method should return void or Future/CompletableFuture\n• Spring creates a proxy for the bean and executes @Async methods in a separate thread\n• Example:\n\n@SpringBootApplication\n@EnableAsync\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n@Service\npublic class AsyncService {\n    @Async\n    public CompletableFuture<String> processData() {\n        // Long running task\n        return CompletableFuture.completedFuture(\"Result\");\n    }\n}\n\n• Important: @Async will not work if you call the method from within the same class"
    },
    {
      "id": 53,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "What is @Async?",
      "answer": "• @Async is a Spring annotation that marks a method to be executed asynchronously\n• When a method is annotated with @Async, Spring executes it in a separate thread\n• Key characteristics:\n  - Must be applied to public methods only\n  - Self-invocation (calling @Async method from same class) doesn't work\n  - Requires @EnableAsync to be enabled\n  - Can specify custom executor using @Async(\"executorName\")\n• Return types supported:\n  - void: Fire and forget\n  - Future: Get result later with blocking\n  - CompletableFuture: Non-blocking asynchronous result\n• Example:\n\n@Async\npublic CompletableFuture<User> findUser(Long id) {\n    User user = userRepository.findById(id);\n    return CompletableFuture.completedFuture(user);\n}"
    },
    {
      "id": 54,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "How do you configure a custom thread pool in Spring Boot?",
      "answer": "• Create a configuration class with @Configuration\n• Define a bean that returns ThreadPoolTaskExecutor or Executor\n• Configure core pool size, max pool size, queue capacity, and thread name prefix\n• Example:\n\n@Configuration\n@EnableAsync\npublic class AsyncConfig {\n    @Bean(name = \"taskExecutor\")\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(\"async-\");\n        executor.initialize();\n        return executor;\n    }\n}\n\n// Use in service\n@Async(\"taskExecutor\")\npublic CompletableFuture<String> processAsync() {\n    // Process\n    return CompletableFuture.completedFuture(\"Done\");\n}"
    },
    {
      "id": 55,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "What is the difference between @Async and CompletableFuture?",
      "answer": "• @Async is an annotation that tells Spring to execute a method asynchronously\n• CompletableFuture is a Java class for handling asynchronous computations\n• Key differences:\n  - @Async: Spring framework feature, declarative approach\n  - CompletableFuture: Java 8+ feature, programmatic approach\n  - @Async requires Spring context and proxy\n  - CompletableFuture can be used anywhere without Spring\n• They work together:\n\n@Async\npublic CompletableFuture<String> getData() {\n    String result = fetchData();\n    return CompletableFuture.completedFuture(result);\n}\n\n• CompletableFuture provides:\n  - Chaining operations with thenApply, thenCompose\n  - Combining multiple futures with allOf, anyOf\n  - Exception handling with exceptionally\n• @Async provides:\n  - Simple thread pool management by Spring\n  - Integration with Spring's transaction management\n  - Declarative configuration"
    },
    {
      "id": 56,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "How do you handle exceptions in @Async methods?",
      "answer": "• For void return type, implement AsyncUncaughtExceptionHandler\n• For Future/CompletableFuture, handle exceptions in the returned object\n• Configure custom exception handler:\n\n@Configuration\n@EnableAsync\npublic class AsyncConfig implements AsyncConfigurer {\n    @Override\n    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {\n        return new CustomAsyncExceptionHandler();\n    }\n}\n\npublic class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {\n    @Override\n    public void handleUncaughtException(Throwable ex, Method method, Object... params) {\n        log.error(\"Exception in async method: \" + method.getName(), ex);\n    }\n}\n\n• For CompletableFuture, use exceptionally or handle:\n\n@Async\npublic CompletableFuture<String> processData() {\n    return CompletableFuture.supplyAsync(() -> {\n        // Process\n        if (error) throw new RuntimeException(\"Error\");\n        return \"Success\";\n    }).exceptionally(ex -> {\n        log.error(\"Error: \", ex);\n        return \"Default\";\n    });\n}"
    },
    {
      "id": 57,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "What is ThreadPoolTaskExecutor?",
      "answer": "• ThreadPoolTaskExecutor is Spring's implementation of TaskExecutor interface\n• It wraps Java's ThreadPoolExecutor and provides Spring-friendly configuration\n• Key configuration properties:\n  - corePoolSize: Minimum number of threads to keep alive\n  - maxPoolSize: Maximum number of threads allowed\n  - queueCapacity: Size of the queue for pending tasks\n  - keepAliveSeconds: Time to keep idle threads alive\n  - threadNamePrefix: Prefix for thread names\n• Benefits:\n  - Integrates with Spring's lifecycle management\n  - Provides graceful shutdown\n  - Thread pooling for better performance\n  - Configurable rejection policies\n• Example configuration:\n\nThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\nexecutor.setCorePoolSize(10);\nexecutor.setMaxPoolSize(20);\nexecutor.setQueueCapacity(50);\nexecutor.setThreadNamePrefix(\"custom-executor-\");\nexecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\nexecutor.initialize();"
    },
    {
      "id": 58,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "What is the difference between @Scheduled and @Async?",
      "answer": "• @Scheduled is for executing tasks at fixed intervals or specific times\n• @Async is for executing methods asynchronously in a separate thread\n• Key differences:\n  - Purpose: @Scheduled for scheduling, @Async for async execution\n  - Trigger: @Scheduled runs automatically, @Async runs when called\n  - Configuration: @Scheduled needs @EnableScheduling, @Async needs @EnableAsync\n• @Scheduled examples:\n\n@Scheduled(fixedRate = 5000) // Every 5 seconds\npublic void fixedRateTask() { }\n\n@Scheduled(cron = \"0 0 12 * * ?\") // Daily at noon\npublic void cronTask() { }\n\n• @Async example:\n\n@Async\npublic CompletableFuture<String> asyncTask() {\n    return CompletableFuture.completedFuture(\"Done\");\n}\n\n• They can be combined:\n\n@Scheduled(fixedRate = 5000)\n@Async\npublic void scheduledAsyncTask() {\n    // Scheduled task runs async\n}"
    },
    {
      "id": 59,
      "category": "Multithreading, Concurrency & Executor Framework",
      "question": "How do you configure thread pool for @Scheduled tasks?",
      "answer": "• By default, @Scheduled tasks run in a single thread\n• To configure a thread pool, create a SchedulingConfigurer bean\n• Set the pool size using ThreadPoolTaskScheduler\n• Example:\n\n@Configuration\n@EnableScheduling\npublic class SchedulingConfig implements SchedulingConfigurer {\n    @Override\n    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\n        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();\n        taskScheduler.setPoolSize(10);\n        taskScheduler.setThreadNamePrefix(\"scheduled-\");\n        taskScheduler.initialize();\n        taskRegistrar.setTaskScheduler(taskScheduler);\n    }\n}\n\n• Alternative using application.properties:\n\nspring.task.scheduling.pool.size=10\nspring.task.scheduling.thread-name-prefix=scheduled-\n\n• Benefits of thread pool:\n  - Multiple scheduled tasks can run concurrently\n  - Prevents blocking if one task takes longer\n  - Better resource utilization"
    },
    {
      "id": 60,
      "category": "Spring Boot in Microservices",
      "question": "What is Spring Cloud?",
      "answer": "• Spring Cloud is a framework that provides tools for building and managing microservices\n• It provides solutions for common patterns in distributed systems\n• Key components:\n  - Service Discovery (Eureka, Consul)\n  - Configuration Management (Config Server)\n  - Circuit Breakers (Resilience4j, Hystrix)\n  - API Gateway (Spring Cloud Gateway)\n  - Load Balancing (Ribbon, LoadBalancer)\n  - Distributed Tracing (Sleuth, Zipkin)\n• Built on top of Spring Boot for easy integration\n• Example dependencies:\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n```"
    },
    {
      "id": 61,
      "category": "Spring Boot in Microservices",
      "question": "What is Service Discovery? Explain Eureka.",
      "answer": "• Service Discovery is a mechanism to automatically detect devices and services on a network\n• In microservices, it helps services find and communicate with each other dynamically\n• Netflix Eureka is a service registry for resilient mid-tier load balancing and failover\n• Components:\n  - Eureka Server: Registry where services register themselves\n  - Eureka Client: Services that register and discover other services\n• How it works:\n  - Services register with Eureka Server on startup\n  - Services send heartbeats every 30 seconds\n  - Clients can query Eureka to find other services\n  - If heartbeats stop, service is removed from registry\n• Eureka Server example:\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n```\n\n• Eureka Client example:\n\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class ServiceApplication { }\n```"
    },
    {
      "id": 62,
      "category": "Spring Boot in Microservices",
      "question": "What is an API Gateway? Explain Spring Cloud Gateway.",
      "answer": "• API Gateway is a single entry point for all client requests to microservices\n• It acts as a reverse proxy, routing requests to appropriate services\n• Benefits:\n  - Centralized authentication and authorization\n  - Rate limiting and throttling\n  - Request/response transformation\n  - Load balancing\n  - Monitoring and logging\n• Spring Cloud Gateway features:\n  - Built on Spring WebFlux (reactive)\n  - Route matching based on path, headers, query params\n  - Filters for request/response modification\n  - Circuit breaker integration\n• Example configuration:\n\n```java\n@Configuration\npublic class GatewayConfig {\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n        return builder.routes()\n            .route(\"user-service\", r -> r.path(\"/users/**\")\n                .uri(\"lb://USER-SERVICE\"))\n            .route(\"order-service\", r -> r.path(\"/orders/**\")\n                .uri(\"lb://ORDER-SERVICE\"))\n            .build();\n    }\n}\n```\n\n• application.yml example:\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: user-service\n          uri: lb://USER-SERVICE\n          predicates:\n            - Path=/users/**\n```"
    },
    {
      "id": 63,
      "category": "Spring Boot in Microservices",
      "question": "What is Circuit Breaker? Explain Resilience4j.",
      "answer": "• Circuit Breaker is a design pattern to prevent cascading failures in microservices\n• It monitors for failures and opens the circuit when threshold is reached\n• Three states:\n  - Closed: Normal operation, requests pass through\n  - Open: Too many failures, requests fail immediately\n  - Half-Open: Testing if service recovered\n• Resilience4j is a lightweight fault tolerance library\n• Key features:\n  - Circuit Breaker\n  - Rate Limiter\n  - Retry mechanism\n  - Bulkhead (limit concurrent calls)\n  - Time Limiter\n• Example implementation:\n\n```java\n@Service\npublic class UserService {\n    @CircuitBreaker(name = \"userService\", fallbackMethod = \"fallbackGetUser\")\n    public User getUser(Long id) {\n        return restTemplate.getForObject(\"http://USER-SERVICE/users/\" + id, User.class);\n    }\n    \n    public User fallbackGetUser(Long id, Exception ex) {\n        return new User(id, \"Default User\");\n    }\n}\n```\n\n• Configuration in application.yml:\n\n```yaml\nresilience4j:\n  circuitbreaker:\n    instances:\n      userService:\n        slidingWindowSize: 10\n        failureRateThreshold: 50\n        waitDurationInOpenState: 10000\n```"
    },
    {
      "id": 64,
      "category": "Spring Boot in Microservices",
      "question": "What is the difference between Ribbon and Spring Cloud LoadBalancer?",
      "answer": "• Both are client-side load balancers for distributing requests across service instances\n• Ribbon is older Netflix library, now in maintenance mode\n• Spring Cloud LoadBalancer is the modern replacement\n• Key differences:\n  - Ribbon: Netflix OSS, blocking/synchronous\n  - LoadBalancer: Spring Cloud, reactive and blocking support\n  - Ribbon: No longer actively developed\n  - LoadBalancer: Actively maintained by Spring team\n  - LoadBalancer: Better integration with Spring ecosystem\n• Spring Cloud LoadBalancer usage:\n\n```java\n@Configuration\npublic class LoadBalancerConfig {\n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n\n@Service\npublic class OrderService {\n    @Autowired\n    private RestTemplate restTemplate;\n    \n    public Order getOrder(Long id) {\n        return restTemplate.getForObject(\"http://ORDER-SERVICE/orders/\" + id, Order.class);\n    }\n}\n```\n\n• Migration from Ribbon to LoadBalancer is straightforward\n• LoadBalancer is default in Spring Cloud 2020.0.0+"
    },
    {
      "id": 65,
      "category": "Spring Boot in Microservices",
      "question": "What is Spring Cloud Config?",
      "answer": "• Spring Cloud Config provides centralized external configuration for distributed systems\n• It allows you to manage application configuration across all environments\n• Components:\n  - Config Server: Hosts configuration files\n  - Config Client: Applications that fetch configuration\n• Benefits:\n  - Centralized configuration management\n  - Environment-specific configurations\n  - Dynamic configuration updates without restart\n  - Version control integration (Git, SVN)\n  - Encryption/decryption support\n• Config Server setup:\n\n```java\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigServerApplication.class, args);\n    }\n}\n```\n\n• application.yml:\n\n```yaml\nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/myorg/config-repo\n          default-label: main\n```\n\n• Config Client setup:\n\n```properties\nspring.application.name=user-service\nspring.cloud.config.uri=http://localhost:8888\n```\n\n• Configuration files in Git: user-service.yml, user-service-dev.yml, user-service-prod.yml"
    },
    {
      "id": 66,
      "category": "Spring Boot in Microservices",
      "question": "How do you implement distributed tracing in Spring Boot?",
      "answer": "• Distributed tracing tracks requests as they flow through multiple microservices\n• Spring Cloud Sleuth and Zipkin are commonly used for this\n• Spring Cloud Sleuth:\n  - Automatically adds trace and span IDs to logs\n  - Integrates with logging frameworks\n  - No code changes required\n• Zipkin:\n  - Collects and visualizes tracing data\n  - Provides UI to see service dependencies\n  - Shows request latency across services\n• Implementation steps:\n  1. Add dependencies:\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-sleuth</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-sleuth-zipkin</artifactId>\n</dependency>\n```\n\n  2. Configure Zipkin server URL:\n\n```yaml\nspring:\n  zipkin:\n    base-url: http://localhost:9411\n  sleuth:\n    sampler:\n      probability: 1.0\n```\n\n  3. Logs automatically include trace ID:\n\n```\n2024-01-15 [user-service,a1b2c3d4e5f6,span123] INFO - Processing request\n```\n\n• Key concepts:\n  - Trace: End-to-end request journey\n  - Span: Single operation within a trace\n  - Trace ID: Unique identifier for entire request\n  - Span ID: Unique identifier for each operation"
    },
    {
      "id": 67,
      "category": "Spring Boot in Microservices",
      "question": "What is the difference between Monolithic and Microservices architecture?",
      "answer": "• Monolithic: Single, unified application where all components are interconnected\n• Microservices: Collection of small, independent services that communicate via APIs\n• Key differences:\n  - Deployment: Monolithic deploys as one unit, Microservices deploy independently\n  - Scalability: Monolithic scales entire app, Microservices scales individual services\n  - Development: Monolithic single codebase, Microservices multiple codebases\n  - Technology: Monolithic same tech stack, Microservices polyglot flexibility\n  - Failure isolation: Monolithic one failure affects all, Microservices isolated failures\n• Monolithic advantages:\n  - Simpler to develop and test initially\n  - Easier debugging and deployment\n  - No distributed system complexity\n  - Better performance (no network calls)\n• Microservices advantages:\n  - Independent deployment and scaling\n  - Technology diversity\n  - Better fault isolation\n  - Easier to understand individual services\n  - Team autonomy\n• Monolithic challenges:\n  - Difficult to scale specific features\n  - Long deployment cycles\n  - Large codebase hard to maintain\n  - Technology lock-in\n• Microservices challenges:\n  - Distributed system complexity\n  - Network latency and failures\n  - Data consistency challenges\n  - More operational overhead"
    },
    {
      "id": 68,
      "category": "Spring Boot in Microservices",
      "question": "How do you handle inter-service communication in microservices?",
      "answer": "• Inter-service communication can be synchronous or asynchronous\n• Synchronous communication:\n  - REST APIs using RestTemplate or WebClient\n  - gRPC for high-performance communication\n  - GraphQL for flexible data queries\n• Asynchronous communication:\n  - Message queues (RabbitMQ, Kafka)\n  - Event-driven architecture\n  - Publish-Subscribe pattern\n• REST example with RestTemplate:\n\n```java\n@Service\npublic class OrderService {\n    @Autowired\n    @LoadBalanced\n    private RestTemplate restTemplate;\n    \n    public User getUser(Long userId) {\n        return restTemplate.getForObject(\"http://USER-SERVICE/users/\" + userId, User.class);\n    }\n}\n```\n\n• WebClient (reactive) example:\n\n```java\n@Service\npublic class OrderService {\n    @Autowired\n    private WebClient.Builder webClientBuilder;\n    \n    public Mono<User> getUser(Long userId) {\n        return webClientBuilder.build()\n            .get()\n            .uri(\"http://USER-SERVICE/users/\" + userId)\n            .retrieve()\n            .bodyToMono(User.class);\n    }\n}\n```\n\n• Message-based communication with Kafka:\n\n```java\n@Service\npublic class OrderService {\n    @Autowired\n    private KafkaTemplate<String, OrderEvent> kafkaTemplate;\n    \n    public void createOrder(Order order) {\n        // Save order\n        kafkaTemplate.send(\"order-created\", new OrderEvent(order));\n    }\n}\n```\n\n• Best practices:\n  - Use circuit breakers for resilience\n  - Implement retry logic\n  - Use service discovery\n  - Consider eventual consistency\n  - Use correlation IDs for tracing"
    },
    {
      "id": 69,
      "category": "Spring Boot in Microservices",
      "question": "What is Saga pattern in microservices?",
      "answer": "• Saga pattern is a way to manage distributed transactions across microservices\n• Each service performs a local transaction and publishes an event\n• Other services listen to events and perform their local transactions\n• Two types of Saga:\n  - Choreography: Services react to events (decentralized)\n  - Orchestration: Central coordinator manages workflow\n• Choreography example:\n  - Order Service creates order → publishes OrderCreated event\n  - Payment Service listens → processes payment → publishes PaymentCompleted\n  - Inventory Service listens → reserves items → publishes ItemsReserved\n  - Shipping Service listens → ships order\n• Orchestration example:\n\n```java\n@Service\npublic class OrderSagaOrchestrator {\n    public void createOrder(Order order) {\n        try {\n            // Step 1: Create order\n            orderService.createOrder(order);\n            // Step 2: Process payment\n            paymentService.processPayment(order.getPaymentInfo());\n            // Step 3: Reserve inventory\n            inventoryService.reserveItems(order.getItems());\n            // Step 4: Ship order\n            shippingService.shipOrder(order);\n        } catch (Exception e) {\n            // Compensating transactions\n            compensate(order);\n        }\n    }\n}\n```\n\n• Compensating transactions:\n  - If any step fails, previous steps must be undone\n  - Each service must provide compensation logic\n  - Example: Refund payment, release inventory, cancel order\n• Benefits:\n  - Maintains data consistency without distributed transactions\n  - Better scalability\n  - Services remain loosely coupled\n• Challenges:\n  - Complex error handling\n  - Debugging distributed workflows\n  - Eventual consistency"
    },
    {
      "id": 70,
      "category": "Spring Boot in Microservices",
      "question": "How do you secure microservices?",
      "answer": "• Microservices security involves multiple layers and strategies\n• Authentication and Authorization:\n  - OAuth 2.0 and JWT tokens\n  - Central authentication service\n  - Token validation at API Gateway\n• Example JWT implementation:\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt());\n        return http.build();\n    }\n}\n```\n\n• API Gateway security:\n  - Centralized authentication\n  - Rate limiting\n  - Request validation\n  - SSL/TLS termination\n• Service-to-service security:\n  - Mutual TLS (mTLS)\n  - Service mesh (Istio, Linkerd)\n  - JWT token propagation\n• Best practices:\n  - Use HTTPS for all communication\n  - Implement API Gateway for single entry point\n  - Use OAuth2/OpenID Connect for authentication\n  - Store secrets in secure vaults (HashiCorp Vault, AWS Secrets Manager)\n  - Implement proper RBAC (Role-Based Access Control)\n  - Use API keys for external clients\n  - Enable CORS appropriately\n  - Implement rate limiting and throttling\n  - Regular security audits and penetration testing\n• Example token propagation:\n\n```java\n@Bean\n@LoadBalanced\npublic RestTemplate restTemplate() {\n    RestTemplate restTemplate = new RestTemplate();\n    restTemplate.setInterceptors(List.of((request, body, execution) -> {\n        String token = SecurityContextHolder.getContext().getAuthentication().getCredentials().toString();\n        request.getHeaders().add(\"Authorization\", \"Bearer \" + token);\n        return execution.execute(request, body);\n    }));\n    return restTemplate;\n}\n```"
    },
    {
      "id": 71,
      "category": "CI/CD & Deployment",
      "question": "How do you containerize a Spring Boot application using Docker?",
      "answer": "• Create a Dockerfile to define the container image\n• Use multi-stage builds for smaller image sizes\n• Set up proper environment variables and ports\n• Build and run the container\n• Basic Dockerfile example:\n\n```dockerfile\nFROM openjdk:17-jdk-slim\nWORKDIR /app\nCOPY target/myapp.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n```\n\n• Multi-stage Dockerfile (better approach):\n\n```dockerfile\n# Build stage\nFROM maven:3.8-openjdk-17 AS build\nWORKDIR /app\nCOPY pom.xml .\nCOPY src ./src\nRUN mvn clean package -DskipTests\n\n# Run stage\nFROM openjdk:17-jdk-slim\nWORKDIR /app\nCOPY --from=build /app/target/*.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n```\n\n• Build and run commands:\n\n```bash\ndocker build -t myapp:1.0 .\ndocker run -p 8080:8080 myapp:1.0\n```\n\n• With environment variables:\n\n```bash\ndocker run -p 8080:8080 -e SPRING_PROFILES_ACTIVE=prod myapp:1.0\n```\n\n• Docker Compose for multiple services:\n\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      - SPRING_PROFILES_ACTIVE=docker\n    depends_on:\n      - db\n  db:\n    image: postgres:14\n    environment:\n      - POSTGRES_DB=mydb\n      - POSTGRES_PASSWORD=secret\n```"
    },
    {
      "id": 72,
      "category": "CI/CD & Deployment",
      "question": "What is the difference between JAR and WAR deployment?",
      "answer": "• JAR (Java Archive) and WAR (Web Archive) are different packaging formats\n• JAR deployment:\n  - Standalone executable with embedded server (Tomcat, Jetty)\n  - Default for Spring Boot applications\n  - Self-contained, includes all dependencies\n  - Run with: java -jar myapp.jar\n  - Easier to deploy and manage\n• WAR deployment:\n  - Requires external application server (Tomcat, WebLogic, JBoss)\n  - Traditional Java web application packaging\n  - Deployed to server's webapps directory\n  - Multiple apps can share same server\n• Spring Boot JAR structure:\n\n```\nmyapp.jar\n├── BOOT-INF\n│   ├── classes (your compiled code)\n│   └── lib (dependencies)\n├── META-INF\n└── org/springframework/boot/loader\n```\n\n• Creating WAR in Spring Boot:\n\n```xml\n<packaging>war</packaging>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n    <scope>provided</scope>\n</dependency>\n```\n\n```java\n@SpringBootApplication\npublic class Application extends SpringBootServletInitializer {\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n}\n```\n\n• When to use JAR:\n  - Microservices\n  - Cloud deployments\n  - Containerized applications\n  - Easier CI/CD\n• When to use WAR:\n  - Legacy infrastructure\n  - Shared hosting requirements\n  - Organizational standards\n  - Multiple apps on same server"
    },
    {
      "id": 73,
      "category": "CI/CD & Deployment",
      "question": "How do you implement health checks in Spring Boot?",
      "answer": "• Spring Boot Actuator provides built-in health check endpoints\n• Add Actuator dependency:\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n• Enable health endpoint in application.properties:\n\n```properties\nmanagement.endpoints.web.exposure.include=health,info\nmanagement.endpoint.health.show-details=always\n```\n\n• Default health check: http://localhost:8080/actuator/health\n• Built-in health indicators:\n  - DataSource (database connectivity)\n  - DiskSpace (disk space availability)\n  - Ping (always returns UP)\n  - Redis, MongoDB, RabbitMQ, etc.\n• Custom health indicator:\n\n```java\n@Component\npublic class CustomHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        boolean serviceUp = checkExternalService();\n        if (serviceUp) {\n            return Health.up()\n                .withDetail(\"service\", \"available\")\n                .withDetail(\"timestamp\", System.currentTimeMillis())\n                .build();\n        }\n        return Health.down()\n            .withDetail(\"service\", \"unavailable\")\n            .build();\n    }\n    \n    private boolean checkExternalService() {\n        // Check external service availability\n        return true;\n    }\n}\n```\n\n• Liveness and Readiness probes:\n\n```properties\nmanagement.endpoint.health.probes.enabled=true\nmanagement.health.livenessState.enabled=true\nmanagement.health.readinessState.enabled=true\n```\n\n• Kubernetes liveness/readiness configuration:\n\n```yaml\nlivenessProbe:\n  httpGet:\n    path: /actuator/health/liveness\n    port: 8080\n  initialDelaySeconds: 30\n  periodSeconds: 10\n  \nreadinessProbe:\n  httpGet:\n    path: /actuator/health/readiness\n    port: 8080\n  initialDelaySeconds: 10\n  periodSeconds: 5\n```\n\n• Health check response example:\n\n```json\n{\n  \"status\": \"UP\",\n  \"components\": {\n    \"db\": {\"status\": \"UP\"},\n    \"diskSpace\": {\"status\": \"UP\"},\n    \"custom\": {\"status\": \"UP\"}\n  }\n}\n```"
    },
    {
      "id": 74,
      "category": "CI/CD & Deployment",
      "question": "How do you configure environment-specific properties in Spring Boot?",
      "answer": "• Spring Boot supports multiple ways to configure environment-specific properties\n• Profile-based configuration:\n  - application.properties (default)\n  - application-dev.properties\n  - application-test.properties\n  - application-prod.properties\n• Activate profile:\n\n```properties\nspring.profiles.active=prod\n```\n\n• Via command line:\n\n```bash\njava -jar myapp.jar --spring.profiles.active=prod\n```\n\n• Via environment variable:\n\n```bash\nexport SPRING_PROFILES_ACTIVE=prod\n```\n\n• YAML configuration (application.yml):\n\n```yaml\nspring:\n  profiles:\n    active: dev\n---\nspring:\n  config:\n    activate:\n      on-profile: dev\n  datasource:\n    url: jdbc:mysql://localhost:3306/devdb\n---\nspring:\n  config:\n    activate:\n      on-profile: prod\n  datasource:\n    url: jdbc:mysql://prod-server:3306/proddb\n```\n\n• Using @Profile annotation:\n\n```java\n@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    @Bean\n    public DataSource dataSource() {\n        // Development datasource\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfig {\n    @Bean\n    public DataSource dataSource() {\n        // Production datasource\n    }\n}\n```\n\n• Property precedence (highest to lowest):\n  1. Command line arguments\n  2. Java system properties\n  3. OS environment variables\n  4. Profile-specific properties\n  5. Application properties\n  6. Default properties\n• External configuration:\n\n```bash\njava -jar myapp.jar --spring.config.location=file:/config/application.properties\n```\n\n• Using Spring Cloud Config for centralized configuration\n• Environment variables override:\n\n```bash\nexport DATABASE_URL=jdbc:mysql://prod:3306/db\njava -jar myapp.jar\n```\n\n• In application.properties:\n\n```properties\ndatabase.url=${DATABASE_URL:jdbc:mysql://localhost:3306/default}\n```\n\n• Docker environment variables:\n\n```yaml\nservices:\n  app:\n    environment:\n      - SPRING_PROFILES_ACTIVE=docker\n      - DATABASE_URL=jdbc:mysql://db:3306/mydb\n```"
    },
    {
      "id": 75,
      "category": "Bonus",
      "question": "How do you implement caching in Spring Boot?",
      "answer": "• Spring Boot provides easy caching abstraction with annotations\n• Add caching dependency:\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n```\n\n• Enable caching with @EnableCaching:\n\n```java\n@SpringBootApplication\n@EnableCaching\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n• Use caching annotations:\n  - @Cacheable: Cache method results\n  - @CachePut: Update cache\n  - @CacheEvict: Remove from cache\n  - @Caching: Combine multiple cache operations\n• Example implementation:\n\n```java\n@Service\npublic class UserService {\n    @Cacheable(value = \"users\", key = \"#id\")\n    public User getUserById(Long id) {\n        // This will be cached\n        return userRepository.findById(id).orElse(null);\n    }\n    \n    @CachePut(value = \"users\", key = \"#user.id\")\n    public User updateUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    @CacheEvict(value = \"users\", key = \"#id\")\n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n    \n    @CacheEvict(value = \"users\", allEntries = true)\n    public void clearCache() {\n        // Clear all cache entries\n    }\n}\n```\n\n• Cache providers:\n  - Simple (default, in-memory)\n  - EhCache\n  - Redis\n  - Caffeine\n  - Hazelcast\n• Redis cache configuration:\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n```properties\nspring.cache.type=redis\nspring.redis.host=localhost\nspring.redis.port=6379\n```\n\n• Custom cache configuration:\n\n```java\n@Configuration\npublic class CacheConfig {\n    @Bean\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager(\"users\", \"products\");\n    }\n}\n```\n\n• Conditional caching:\n\n```java\n@Cacheable(value = \"users\", key = \"#id\", condition = \"#id > 10\")\npublic User getUserById(Long id) {\n    return userRepository.findById(id).orElse(null);\n}\n```"
    },
    {
      "id": 76,
      "category": "Bonus",
      "question": "What is Spring Boot DevTools?",
      "answer": "• Spring Boot DevTools provides features to improve development experience\n• Add DevTools dependency:\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n```\n\n• Key features:\n  - Automatic restart when code changes\n  - LiveReload integration for browser refresh\n  - Configuration defaults optimized for development\n  - Remote debugging support\n  - H2 console auto-configuration\n• Automatic restart:\n  - Monitors classpath changes\n  - Restarts application automatically\n  - Faster than full restart (uses two classloaders)\n  - Triggered by saving files in IDE\n• LiveReload:\n  - Automatically refreshes browser\n  - Works with browser extension\n  - Monitors static resources\n• Configuration:\n\n```properties\n# Disable automatic restart\nspring.devtools.restart.enabled=false\n\n# Exclude specific paths from restart\nspring.devtools.restart.exclude=static/**,public/**\n\n# Enable LiveReload\nspring.devtools.livereload.enabled=true\n```\n\n• Remote development:\n  - Connect to remote Spring Boot application\n  - Debug and restart remotely\n  - Useful for cloud environments\n• Global settings (~/.config/spring-boot/spring-boot-devtools.properties):\n\n```properties\nspring.devtools.restart.trigger-file=.reloadtrigger\n```\n\n• Important notes:\n  - Automatically disabled in production (when packaged as JAR)\n  - Should not be included in production builds\n  - Uses restart classloader for faster restarts\n  - Property defaults differ from production (e.g., caching disabled)\n• Performance benefits:\n  - Faster development cycle\n  - No manual restart needed\n  - Quick feedback on changes"
    },
    {
      "id": 77,
      "category": "Bonus",
      "question": "How do you implement logging in Spring Boot?",
      "answer": "• Spring Boot uses Logback as the default logging framework\n• Logging is pre-configured, no additional setup needed\n• Use SLF4J API for logging:\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Service\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n    \n    public User getUser(Long id) {\n        logger.debug(\"Fetching user with id: {}\", id);\n        User user = userRepository.findById(id).orElse(null);\n        if (user == null) {\n            logger.warn(\"User not found with id: {}\", id);\n        } else {\n            logger.info(\"User found: {}\", user.getUsername());\n        }\n        return user;\n    }\n}\n```\n\n• Lombok @Slf4j annotation (shortcut):\n\n```java\n@Slf4j\n@Service\npublic class UserService {\n    public User getUser(Long id) {\n        log.info(\"Fetching user with id: {}\", id);\n        return userRepository.findById(id).orElse(null);\n    }\n}\n```\n\n• Configure logging levels in application.properties:\n\n```properties\n# Root level\nlogging.level.root=INFO\n\n# Package level\nlogging.level.com.myapp=DEBUG\nlogging.level.org.springframework.web=DEBUG\nlogging.level.org.hibernate.SQL=DEBUG\n\n# Log to file\nlogging.file.name=myapp.log\nlogging.file.path=/var/log\n\n# Log pattern\nlogging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n\nlogging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\n```\n\n• Logback configuration (logback-spring.xml):\n\n```xml\n<configuration>\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    \n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>logs/myapp.log</file>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>logs/myapp.%d{yyyy-MM-dd}.log</fileNamePattern>\n            <maxHistory>30</maxHistory>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    \n    <root level=\"INFO\">\n        <appender-ref ref=\"CONSOLE\" />\n        <appender-ref ref=\"FILE\" />\n    </root>\n</configuration>\n```\n\n• Log levels (from most to least verbose):\n  - TRACE: Very detailed information\n  - DEBUG: Debugging information\n  - INFO: Informational messages (default)\n  - WARN: Warning messages\n  - ERROR: Error messages\n• Profile-specific logging:\n\n```xml\n<springProfile name=\"dev\">\n    <root level=\"DEBUG\">\n        <appender-ref ref=\"CONSOLE\" />\n    </root>\n</springProfile>\n\n<springProfile name=\"prod\">\n    <root level=\"WARN\">\n        <appender-ref ref=\"FILE\" />\n    </root>\n</springProfile>\n```\n\n• Logging best practices:\n  - Use appropriate log levels\n  - Use parameterized logging (logger.info(\"User {}\", id))\n  - Don't log sensitive information\n  - Use structured logging for production\n  - Configure log rotation\n  - Use correlation IDs for distributed tracing"
    }
  ]
}

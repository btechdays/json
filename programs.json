{
  "java": [
    {
      "id": 1,
      "title": "Hello World",
      "code": "public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}",
      "output": "Hello, World!"
    },
    {
      "id": 2,
      "title": "Add Two Numbers",
      "code": "public class AddNumbers {\n    public static void main(String[] args) {\n        int a = 10, b = 20;\n        int sum = a + b;\n        System.out.println(\"Sum: \" + sum);\n    }\n}",
      "output": "Sum: 30"
    },
    {
      "id": 3,
      "title": "Check Even/Odd",
      "code": "public class EvenOdd {\n    public static void main(String[] args) {\n        int num = 15;\n        if (num % 2 == 0) {\n            System.out.println(num + \" is even\");\n        } else {\n            System.out.println(num + \" is odd\");\n        }\n    }\n}",
      "output": "15 is odd"
    },
    {
      "id": 4,
      "title": "Factorial of Number",
      "code": "public class Factorial {\n    public static void main(String[] args) {\n        int n = 5;\n        int fact = 1;\n        for (int i = 1; i <= n; i++) {\n            fact *= i;\n        }\n        System.out.println(\"Factorial of \" + n + \" is \" + fact);\n    }\n}",
      "output": "Factorial of 5 is 120"
    },
    {
      "id": 5,
      "title": "Prime Number Check",
      "code": "public class PrimeCheck {\n    public static void main(String[] args) {\n        int num = 17;\n        boolean isPrime = true;\n        \n        if (num <= 1) {\n            isPrime = false;\n        } else {\n            for (int i = 2; i <= Math.sqrt(num); i++) {\n                if (num % i == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n        }\n        \n        if (isPrime) {\n            System.out.println(num + \" is prime\");\n        } else {\n            System.out.println(num + \" is not prime\");\n        }\n    }\n}",
      "output": "17 is prime"
    },
    {
      "id": 6,
      "title": "Array Sum",
      "code": "public class ArraySum {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int sum = 0;\n        \n        for (int num : arr) {\n            sum += num;\n        }\n        \n        System.out.println(\"Array sum: \" + sum);\n    }\n}",
      "output": "Array sum: 15"
    },
    {
      "id": 7,
      "title": "Reverse String",
      "code": "public class ReverseString {\n    public static void main(String[] args) {\n        String str = \"Hello\";\n        String reversed = \"\";\n        \n        for (int i = str.length() - 1; i >= 0; i--) {\n            reversed += str.charAt(i);\n        }\n        \n        System.out.println(\"Original: \" + str);\n        System.out.println(\"Reversed: \" + reversed);\n    }\n}",
      "output": "Original: Hello\\nReversed: olleH"
    },
    {
      "id": 8,
      "title": "Fibonacci Series",
      "code": "public class Fibonacci {\n    public static void main(String[] args) {\n        int n = 10;\n        int a = 0, b = 1;\n        \n        System.out.print(\"Fibonacci series: \" + a + \" \" + b);\n        \n        for (int i = 2; i < n; i++) {\n            int next = a + b;\n            System.out.print(\" \" + next);\n            a = b;\n            b = next;\n        }\n    }\n}",
      "output": "Fibonacci series: 0 1 1 2 3 5 8 13 21 34"
    },
    {
      "id": 9,
      "title": "Largest in Array",
      "code": "public class LargestNumber {\n    public static void main(String[] args) {\n        int[] arr = {10, 5, 8, 20, 3};\n        int max = arr[0];\n        \n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        \n        System.out.println(\"Largest number: \" + max);\n    }\n}",
      "output": "Largest number: 20"
    },
    {
      "id": 10,
      "title": "Palindrome Check",
      "code": "public class PalindromeCheck {\n    public static void main(String[] args) {\n        String str = \"madam\";\n        String reversed = \"\";\n        \n        for (int i = str.length() - 1; i >= 0; i--) {\n            reversed += str.charAt(i);\n        }\n        \n        if (str.equals(reversed)) {\n            System.out.println(str + \" is a palindrome\");\n        } else {\n            System.out.println(str + \" is not a palindrome\");\n        }\n    }\n}",
      "output": "madam is a palindrome"
    }
  ],
  "c": [
    {
      "id": 1,
      "title": "Hello World",
      "code": "#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}",
      "output": "Hello, World!"
    },
    {
      "id": 2,
      "title": "Add Two Numbers",
      "code": "#include <stdio.h>\n\nint main() {\n    int a = 10, b = 20;\n    int sum = a + b;\n    printf(\"Sum: %d\\n\", sum);\n    return 0;\n}",
      "output": "Sum: 30"
    },
    {
      "id": 3,
      "title": "Check Even/Odd",
      "code": "#include <stdio.h>\n\nint main() {\n    int num = 15;\n    if (num % 2 == 0) {\n        printf(\"%d is even\\n\", num);\n    } else {\n        printf(\"%d is odd\\n\", num);\n    }\n    return 0;\n}",
      "output": "15 is odd"
    },
    {
      "id": 4,
      "title": "Factorial of Number",
      "code": "#include <stdio.h>\n\nint main() {\n    int n = 5;\n    int fact = 1;\n    \n    for (int i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    \n    printf(\"Factorial of %d is %d\\n\", n, fact);\n    return 0;\n}",
      "output": "Factorial of 5 is 120"
    },
    {
      "id": 5,
      "title": "Prime Number Check",
      "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int num = 17;\n    int isPrime = 1;\n    \n    if (num <= 1) {\n        isPrime = 0;\n    } else {\n        for (int i = 2; i <= sqrt(num); i++) {\n            if (num % i == 0) {\n                isPrime = 0;\n                break;\n            }\n        }\n    }\n    \n    if (isPrime) {\n        printf(\"%d is prime\\n\", num);\n    } else {\n        printf(\"%d is not prime\\n\", num);\n    }\n    \n    return 0;\n}",
      "output": "17 is prime"
    },
    {
      "id": 6,
      "title": "Array Sum",
      "code": "#include <stdio.h>\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = 5;\n    int sum = 0;\n    \n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n    \n    printf(\"Array sum: %d\\n\", sum);\n    return 0;\n}",
      "output": "Array sum: 15"
    },
    {
      "id": 7,
      "title": "Reverse String",
      "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Hello\";\n    int len = strlen(str);\n    \n    printf(\"Original: %s\\n\", str);\n    printf(\"Reversed: \");\n    \n    for (int i = len - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
      "output": "Original: Hello\\nReversed: olleH"
    },
    {
      "id": 8,
      "title": "Fibonacci Series",
      "code": "#include <stdio.h>\n\nint main() {\n    int n = 10;\n    int a = 0, b = 1;\n    \n    printf(\"Fibonacci series: %d %d\", a, b);\n    \n    for (int i = 2; i < n; i++) {\n        int next = a + b;\n        printf(\" %d\", next);\n        a = b;\n        b = next;\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
      "output": "Fibonacci series: 0 1 1 2 3 5 8 13 21 34"
    },
    {
      "id": 9,
      "title": "Largest in Array",
      "code": "#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 5, 8, 20, 3};\n    int n = 5;\n    int max = arr[0];\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    \n    printf(\"Largest number: %d\\n\", max);\n    return 0;\n}",
      "output": "Largest number: 20"
    },
    {
      "id": 10,
      "title": "Palindrome Check",
      "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"madam\";\n    int len = strlen(str);\n    int isPalindrome = 1;\n    \n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            isPalindrome = 0;\n            break;\n        }\n    }\n    \n    if (isPalindrome) {\n        printf(\"%s is a palindrome\\n\", str);\n    } else {\n        printf(\"%s is not a palindrome\\n\", str);\n    }\n    \n    return 0;\n}",
      "output": "madam is a palindrome"
    }
  ],
  "javascript": [
    {
      "id": 1,
      "title": "Hello World",
      "code": "console.log('Hello, World!');",
      "output": "Hello, World!"
    },
    {
      "id": 2,
      "title": "Variables and Data Types",
      "code": "// Different variable declarations\nlet name = 'John';\nconst age = 25;\nvar isActive = true;\n\n// Template literals\nconsole.log(`Name: ${name}, Age: ${age}, Active: ${isActive}`);\n\n// Type checking\nconsole.log(`Type of name: ${typeof name}`);\nconsole.log(`Type of age: ${typeof age}`);\nconsole.log(`Type of isActive: ${typeof isActive}`);",
      "output": "Name: John, Age: 25, Active: true\nType of name: string\nType of age: number\nType of isActive: boolean"
    },
    {
      "id": 3,
      "title": "Arrow Functions",
      "code": "// Traditional function\nfunction add(a, b) {\n    return a + b;\n}\n\n// Arrow function\nconst multiply = (a, b) => a * b;\n\n// Arrow function with single parameter\nconst square = x => x * x;\n\nconsole.log('Add:', add(5, 3));\nconsole.log('Multiply:', multiply(4, 6));\nconsole.log('Square:', square(7));",
      "output": "Add: 8\nMultiply: 24\nSquare: 49"
    },
    {
      "id": 4,
      "title": "Array Methods",
      "code": "const numbers = [1, 2, 3, 4, 5];\n\n// Map - transform each element\nconst doubled = numbers.map(n => n * 2);\nconsole.log('Doubled:', doubled);\n\n// Filter - select elements\nconst evens = numbers.filter(n => n % 2 === 0);\nconsole.log('Even numbers:', evens);\n\n// Reduce - accumulate value\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\nconsole.log('Sum:', sum);\n\n// Find - first matching element\nconst found = numbers.find(n => n > 3);\nconsole.log('First > 3:', found);",
      "output": "Doubled: [2, 4, 6, 8, 10]\nEven numbers: [2, 4]\nSum: 15\nFirst > 3: 4"
    },
    {
      "id": 5,
      "title": "Object Destructuring",
      "code": "// Object with nested properties\nconst person = {\n    name: 'Alice',\n    age: 30,\n    address: {\n        city: 'New York',\n        country: 'USA'\n    },\n    hobbies: ['reading', 'swimming']\n};\n\n// Basic destructuring\nconst { name, age } = person;\nconsole.log(`${name} is ${age} years old`);\n\n// Nested destructuring\nconst { address: { city, country } } = person;\nconsole.log(`Lives in ${city}, ${country}`);\n\n// Array destructuring\nconst [hobby1, hobby2] = person.hobbies;\nconsole.log(`Hobbies: ${hobby1} and ${hobby2}`);",
      "output": "Alice is 30 years old\nLives in New York, USA\nHobbies: reading and swimming"
    },
    {
      "id": 6,
      "title": "Promises and Async/Await",
      "code": "// Create a Promise\nconst fetchData = (success = true) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (success) {\n                resolve('Data fetched successfully!');\n            } else {\n                reject('Failed to fetch data');\n            }\n        }, 1000);\n    });\n};\n\n// Using async/await\nasync function getData() {\n    try {\n        const result = await fetchData(true);\n        console.log(result);\n        return result;\n    } catch (error) {\n        console.error(error);\n    }\n}\n\n// Call async function\ngetData();",
      "output": "Data fetched successfully!"
    },
    {
      "id": 7,
      "title": "Classes and Inheritance",
      "code": "// Base class\nclass Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    speak() {\n        console.log(`${this.name} makes a sound`);\n    }\n}\n\n// Derived class\nclass Dog extends Animal {\n    constructor(name, breed) {\n        super(name);\n        this.breed = breed;\n    }\n    \n    speak() {\n        console.log(`${this.name} barks`);\n    }\n    \n    getInfo() {\n        return `${this.name} is a ${this.breed}`;\n    }\n}\n\nconst dog = new Dog('Buddy', 'Golden Retriever');\ndog.speak();\nconsole.log(dog.getInfo());",
      "output": "Buddy barks\nBuddy is a Golden Retriever"
    },
    {
      "id": 8,
      "title": "Closures and Higher-Order Functions",
      "code": "// Closure example\nfunction createCounter() {\n    let count = 0;\n    return function() {\n        count++;\n        return count;\n    };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\nconsole.log('Counter 1:', counter1()); // 1\nconsole.log('Counter 1:', counter1()); // 2\nconsole.log('Counter 2:', counter2()); // 1\n\n// Higher-order function\nfunction multiplyBy(factor) {\n    return function(number) {\n        return number * factor;\n    };\n}\n\nconst double = multiplyBy(2);\nconst triple = multiplyBy(3);\n\nconsole.log('Double 5:', double(5));\nconsole.log('Triple 4:', triple(4));",
      "output": "Counter 1: 1\nCounter 1: 2\nCounter 2: 1\nDouble 5: 10\nTriple 4: 12"
    },
    {
      "id": 9,
      "title": "Set and Map Collections",
      "code": "// Set - unique values\nconst uniqueNumbers = new Set([1, 2, 2, 3, 3, 4]);\nconsole.log('Unique numbers:', Array.from(uniqueNumbers));\n\n// Set operations\nuniqueNumbers.add(5);\nuniqueNumbers.delete(1);\nconsole.log('After operations:', Array.from(uniqueNumbers));\n\n// Map - key-value pairs\nconst userRoles = new Map();\nuserRoles.set('john', 'admin');\nuserRoles.set('jane', 'user');\nuserRoles.set('bob', 'moderator');\n\nconsole.log('John\\'s role:', userRoles.get('john'));\nconsole.log('All roles:');\nfor (let [user, role] of userRoles) {\n    console.log(`  ${user}: ${role}`);\n}",
      "output": "Unique numbers: [1, 2, 3, 4]\nAfter operations: [2, 3, 4, 5]\nJohn's role: admin\nAll roles:\n  john: admin\n  jane: user\n  bob: moderator"
    },
    {
      "id": 10,
      "title": "Error Handling and Try-Catch",
      "code": "function divide(a, b) {\n    if (b === 0) {\n        throw new Error('Division by zero is not allowed');\n    }\n    return a / b;\n}\n\nfunction safeDivide(a, b) {\n    try {\n        const result = divide(a, b);\n        console.log(`${a} ÷ ${b} = ${result}`);\n        return result;\n    } catch (error) {\n        console.error('Error:', error.message);\n        return null;\n    } finally {\n        console.log('Division operation completed');\n    }\n}\n\n// Test cases\nsafeDivide(10, 2);\nsafeDivide(8, 0);\nsafeDivide(15, 3);",
      "output": "10 ÷ 2 = 5\nDivision operation completed\nError: Division by zero is not allowed\nDivision operation completed\n15 ÷ 3 = 5\nDivision operation completed"
    },
    {
      "id": 11,
      "title": "Regular Expressions",
      "code": "const text = 'Contact us at: john@example.com or call +1-234-567-8900';\n\n// Email regex\nconst emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/;\nconst email = text.match(emailRegex);\nconsole.log('Email found:', email ? email[0] : 'None');\n\n// Phone regex\nconst phoneRegex = /\\+?1?-?\\(?\\d{3}\\)?-?\\d{3}-?\\d{4}/;\nconst phone = text.match(phoneRegex);\nconsole.log('Phone found:', phone ? phone[0] : 'None');\n\n// Replace emails with [EMAIL]\nconst sanitized = text.replace(emailRegex, '[EMAIL]');\nconsole.log('Sanitized:', sanitized);",
      "output": "Email found: john@example.com\nPhone found: +1-234-567-8900\nSanitized: Contact us at: [EMAIL] or call +1-234-567-8900"
    },
    {
      "id": 12,
      "title": "Local Storage and JSON",
      "code": "// Object to store\nconst user = {\n    id: 123,\n    name: 'Sarah',\n    preferences: {\n        theme: 'dark',\n        language: 'en'\n    }\n};\n\n// Store in localStorage\ntry {\n    localStorage.setItem('user', JSON.stringify(user));\n    console.log('User data saved to localStorage');\n    \n    // Retrieve from localStorage\n    const storedUser = JSON.parse(localStorage.getItem('user'));\n    console.log('Retrieved user:', storedUser);\n    \n    // Modify and update\n    storedUser.preferences.theme = 'light';\n    localStorage.setItem('user', JSON.stringify(storedUser));\n    console.log('User preferences updated');\n    \n} catch (error) {\n    console.error('localStorage not available or JSON error:', error);\n}",
      "output": "User data saved to localStorage\nRetrieved user: {id: 123, name: 'Sarah', preferences: {theme: 'dark', language: 'en'}}\nUser preferences updated"
    },
    {
      "id": 13,
      "title": "Event Handling",
      "code": "// Simulate DOM event handling\nclass SimpleEventHandler {\n    constructor() {\n        this.events = {};\n    }\n    \n    addEventListener(event, callback) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n        this.events[event].push(callback);\n    }\n    \n    trigger(event, data) {\n        if (this.events[event]) {\n            this.events[event].forEach(callback => callback(data));\n        }\n    }\n}\n\nconst handler = new SimpleEventHandler();\n\n// Add event listeners\nhandler.addEventListener('click', (data) => {\n    console.log('Button clicked with data:', data);\n});\n\nhandler.addEventListener('hover', () => {\n    console.log('Mouse hover detected');\n});\n\n// Trigger events\nhandler.trigger('click', { x: 100, y: 200 });\nhandler.trigger('hover');",
      "output": "Button clicked with data: {x: 100, y: 200}\nMouse hover detected"
    },
    {
      "id": 14,
      "title": "Fetch API Simulation",
      "code": "// Simulate API calls with Promise\nfunction fetchUser(id) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (id > 0) {\n                resolve({\n                    id: id,\n                    name: 'User ' + id,\n                    email: `user${id}@example.com`,\n                    status: 'active'\n                });\n            } else {\n                reject(new Error('Invalid user ID'));\n            }\n        }, 1000);\n    });\n}\n\n// Using async/await\nasync function getUsers() {\n    try {\n        const user1 = await fetchUser(1);\n        const user2 = await fetchUser(2);\n        \n        console.log('User 1:', user1);\n        console.log('User 2:', user2);\n        \n        // Try invalid user\n        await fetchUser(-1);\n    } catch (error) {\n        console.log('Error:', error.message);\n    }\n}\n\ngetUsers();",
      "output": "User 1: {id: 1, name: 'User 1', email: 'user1@example.com', status: 'active'}\nUser 2: {id: 2, name: 'User 2', email: 'user2@example.com', status: 'active'}\nError: Invalid user ID"
    },
    {
      "id": 15,
      "title": "Array Sorting and Searching",
      "code": "const students = [\n    { name: 'Alice', grade: 92, age: 20 },\n    { name: 'Bob', grade: 85, age: 19 },\n    { name: 'Charlie', grade: 98, age: 21 },\n    { name: 'Diana', grade: 87, age: 20 }\n];\n\n// Sort by grade (descending)\nconst byGrade = [...students].sort((a, b) => b.grade - a.grade);\nconsole.log('Sorted by grade:');\nbyGrade.forEach(s => console.log(`${s.name}: ${s.grade}`));\n\n// Sort by name (alphabetical)\nconst byName = [...students].sort((a, b) => a.name.localeCompare(b.name));\nconsole.log('\\nSorted by name:');\nbyName.forEach(s => console.log(s.name));\n\n// Find student with highest grade\nconst topStudent = students.reduce((max, student) => \n    student.grade > max.grade ? student : max\n);\nconsole.log('\\nTop student:', topStudent.name);\n\n// Binary search simulation\nfunction binarySearch(arr, target) {\n    let left = 0, right = arr.length - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid].grade === target) return mid;\n        if (arr[mid].grade < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n\nconst sortedByGrade = [...students].sort((a, b) => a.grade - b.grade);\nconst found = binarySearch(sortedByGrade, 92);\nconsole.log('\\nBinary search result:', found !== -1 ? 'Found' : 'Not found');",
      "output": "Sorted by grade:\nCharlie: 98\nAlice: 92\nDiana: 87\nBob: 85\n\nSorted by name:\nAlice\nBob\nCharlie\nDiana\n\nTop student: Charlie\n\nBinary search result: Found"
    },
    {
      "id": 16,
      "title": "Object-Oriented Programming",
      "code": "// Abstract base class concept\nclass Shape {\n    constructor(name) {\n        if (this.constructor === Shape) {\n            throw new Error('Cannot instantiate abstract class');\n        }\n        this.name = name;\n    }\n    \n    // Abstract method\n    area() {\n        throw new Error('Must implement area method');\n    }\n    \n    display() {\n        console.log(`${this.name} - Area: ${this.area()}`);\n    }\n}\n\nclass Rectangle extends Shape {\n    constructor(width, height) {\n        super('Rectangle');\n        this.width = width;\n        this.height = height;\n    }\n    \n    area() {\n        return this.width * this.height;\n    }\n}\n\nclass Circle extends Shape {\n    constructor(radius) {\n        super('Circle');\n        this.radius = radius;\n    }\n    \n    area() {\n        return Math.PI * this.radius * this.radius;\n    }\n}\n\n// Usage\nconst rect = new Rectangle(5, 3);\nconst circle = new Circle(4);\n\nrect.display();\ncircle.display();\n\n// Static method example\nclass MathUtils {\n    static factorial(n) {\n        return n <= 1 ? 1 : n * this.factorial(n - 1);\n    }\n}\n\nconsole.log('Factorial of 5:', MathUtils.factorial(5));",
      "output": "Rectangle - Area: 15\nCircle - Area: 50.26548245743669\nFactorial of 5: 120"
    },
    {
      "id": 17,
      "title": "DOM Tree Simulation",
      "code": "// Simple DOM-like structure\nclass DOMNode {\n    constructor(tagName, attributes = {}) {\n        this.tagName = tagName;\n        this.attributes = attributes;\n        this.children = [];\n        this.textContent = '';\n    }\n    \n    appendChild(child) {\n        this.children.push(child);\n        child.parent = this;\n    }\n    \n    setAttribute(name, value) {\n        this.attributes[name] = value;\n    }\n    \n    getElementById(id) {\n        if (this.attributes.id === id) return this;\n        \n        for (let child of this.children) {\n            const found = child.getElementById(id);\n            if (found) return found;\n        }\n        return null;\n    }\n    \n    render(indent = 0) {\n        const spaces = ' '.repeat(indent);\n        let attrs = Object.entries(this.attributes)\n            .map(([k, v]) => `${k}=\"${v}\"`)\n            .join(' ');\n        \n        console.log(`${spaces}<${this.tagName}${attrs ? ' ' + attrs : ''}>${this.textContent}`);\n        \n        this.children.forEach(child => child.render(indent + 2));\n    }\n}\n\n// Create a simple DOM tree\nconst html = new DOMNode('html');\nconst head = new DOMNode('head');\nconst body = new DOMNode('body', { class: 'main' });\n\nconst title = new DOMNode('title');\ntitle.textContent = 'My Page';\nhead.appendChild(title);\n\nconst div = new DOMNode('div', { id: 'container', class: 'wrapper' });\nconst p = new DOMNode('p');\np.textContent = 'Hello World!';\n\ndiv.appendChild(p);\nbody.appendChild(div);\nhtml.appendChild(head);\nhtml.appendChild(body);\n\nconsole.log('DOM Tree:');\nhtml.render();\n\n// Test getElementById\nconst found = html.getElementById('container');\nconsole.log('\\nFound element:', found ? found.tagName : 'null');",
      "output": "DOM Tree:\n<html>\n  <head>\n    <title>My Page\n  <body class=\"main\">\n    <div id=\"container\" class=\"wrapper\">\n      <p>Hello World!\n\nFound element: div"
    },
    {
      "id": 18,
      "title": "Data Validation",
      "code": "// Validation utility class\nclass Validator {\n    static email(email) {\n        const pattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        return pattern.test(email);\n    }\n    \n    static phone(phone) {\n        const pattern = /^[\\+]?[1-9][\\d]{0,3}[\\s\\-]?\\(?[\\d]{3}\\)?[\\s\\-]?[\\d]{3}[\\s\\-]?[\\d]{4}$/;\n        return pattern.test(phone);\n    }\n    \n    static password(password) {\n        // At least 8 chars, 1 uppercase, 1 lowercase, 1 number\n        const pattern = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d@$!%*?&]{8,}$/;\n        return pattern.test(password);\n    }\n    \n    static creditCard(number) {\n        // Simple Luhn algorithm\n        const digits = number.replace(/\\s/g, '').split('').reverse();\n        let sum = 0;\n        \n        for (let i = 0; i < digits.length; i++) {\n            let digit = parseInt(digits[i]);\n            if (i % 2 === 1) {\n                digit *= 2;\n                if (digit > 9) digit -= 9;\n            }\n            sum += digit;\n        }\n        \n        return sum % 10 === 0;\n    }\n}\n\n// Test validation\nconst testData = {\n    emails: ['test@example.com', 'invalid.email', 'user@domain.co.uk'],\n    phones: ['+1-234-567-8900', '123-456-7890', '1234567890'],\n    passwords: ['SecurePass123', 'weak', 'StrongP@ss1'],\n    cards: ['4532015112830366', '1234567890123456', '4000000000000002']\n};\n\nconsole.log('Email Validation:');\ntestData.emails.forEach(email => {\n    console.log(`${email}: ${Validator.email(email) ? 'Valid' : 'Invalid'}`);\n});\n\nconsole.log('\\nPhone Validation:');\ntestData.phones.forEach(phone => {\n    console.log(`${phone}: ${Validator.phone(phone) ? 'Valid' : 'Invalid'}`);\n});\n\nconsole.log('\\nPassword Validation:');\ntestData.passwords.forEach(password => {\n    console.log(`${password}: ${Validator.password(password) ? 'Valid' : 'Invalid'}`);\n});\n\nconsole.log('\\nCredit Card Validation:');\ntestData.cards.forEach(card => {\n    console.log(`${card}: ${Validator.creditCard(card) ? 'Valid' : 'Invalid'}`);\n});",
      "output": "Email Validation:\ntest@example.com: Valid\ninvalid.email: Invalid\nuser@domain.co.uk: Valid\n\nPhone Validation:\n+1-234-567-8900: Valid\n123-456-7890: Valid\n1234567890: Invalid\n\nPassword Validation:\nSecurePass123: Valid\nweak: Invalid\nStrongP@ss1: Valid\n\nCredit Card Validation:\n4532015112830366: Valid\n1234567890123456: Invalid\n4000000000000002: Valid"
    },
    {
      "id": 19,
      "title": "Calculator with Memory",
      "code": "class Calculator {\n    constructor() {\n        this.current = 0;\n        this.memory = 0;\n        this.history = [];\n    }\n    \n    add(value) {\n        this.current += value;\n        this.history.push(`+ ${value} = ${this.current}`);\n        return this;\n    }\n    \n    subtract(value) {\n        this.current -= value;\n        this.history.push(`- ${value} = ${this.current}`);\n        return this;\n    }\n    \n    multiply(value) {\n        this.current *= value;\n        this.history.push(`* ${value} = ${this.current}`);\n        return this;\n    }\n    \n    divide(value) {\n        if (value === 0) {\n            throw new Error('Division by zero');\n        }\n        this.current /= value;\n        this.history.push(`/ ${value} = ${this.current}`);\n        return this;\n    }\n    \n    power(value) {\n        this.current = Math.pow(this.current, value);\n        this.history.push(`^ ${value} = ${this.current}`);\n        return this;\n    }\n    \n    sqrt() {\n        this.current = Math.sqrt(this.current);\n        this.history.push(`√ = ${this.current}`);\n        return this;\n    }\n    \n    memoryStore() {\n        this.memory = this.current;\n        this.history.push(`Memory stored: ${this.memory}`);\n        return this;\n    }\n    \n    memoryRecall() {\n        this.current = this.memory;\n        this.history.push(`Memory recalled: ${this.memory}`);\n        return this;\n    }\n    \n    memoryClear() {\n        this.memory = 0;\n        this.history.push('Memory cleared');\n        return this;\n    }\n    \n    clear() {\n        this.current = 0;\n        this.history.push('Calculator cleared');\n        return this;\n    }\n    \n    getResult() {\n        return this.current;\n    }\n    \n    getHistory() {\n        return this.history;\n    }\n    \n    showHistory() {\n        console.log('Calculation History:');\n        this.history.forEach((entry, index) => {\n            console.log(`${index + 1}. ${entry}`);\n        });\n    }\n}\n\n// Usage example\nconst calc = new Calculator();\n\ntry {\n    calc.add(10)\n        .multiply(5)\n        .subtract(20)\n        .memoryStore()\n        .divide(2)\n        .power(2)\n        .sqrt()\n        .memoryRecall()\n        .add(5);\n    \n    console.log('Final result:', calc.getResult());\n    calc.showHistory();\n    \n} catch (error) {\n    console.error('Calculator error:', error.message);\n}",
      "output": "Final result: 35\nCalculation History:\n1. + 10 = 10\n2. * 5 = 50\n3. - 20 = 30\n4. Memory stored: 30\n5. / 2 = 15\n6. ^ 2 = 225\n7. √ = 15\n8. Memory recalled: 30\n9. + 5 = 35"
    },
    {
      "id": 20,
      "title": "Simple State Management",
      "code": "// Simple Redux-like state management\nclass StateManager {\n    constructor(initialState = {}) {\n        this.state = { ...initialState };\n        this.listeners = [];\n        this.actionHistory = [];\n    }\n    \n    subscribe(listener) {\n        this.listeners.push(listener);\n        return () => {\n            this.listeners = this.listeners.filter(l => l !== listener);\n        };\n    }\n    \n    dispatch(action) {\n        console.log('Dispatching action:', action.type);\n        this.actionHistory.push(action);\n        \n        const newState = this.reducer(this.state, action);\n        if (newState !== this.state) {\n            this.state = newState;\n            this.listeners.forEach(listener => listener(this.state));\n        }\n    }\n    \n    getState() {\n        return { ...this.state };\n    }\n    \n    reducer(state, action) {\n        switch (action.type) {\n            case 'ADD_TODO':\n                return {\n                    ...state,\n                    todos: [...state.todos, {\n                        id: Date.now(),\n                        text: action.payload.text,\n                        completed: false\n                    }]\n                };\n                \n            case 'TOGGLE_TODO':\n                return {\n                    ...state,\n                    todos: state.todos.map(todo =>\n                        todo.id === action.payload.id\n                            ? { ...todo, completed: !todo.completed }\n                            : todo\n                    )\n                };\n                \n            case 'DELETE_TODO':\n                return {\n                    ...state,\n                    todos: state.todos.filter(todo => todo.id !== action.payload.id)\n                };\n                \n            default:\n                return state;\n        }\n    }\n}\n\n// Usage\nconst store = new StateManager({\n    todos: [],\n    user: { name: 'John' }\n});\n\n// Subscribe to state changes\nconst unsubscribe = store.subscribe((state) => {\n    console.log('State updated:', JSON.stringify(state, null, 2));\n});\n\n// Dispatch actions\nstore.dispatch({ type: 'ADD_TODO', payload: { text: 'Learn JavaScript' } });\nstore.dispatch({ type: 'ADD_TODO', payload: { text: 'Build a project' } });\n\nconst todoId = store.getState().todos[0].id;\nstore.dispatch({ type: 'TOGGLE_TODO', payload: { id: todoId } });\n\nconsole.log('\\nFinal state:');\nconsole.log(JSON.stringify(store.getState(), null, 2));",
      "output": "Dispatching action: ADD_TODO\nState updated: {\n  \"todos\": [\n    {\n      \"id\": 1640995200000,\n      \"text\": \"Learn JavaScript\",\n      \"completed\": false\n    }\n  ],\n  \"user\": {\n    \"name\": \"John\"\n  }\n}\nDispatching action: ADD_TODO\nState updated: {\n  \"todos\": [\n    {\n      \"id\": 1640995200000,\n      \"text\": \"Learn JavaScript\",\n      \"completed\": false\n    },\n    {\n      \"id\": 1640995200001,\n      \"text\": \"Build a project\",\n      \"completed\": false\n    }\n  ],\n  \"user\": {\n    \"name\": \"John\"\n  }\n}\nDispatching action: TOGGLE_TODO\nState updated: {\n  \"todos\": [\n    {\n      \"id\": 1640995200000,\n      \"text\": \"Learn JavaScript\",\n      \"completed\": true\n    },\n    {\n      \"id\": 1640995200001,\n      \"text\": \"Build a project\",\n      \"completed\": false\n    }\n  ],\n  \"user\": {\n    \"name\": \"John\"\n  }\n}\n\nFinal state:\n{\n  \"todos\": [\n    {\n      \"id\": 1640995200000,\n      \"text\": \"Learn JavaScript\",\n      \"completed\": true\n    },\n    {\n      \"id\": 1640995200001,\n      \"text\": \"Build a project\",\n      \"completed\": false\n    }\n  ],\n  \"user\": {\n    \"name\": \"John\"\n  }\n}"
    },
    {
      "id": 21,
      "title": "Advanced Array Flattening",
      "code": "// Deep array flattening with recursion\nfunction deepFlatten(arr) {\n    return arr.reduce((flat, item) => {\n        return flat.concat(Array.isArray(item) ? deepFlatten(item) : item);\n    }, []);\n}\n\n// Using built-in flat() method\nconst nestedArray = [1, [2, 3], [4, [5, 6]], [[7, 8], 9]];\n\nconsole.log('Original:', nestedArray);\nconsole.log('Deep flattened (custom):', deepFlatten(nestedArray));\nconsole.log('Flattened (Infinity):', nestedArray.flat(Infinity));\n\n// Flatten with specific depth\nconst partialFlat = nestedArray.flat(1);\nconsole.log('Flattened (depth 1):', partialFlat);\n\n// FlatMap example\nconst words = ['hello', 'world'];\nconst letters = words.flatMap(word => word.split(''));\nconsole.log('Letters from words:', letters);",
      "output": "Original: [1, [2, 3], [4, [5, 6]], [[7, 8], 9]]\nDeep flattened (custom): [1, 2, 3, 4, 5, 6, 7, 8, 9]\nFlattened (Infinity): [1, 2, 3, 4, 5, 6, 7, 8, 9]\nFlattened (depth 1): [1, 2, 3, 4, [5, 6], [7, 8], 9]\nLetters from words: ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']"
    },
    {
      "id": 22,
      "title": "String Template Engine",
      "code": "// Simple template engine with variable substitution\nclass TemplateEngine {\n    constructor() {\n        this.templates = new Map();\n    }\n    \n    // Register a template\n    register(name, template) {\n        this.templates.set(name, template);\n    }\n    \n    // Render template with data\n    render(name, data = {}) {\n        const template = this.templates.get(name);\n        if (!template) {\n            throw new Error(`Template '${name}' not found`);\n        }\n        \n        return template.replace(/{{\\s*(\\w+)\\s*}}/g, (match, key) => {\n            return data.hasOwnProperty(key) ? data[key] : match;\n        });\n    }\n    \n    // Render with conditionals and loops\n    renderAdvanced(template, data = {}) {\n        let result = template;\n        \n        // Handle conditionals: {{#if condition}}...{{/if}}\n        result = result.replace(/{{#if\\s+(\\w+)}}([\\s\\S]*?){{\/if}}/g, (match, condition, content) => {\n            return data[condition] ? content : '';\n        });\n        \n        // Handle loops: {{#each items}}...{{/each}}\n        result = result.replace(/{{#each\\s+(\\w+)}}([\\s\\S]*?){{\/each}}/g, (match, arrayName, content) => {\n            const array = data[arrayName] || [];\n            return array.map(item => {\n                return content.replace(/{{this}}/g, item)\n                             .replace(/{{@index}}/g, array.indexOf(item));\n            }).join('');\n        });\n        \n        // Handle simple variables\n        result = result.replace(/{{\\s*(\\w+)\\s*}}/g, (match, key) => {\n            return data.hasOwnProperty(key) ? data[key] : match;\n        });\n        \n        return result;\n    }\n}\n\n// Usage examples\nconst engine = new TemplateEngine();\n\n// Simple template\nengine.register('greeting', 'Hello, {{name}}! You have {{count}} messages.');\nconsole.log(engine.render('greeting', { name: 'Alice', count: 5 }));\n\n// Advanced template with conditionals and loops\nconst advancedTemplate = `\nWelcome {{name}}!\n{{#if isAdmin}}You are an administrator.{{/if}}\n\nYour tasks:\n{{#each tasks}}- {{this}} (item #{{@index}})\n{{/each}}\n`;\n\nconst data = {\n    name: 'Bob',\n    isAdmin: true,\n    tasks: ['Review code', 'Deploy application', 'Update documentation']\n};\n\nconsole.log(engine.renderAdvanced(advancedTemplate, data));",
      "output": "Hello, Alice! You have 5 messages.\n\nWelcome Bob!\nYou are an administrator.\n\nYour tasks:\n- Review code (item #0)\n- Deploy application (item #1)\n- Update documentation (item #2)"
    },
    {
      "id": 23,
      "title": "Date and Time Utilities",
      "code": "// Comprehensive date and time utility functions\nclass DateUtils {\n    // Format date in various formats\n    static formatDate(date, format = 'YYYY-MM-DD') {\n        const d = new Date(date);\n        const formats = {\n            YYYY: d.getFullYear(),\n            MM: String(d.getMonth() + 1).padStart(2, '0'),\n            DD: String(d.getDate()).padStart(2, '0'),\n            HH: String(d.getHours()).padStart(2, '0'),\n            mm: String(d.getMinutes()).padStart(2, '0'),\n            ss: String(d.getSeconds()).padStart(2, '0')\n        };\n        \n        return format.replace(/YYYY|MM|DD|HH|mm|ss/g, match => formats[match]);\n    }\n    \n    // Calculate age from birthdate\n    static calculateAge(birthDate) {\n        const today = new Date();\n        const birth = new Date(birthDate);\n        let age = today.getFullYear() - birth.getFullYear();\n        const monthDiff = today.getMonth() - birth.getMonth();\n        \n        if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {\n            age--;\n        }\n        \n        return age;\n    }\n    \n    // Get time difference between two dates\n    static timeDifference(date1, date2) {\n        const diff = Math.abs(new Date(date2) - new Date(date1));\n        \n        const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));\n        const seconds = Math.floor((diff % (1000 * 60)) / 1000);\n        \n        return { days, hours, minutes, seconds };\n    }\n    \n    // Check if date is weekend\n    static isWeekend(date) {\n        const day = new Date(date).getDay();\n        return day === 0 || day === 6; // Sunday = 0, Saturday = 6\n    }\n    \n    // Add/subtract time from date\n    static addTime(date, amount, unit) {\n        const result = new Date(date);\n        \n        switch (unit) {\n            case 'days':\n                result.setDate(result.getDate() + amount);\n                break;\n            case 'months':\n                result.setMonth(result.getMonth() + amount);\n                break;\n            case 'years':\n                result.setFullYear(result.getFullYear() + amount);\n                break;\n            case 'hours':\n                result.setHours(result.getHours() + amount);\n                break;\n            case 'minutes':\n                result.setMinutes(result.getMinutes() + amount);\n                break;\n        }\n        \n        return result;\n    }\n    \n    // Get timezone offset in hours\n    static getTimezoneOffset() {\n        return new Date().getTimezoneOffset() / -60;\n    }\n}\n\n// Usage examples\nconst now = new Date();\nconsole.log('Current date:', DateUtils.formatDate(now, 'YYYY-MM-DD HH:mm:ss'));\nconsole.log('Age from 1990-05-15:', DateUtils.calculateAge('1990-05-15'));\n\nconst date1 = '2024-01-01';\nconst date2 = '2024-03-15';\nconst diff = DateUtils.timeDifference(date1, date2);\nconsole.log(`Time difference: ${diff.days} days, ${diff.hours} hours`);\n\nconsole.log('Is today weekend?', DateUtils.isWeekend(now));\n\nconst futureDate = DateUtils.addTime(now, 30, 'days');\nconsole.log('30 days from now:', DateUtils.formatDate(futureDate));\n\nconsole.log('Timezone offset:', DateUtils.getTimezoneOffset(), 'hours');\n\n// Relative time formatting\nfunction getRelativeTime(date) {\n    const now = new Date();\n    const diff = now - new Date(date);\n    const seconds = Math.floor(diff / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    \n    if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;\n    if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;\n    if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;\n    return 'Just now';\n}\n\nconst pastDate = new Date(Date.now() - 2 * 60 * 60 * 1000); // 2 hours ago\nconsole.log('Relative time:', getRelativeTime(pastDate));",
      "output": "Current date: 2024-12-18 14:30:45\nAge from 1990-05-15: 34\nTime difference: 74 days, 0 hours\nIs today weekend? false\n30 days from now: 2025-01-17\nTimezone offset: -8 hours\nRelative time: 2 hours ago"
    },
    {
      "id": 24,
      "title": "Advanced Math Operations",
      "code": "// Advanced mathematical operations and utilities\nclass MathUtils {\n    // Calculate factorial using recursion\n    static factorial(n) {\n        if (n < 0) throw new Error('Factorial undefined for negative numbers');\n        if (n === 0 || n === 1) return 1;\n        return n * this.factorial(n - 1);\n    }\n    \n    // Calculate Greatest Common Divisor (GCD)\n    static gcd(a, b) {\n        return b === 0 ? Math.abs(a) : this.gcd(b, a % b);\n    }\n    \n    // Calculate Least Common Multiple (LCM)\n    static lcm(a, b) {\n        return Math.abs(a * b) / this.gcd(a, b);\n    }\n    \n    // Check if number is prime\n    static isPrime(n) {\n        if (n < 2) return false;\n        if (n === 2) return true;\n        if (n % 2 === 0) return false;\n        \n        for (let i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i === 0) return false;\n        }\n        return true;\n    }\n    \n    // Generate Fibonacci sequence\n    static fibonacci(n) {\n        if (n <= 0) return [];\n        if (n === 1) return [0];\n        \n        const fib = [0, 1];\n        for (let i = 2; i < n; i++) {\n            fib[i] = fib[i - 1] + fib[i - 2];\n        }\n        return fib;\n    }\n    \n    // Calculate statistics for array\n    static statistics(numbers) {\n        if (numbers.length === 0) return null;\n        \n        const sorted = [...numbers].sort((a, b) => a - b);\n        const sum = numbers.reduce((acc, num) => acc + num, 0);\n        const mean = sum / numbers.length;\n        \n        // Median\n        const mid = Math.floor(numbers.length / 2);\n        const median = numbers.length % 2 === 0 \n            ? (sorted[mid - 1] + sorted[mid]) / 2 \n            : sorted[mid];\n        \n        // Mode\n        const frequency = {};\n        numbers.forEach(num => frequency[num] = (frequency[num] || 0) + 1);\n        const maxFreq = Math.max(...Object.values(frequency));\n        const mode = Object.keys(frequency).filter(key => frequency[key] === maxFreq).map(Number);\n        \n        // Standard deviation\n        const variance = numbers.reduce((acc, num) => acc + Math.pow(num - mean, 2), 0) / numbers.length;\n        const stdDev = Math.sqrt(variance);\n        \n        return {\n            mean: Math.round(mean * 100) / 100,\n            median,\n            mode: mode.length === numbers.length ? null : mode,\n            min: Math.min(...numbers),\n            max: Math.max(...numbers),\n            range: Math.max(...numbers) - Math.min(...numbers),\n            variance: Math.round(variance * 100) / 100,\n            stdDev: Math.round(stdDev * 100) / 100\n        };\n    }\n    \n    // Convert between number bases\n    static convertBase(number, fromBase, toBase) {\n        if (fromBase === toBase) return number.toString();\n        \n        // Convert to decimal first\n        const decimal = fromBase === 10 ? number : parseInt(number, fromBase);\n        \n        // Convert from decimal to target base\n        if (toBase === 10) return decimal.toString();\n        return decimal.toString(toBase);\n    }\n    \n    // Calculate compound interest\n    static compoundInterest(principal, rate, time, compound = 1) {\n        const amount = principal * Math.pow(1 + rate / compound, compound * time);\n        const interest = amount - principal;\n        \n        return {\n            principal,\n            rate: rate * 100,\n            time,\n            compound,\n            amount: Math.round(amount * 100) / 100,\n            interest: Math.round(interest * 100) / 100\n        };\n    }\n}\n\n// Usage examples\nconsole.log('Factorial of 6:', MathUtils.factorial(6));\nconsole.log('GCD of 48 and 18:', MathUtils.gcd(48, 18));\nconsole.log('LCM of 12 and 18:', MathUtils.lcm(12, 18));\nconsole.log('Is 17 prime?', MathUtils.isPrime(17));\nconsole.log('First 10 Fibonacci numbers:', MathUtils.fibonacci(10));\n\nconst numbers = [1, 2, 2, 3, 4, 4, 4, 5];\nconst stats = MathUtils.statistics(numbers);\nconsole.log('Statistics for [1,2,2,3,4,4,4,5]:');\nconsole.log(`Mean: ${stats.mean}, Median: ${stats.median}, Mode: ${stats.mode}`);\nconsole.log(`Range: ${stats.range}, Std Dev: ${stats.stdDev}`);\n\nconsole.log('255 in binary:', MathUtils.convertBase('255', 10, 2));\nconsole.log('1010 binary to decimal:', MathUtils.convertBase('1010', 2, 10));\n\nconst investment = MathUtils.compoundInterest(1000, 0.05, 3, 4);\nconsole.log(`Investment: $${investment.principal} at ${investment.rate}% for ${investment.time} years`);\nconsole.log(`Final amount: $${investment.amount}, Interest: $${investment.interest}`);",
      "output": "Factorial of 6: 720\nGCD of 48 and 18: 6\nLCM of 12 and 18: 36\nIs 17 prime? true\nFirst 10 Fibonacci numbers: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nStatistics for [1,2,2,3,4,4,4,5]:\nMean: 3.13, Median: 3.5, Mode: [4]\nRange: 4, Std Dev: 1.36\n255 in binary: 11111111\n1010 binary to decimal: 10\nInvestment: $1000 at 5% for 3 years\nFinal amount: $1160.75, Interest: $160.75"
    },
    {
      "id": 25,
      "title": "File System Simulation",
      "code": "// Virtual file system simulation\nclass VirtualFileSystem {\n    constructor() {\n        this.root = {\n            type: 'directory',\n            name: '/',\n            children: {},\n            parent: null,\n            created: new Date(),\n            modified: new Date()\n        };\n        this.currentDirectory = this.root;\n    }\n    \n    // Navigate to directory\n    cd(path) {\n        if (path === '/') {\n            this.currentDirectory = this.root;\n            return true;\n        }\n        \n        if (path === '..') {\n            if (this.currentDirectory.parent) {\n                this.currentDirectory = this.currentDirectory.parent;\n            }\n            return true;\n        }\n        \n        const target = this.currentDirectory.children[path];\n        if (target && target.type === 'directory') {\n            this.currentDirectory = target;\n            return true;\n        }\n        \n        throw new Error(`Directory '${path}' not found`);\n    }\n    \n    // Create directory\n    mkdir(name) {\n        if (this.currentDirectory.children[name]) {\n            throw new Error(`'${name}' already exists`);\n        }\n        \n        this.currentDirectory.children[name] = {\n            type: 'directory',\n            name,\n            children: {},\n            parent: this.currentDirectory,\n            created: new Date(),\n            modified: new Date()\n        };\n    }\n    \n    // Create file with content\n    touch(name, content = '') {\n        this.currentDirectory.children[name] = {\n            type: 'file',\n            name,\n            content,\n            size: content.length,\n            parent: this.currentDirectory,\n            created: new Date(),\n            modified: new Date()\n        };\n    }\n    \n    // List directory contents\n    ls() {\n        const items = Object.values(this.currentDirectory.children);\n        return items.map(item => ({\n            name: item.name,\n            type: item.type,\n            size: item.size || 0,\n            modified: item.modified.toISOString().split('T')[0]\n        }));\n    }\n    \n    // Read file content\n    cat(filename) {\n        const file = this.currentDirectory.children[filename];\n        if (!file) {\n            throw new Error(`File '${filename}' not found`);\n        }\n        if (file.type !== 'file') {\n            throw new Error(`'${filename}' is not a file`);\n        }\n        return file.content;\n    }\n    \n    // Write to file\n    echo(content, filename) {\n        if (this.currentDirectory.children[filename]) {\n            this.currentDirectory.children[filename].content = content;\n            this.currentDirectory.children[filename].size = content.length;\n            this.currentDirectory.children[filename].modified = new Date();\n        } else {\n            this.touch(filename, content);\n        }\n    }\n    \n    // Remove file or directory\n    rm(name) {\n        if (!this.currentDirectory.children[name]) {\n            throw new Error(`'${name}' not found`);\n        }\n        delete this.currentDirectory.children[name];\n    }\n    \n    // Get current path\n    pwd() {\n        let path = '';\n        let current = this.currentDirectory;\n        \n        while (current && current.parent) {\n            path = '/' + current.name + path;\n            current = current.parent;\n        }\n        \n        return path || '/';\n    }\n    \n    // Find files by name pattern\n    find(pattern) {\n        const results = [];\n        \n        const search = (dir, currentPath) => {\n            Object.values(dir.children).forEach(item => {\n                const fullPath = currentPath + '/' + item.name;\n                if (item.name.includes(pattern)) {\n                    results.push({\n                        path: fullPath,\n                        type: item.type\n                    });\n                }\n                if (item.type === 'directory') {\n                    search(item, fullPath);\n                }\n            });\n        };\n        \n        search(this.root, '');\n        return results;\n    }\n}\n\n// Usage demonstration\nconst fs = new VirtualFileSystem();\n\ntry {\n    console.log('Current directory:', fs.pwd());\n    \n    // Create directory structure\n    fs.mkdir('documents');\n    fs.mkdir('projects');\n    fs.touch('readme.txt', 'Welcome to the virtual file system!');\n    \n    console.log('Root contents:');\n    console.table(fs.ls());\n    \n    // Navigate and create more files\n    fs.cd('documents');\n    fs.touch('letter.txt', 'Dear friend, how are you?');\n    fs.mkdir('personal');\n    \n    console.log('\\nDocuments directory:');\n    console.table(fs.ls());\n    \n    console.log('Current path:', fs.pwd());\n    \n    // Read file content\n    console.log('\\nContent of letter.txt:');\n    console.log(fs.cat('letter.txt'));\n    \n    // Go back to root and search\n    fs.cd('/');\n    console.log('\\nSearching for files containing \"txt\":');\n    const found = fs.find('txt');\n    console.table(found);\n    \n    // Create nested structure\n    fs.cd('projects');\n    fs.mkdir('web-app');\n    fs.cd('web-app');\n    fs.touch('index.html', '<html><body>Hello World</body></html>');\n    fs.touch('style.css', 'body { margin: 0; }');\n    \n    console.log('\\nWeb-app directory:');\n    console.table(fs.ls());\n    console.log('Current path:', fs.pwd());\n    \n} catch (error) {\n    console.error('File system error:', error.message);\n}",
      "output": "Current directory: /\nRoot contents:\n┌─────────┬─────────────┬─────────────┬──────┬────────────┐\n│ (index) │    name     │    type     │ size │  modified  │\n├─────────┼─────────────┼─────────────┼──────┼────────────┤\n│    0    │ 'documents' │ 'directory' │  0   │ '2024-12-18'│\n│    1    │ 'projects'  │ 'directory' │  0   │ '2024-12-18'│\n│    2    │ 'readme.txt'│   'file'    │  36  │ '2024-12-18'│\n└─────────┴─────────────┴─────────────┴──────┴────────────┘\n\nDocuments directory:\n┌─────────┬─────────────┬─────────────┬──────┬────────────┐\n│ (index) │    name     │    type     │ size │  modified  │\n├─────────┼─────────────┼─────────────┼──────┼────────────┤\n│    0    │ 'letter.txt'│   'file'    │  25  │ '2024-12-18'│\n│    1    │ 'personal'  │ 'directory' │  0   │ '2024-12-18'│\n└─────────┴─────────────┴─────────────┴──────┴────────────┘\nCurrent path: /documents\n\nContent of letter.txt:\nDear friend, how are you?\n\nSearching for files containing \"txt\":\n┌─────────┬─────────────────────┬─────────┐\n│ (index) │        path         │  type   │\n├─────────┼─────────────────────┼─────────┤\n│    0    │   '/readme.txt'     │ 'file'  │\n│    1    │ '/documents/letter.txt' │ 'file' │\n└─────────┴─────────────────────┴─────────┘\n\nWeb-app directory:\n┌─────────┬──────────────┬─────────┬──────┬────────────┐\n│ (index) │     name     │  type   │ size │  modified  │\n├─────────┼──────────────┼─────────┼──────┼────────────┤\n│    0    │ 'index.html' │ 'file'  │  38  │ '2024-12-18'│\n│    1    │ 'style.css'  │ 'file'  │  17  │ '2024-12-18'│\n└─────────┴──────────────┴─────────┴──────┴────────────┘\nCurrent path: /projects/web-app"
    },
    {
      "id": 26,
      "title": "REST API Client Simulation",
      "code": "// Simulated REST API client with caching and error handling\nclass APIClient {\n    constructor(baseURL = 'https://api.example.com') {\n        this.baseURL = baseURL;\n        this.cache = new Map();\n        this.interceptors = {\n            request: [],\n            response: []\n        };\n    }\n    \n    // Add request interceptor\n    addRequestInterceptor(interceptor) {\n        this.interceptors.request.push(interceptor);\n    }\n    \n    // Add response interceptor\n    addResponseInterceptor(interceptor) {\n        this.interceptors.response.push(interceptor);\n    }\n    \n    // Simulate HTTP request\n    async request(method, endpoint, data = null, options = {}) {\n        const config = {\n            method: method.toUpperCase(),\n            url: `${this.baseURL}${endpoint}`,\n            data,\n            headers: { 'Content-Type': 'application/json', ...options.headers },\n            cache: options.cache || false\n        };\n        \n        // Apply request interceptors\n        let finalConfig = config;\n        for (const interceptor of this.interceptors.request) {\n            finalConfig = interceptor(finalConfig);\n        }\n        \n        // Check cache for GET requests\n        const cacheKey = `${method}:${endpoint}`;\n        if (method.toUpperCase() === 'GET' && finalConfig.cache && this.cache.has(cacheKey)) {\n            console.log('Cache hit for:', cacheKey);\n            return this.cache.get(cacheKey);\n        }\n        \n        // Simulate network delay\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000));\n        \n        // Simulate API response\n        let response = await this.simulateResponse(finalConfig);\n        \n        // Apply response interceptors\n        for (const interceptor of this.interceptors.response) {\n            response = interceptor(response);\n        }\n        \n        // Cache GET responses\n        if (method.toUpperCase() === 'GET' && finalConfig.cache) {\n            this.cache.set(cacheKey, response);\n        }\n        \n        return response;\n    }\n    \n    // Simulate different API responses\n    async simulateResponse(config) {\n        const { method, url, data } = config;\n        \n        // Simulate different endpoints\n        if (url.includes('/users')) {\n            if (method === 'GET') {\n                return {\n                    status: 200,\n                    data: [\n                        { id: 1, name: 'John Doe', email: 'john@example.com' },\n                        { id: 2, name: 'Jane Smith', email: 'jane@example.com' }\n                    ]\n                };\n            } else if (method === 'POST') {\n                return {\n                    status: 201,\n                    data: { id: 3, ...data, created: new Date().toISOString() }\n                };\n            }\n        }\n        \n        if (url.includes('/posts')) {\n            if (method === 'GET') {\n                return {\n                    status: 200,\n                    data: [\n                        { id: 1, title: 'First Post', content: 'Hello World!' },\n                        { id: 2, title: 'Second Post', content: 'Learning JavaScript' }\n                    ]\n                };\n            }\n        }\n        \n        // Simulate error for certain endpoints\n        if (url.includes('/error')) {\n            throw new Error('API Error: Resource not found');\n        }\n        \n        // Default response\n        return {\n            status: 200,\n            data: { message: 'Success', timestamp: new Date().toISOString() }\n        };\n    }\n    \n    // Convenience methods\n    get(endpoint, options) {\n        return this.request('GET', endpoint, null, options);\n    }\n    \n    post(endpoint, data, options) {\n        return this.request('POST', endpoint, data, options);\n    }\n    \n    put(endpoint, data, options) {\n        return this.request('PUT', endpoint, data, options);\n    }\n    \n    delete(endpoint, options) {\n        return this.request('DELETE', endpoint, null, options);\n    }\n}\n\n// Usage example\nasync function demonstrateAPIClient() {\n    const api = new APIClient('https://jsonplaceholder.typicode.com');\n    \n    // Add request interceptor for authentication\n    api.addRequestInterceptor((config) => {\n        console.log('Request interceptor: Adding auth header');\n        config.headers['Authorization'] = 'Bearer fake-token';\n        return config;\n    });\n    \n    // Add response interceptor for logging\n    api.addResponseInterceptor((response) => {\n        console.log('Response interceptor: Status', response.status);\n        return response;\n    });\n    \n    try {\n        // GET request with caching\n        console.log('=== Fetching Users (cached) ===');\n        const users1 = await api.get('/users', { cache: true });\n        console.log('Users:', users1.data);\n        \n        // Second request should hit cache\n        const users2 = await api.get('/users', { cache: true });\n        console.log('Users (cached):', users2.data);\n        \n        // POST request\n        console.log('\\n=== Creating User ===');\n        const newUser = await api.post('/users', {\n            name: 'New User',\n            email: 'newuser@example.com'\n        });\n        console.log('Created user:', newUser.data);\n        \n        // GET posts\n        console.log('\\n=== Fetching Posts ===');\n        const posts = await api.get('/posts');\n        console.log('Posts:', posts.data);\n        \n    } catch (error) {\n        console.error('API Error:', error.message);\n    }\n}\n\n// Run demonstration\ndemonstrate APIClient();",
      "output": "=== Fetching Users (cached) ===\nRequest interceptor: Adding auth header\nResponse interceptor: Status 200\nUsers: [{id: 1, name: 'John Doe', email: 'john@example.com'}, {id: 2, name: 'Jane Smith', email: 'jane@example.com'}]\nCache hit for: GET:/users\nUsers (cached): [{id: 1, name: 'John Doe', email: 'john@example.com'}, {id: 2, name: 'Jane Smith', email: 'jane@example.com'}]\n\n=== Creating User ===\nRequest interceptor: Adding auth header\nResponse interceptor: Status 201\nCreated user: {id: 3, name: 'New User', email: 'newuser@example.com', created: '2024-12-18T22:30:45.123Z'}\n\n=== Fetching Posts ===\nRequest interceptor: Adding auth header\nResponse interceptor: Status 200\nPosts: [{id: 1, title: 'First Post', content: 'Hello World!'}, {id: 2, title: 'Second Post', content: 'Learning JavaScript'}]"
    },
    {
      "id": 27,
      "title": "Observer Pattern Implementation",
      "code": "// Observer pattern with event system\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n        this.maxListeners = 10;\n    }\n    \n    // Add event listener\n    on(event, listener) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n        \n        if (this.events[event].length >= this.maxListeners) {\n            console.warn(`Warning: Event '${event}' has ${this.events[event].length} listeners`);\n        }\n        \n        this.events[event].push(listener);\n        return this; // For chaining\n    }\n    \n    // Add one-time event listener\n    once(event, listener) {\n        const onceWrapper = (...args) => {\n            listener.apply(this, args);\n            this.off(event, onceWrapper);\n        };\n        return this.on(event, onceWrapper);\n    }\n    \n    // Remove event listener\n    off(event, listenerToRemove) {\n        if (!this.events[event]) return this;\n        \n        this.events[event] = this.events[event].filter(listener => \n            listener !== listenerToRemove\n        );\n        \n        return this;\n    }\n    \n    // Emit event\n    emit(event, ...args) {\n        if (!this.events[event]) return false;\n        \n        this.events[event].forEach(listener => {\n            try {\n                listener.apply(this, args);\n            } catch (error) {\n                console.error(`Error in event listener for '${event}':`, error);\n            }\n        });\n        \n        return true;\n    }\n    \n    // Remove all listeners for event\n    removeAllListeners(event) {\n        if (event) {\n            delete this.events[event];\n        } else {\n            this.events = {};\n        }\n        return this;\n    }\n    \n    // Get listener count\n    listenerCount(event) {\n        return this.events[event] ? this.events[event].length : 0;\n    }\n    \n    // List all events\n    eventNames() {\n        return Object.keys(this.events);\n    }\n}\n\n// Subject-Observer pattern example\nclass Subject extends EventEmitter {\n    constructor(name) {\n        super();\n        this.name = name;\n        this.state = {};\n    }\n    \n    setState(key, value) {\n        const oldValue = this.state[key];\n        this.state[key] = value;\n        \n        // Emit specific property change\n        this.emit('change', { key, value, oldValue });\n        this.emit(`change:${key}`, value, oldValue);\n        \n        // Emit general state change\n        this.emit('stateChange', this.state);\n    }\n    \n    getState() {\n        return { ...this.state };\n    }\n}\n\nclass Observer {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    observe(subject) {\n        subject.on('change', (data) => {\n            console.log(`${this.name} observed change in ${subject.name}: ${data.key} = ${data.value}`);\n        });\n        \n        subject.on('stateChange', (state) => {\n            console.log(`${this.name} received state update:`, state);\n        });\n    }\n    \n    observeSpecific(subject, property) {\n        subject.on(`change:${property}`, (newValue, oldValue) => {\n            console.log(`${this.name} observed ${property} changed: ${oldValue} -> ${newValue}`);\n        });\n    }\n}\n\n// Usage example\nconsole.log('=== Observer Pattern Demo ===');\n\n// Create subject and observers\nconst userModel = new Subject('UserModel');\nconst uiObserver = new Observer('UIObserver');\nconst loggerObserver = new Observer('LoggerObserver');\n\n// Set up observers\nuiObserver.observe(userModel);\nloggerObserver.observeSpecific(userModel, 'email');\n\n// Test the pattern\nconst emailListener = (email) => console.log(`Email notification sent to: ${email}`);\nuserModel.on('change:email', emailListener);\n\n// Make changes\nconsole.log('\\nSetting user name...');\nuserModel.setState('name', 'John Doe');\n\nconsole.log('\\nSetting user email...');\nuserModel.setState('email', 'john@example.com');\n\nconsole.log('\\nUpdating email...');\nuserModel.setState('email', 'john.doe@example.com');\n\nconsole.log('\\nSetting user age...');\nuserModel.setState('age', 30);\n\nconsole.log('\\nEvent statistics:');\nconsole.log('Events registered:', userModel.eventNames());\nconsole.log('Change listeners:', userModel.listenerCount('change'));\nconsole.log('Email change listeners:', userModel.listenerCount('change:email'));\n\n// Demonstrate once listener\nconsole.log('\\n=== Once Listener Demo ===');\nuserModel.once('change:status', (status) => {\n    console.log(`One-time status update: ${status}`);\n});\n\nuserModel.setState('status', 'active');\nuserModel.setState('status', 'inactive'); // This won't trigger the once listener\n\n// Error handling demo\nconsole.log('\\n=== Error Handling Demo ===');\nuserModel.on('error-test', () => {\n    throw new Error('Simulated listener error');\n});\n\nuserModel.emit('error-test');\nconsole.log('Application continues after listener error');",
      "output": "=== Observer Pattern Demo ===\n\nSetting user name...\nUIObserver observed change in UserModel: name = John Doe\nUIObserver received state update: {name: 'John Doe'}\n\nSetting user email...\nUIObserver observed change in UserModel: email = john@example.com\nLoggerObserver observed email changed: undefined -> john@example.com\nEmail notification sent to: john@example.com\nUIObserver received state update: {name: 'John Doe', email: 'john@example.com'}\n\nUpdating email...\nUIObserver observed change in UserModel: email = john.doe@example.com\nLoggerObserver observed email changed: john@example.com -> john.doe@example.com\nEmail notification sent to: john.doe@example.com\nUIObserver received state update: {name: 'John Doe', email: 'john.doe@example.com'}\n\nSetting user age...\nUIObserver observed change in UserModel: age = 30\nUIObserver received state update: {name: 'John Doe', email: 'john.doe@example.com', age: 30}\n\nEvent statistics:\nEvents registered: ['change', 'change:email', 'stateChange', 'change:name', 'change:age']\nChange listeners: 1\nEmail change listeners: 2\n\n=== Once Listener Demo ===\nOne-time status update: active\n\n=== Error Handling Demo ===\nError in event listener for 'error-test': Error: Simulated listener error\nApplication continues after listener error"
    },
    {
      "id": 28,
      "title": "Binary Search Tree Implementation",
      "code": "// Binary Search Tree with various operations\nclass TreeNode {\n    constructor(value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass BinarySearchTree {\n    constructor() {\n        this.root = null;\n        this.size = 0;\n    }\n    \n    // Insert a value\n    insert(value) {\n        const newNode = new TreeNode(value);\n        \n        if (!this.root) {\n            this.root = newNode;\n        } else {\n            this.insertNode(this.root, newNode);\n        }\n        this.size++;\n    }\n    \n    insertNode(node, newNode) {\n        if (newNode.value < node.value) {\n            if (!node.left) {\n                node.left = newNode;\n            } else {\n                this.insertNode(node.left, newNode);\n            }\n        } else {\n            if (!node.right) {\n                node.right = newNode;\n            } else {\n                this.insertNode(node.right, newNode);\n            }\n        }\n    }\n    \n    // Search for a value\n    search(value) {\n        return this.searchNode(this.root, value);\n    }\n    \n    searchNode(node, value) {\n        if (!node) return false;\n        \n        if (value === node.value) return true;\n        if (value < node.value) return this.searchNode(node.left, value);\n        return this.searchNode(node.right, value);\n    }\n    \n    // In-order traversal (sorted order)\n    inOrder() {\n        const result = [];\n        this.inOrderTraversal(this.root, result);\n        return result;\n    }\n    \n    inOrderTraversal(node, result) {\n        if (node) {\n            this.inOrderTraversal(node.left, result);\n            result.push(node.value);\n            this.inOrderTraversal(node.right, result);\n        }\n    }\n    \n    // Pre-order traversal\n    preOrder() {\n        const result = [];\n        this.preOrderTraversal(this.root, result);\n        return result;\n    }\n    \n    preOrderTraversal(node, result) {\n        if (node) {\n            result.push(node.value);\n            this.preOrderTraversal(node.left, result);\n            this.preOrderTraversal(node.right, result);\n        }\n    }\n    \n    // Post-order traversal\n    postOrder() {\n        const result = [];\n        this.postOrderTraversal(this.root, result);\n        return result;\n    }\n    \n    postOrderTraversal(node, result) {\n        if (node) {\n            this.postOrderTraversal(node.left, result);\n            this.postOrderTraversal(node.right, result);\n            result.push(node.value);\n        }\n    }\n    \n    // Find minimum value\n    findMin() {\n        let node = this.root;\n        while (node && node.left) {\n            node = node.left;\n        }\n        return node ? node.value : null;\n    }\n    \n    // Find maximum value\n    findMax() {\n        let node = this.root;\n        while (node && node.right) {\n            node = node.right;\n        }\n        return node ? node.value : null;\n    }\n    \n    // Get height of tree\n    height() {\n        return this.getHeight(this.root);\n    }\n    \n    getHeight(node) {\n        if (!node) return -1;\n        return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));\n    }\n    \n    // Check if tree is balanced\n    isBalanced() {\n        return this.checkBalance(this.root) !== -1;\n    }\n    \n    checkBalance(node) {\n        if (!node) return 0;\n        \n        const leftHeight = this.checkBalance(node.left);\n        if (leftHeight === -1) return -1;\n        \n        const rightHeight = this.checkBalance(node.right);\n        if (rightHeight === -1) return -1;\n        \n        if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n        \n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n    \n    // Level-order traversal (breadth-first)\n    levelOrder() {\n        if (!this.root) return [];\n        \n        const result = [];\n        const queue = [this.root];\n        \n        while (queue.length > 0) {\n            const node = queue.shift();\n            result.push(node.value);\n            \n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        \n        return result;\n    }\n    \n    // Delete a value\n    delete(value) {\n        this.root = this.deleteNode(this.root, value);\n        this.size--;\n    }\n    \n    deleteNode(node, value) {\n        if (!node) return null;\n        \n        if (value < node.value) {\n            node.left = this.deleteNode(node.left, value);\n        } else if (value > node.value) {\n            node.right = this.deleteNode(node.right, value);\n        } else {\n            // Node to be deleted found\n            \n            // Case 1: No children\n            if (!node.left && !node.right) {\n                return null;\n            }\n            \n            // Case 2: One child\n            if (!node.left) return node.right;\n            if (!node.right) return node.left;\n            \n            // Case 3: Two children\n            // Find the in-order successor (smallest in right subtree)\n            let successor = node.right;\n            while (successor.left) {\n                successor = successor.left;\n            }\n            \n            // Replace value with successor's value\n            node.value = successor.value;\n            \n            // Delete the successor\n            node.right = this.deleteNode(node.right, successor.value);\n        }\n        \n        return node;\n    }\n    \n    // Visualize tree structure\n    display() {\n        if (!this.root) {\n            console.log('Tree is empty');\n            return;\n        }\n        \n        this.displayTree(this.root, '', true);\n    }\n    \n    displayTree(node, prefix, isLast) {\n        if (node) {\n            console.log(prefix + (isLast ? '└── ' : '├── ') + node.value);\n            \n            const children = [node.left, node.right].filter(child => child !== null);\n            children.forEach((child, index) => {\n                const isLastChild = index === children.length - 1;\n                const newPrefix = prefix + (isLast ? '    ' : '│   ');\n                this.displayTree(child, newPrefix, isLastChild);\n            });\n        }\n    }\n}\n\n// Usage example\nconst bst = new BinarySearchTree();\n\n// Insert values\nconst values = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 65];\nconsole.log('Inserting values:', values.join(', '));\nvalues.forEach(val => bst.insert(val));\n\nconsole.log('\\nTree structure:');\nbst.display();\n\nconsole.log('\\nTree statistics:');\nconsole.log('Size:', bst.size);\nconsole.log('Height:', bst.height());\nconsole.log('Minimum:', bst.findMin());\nconsole.log('Maximum:', bst.findMax());\nconsole.log('Is balanced:', bst.isBalanced());\n\nconsole.log('\\nTraversals:');\nconsole.log('In-order (sorted):', bst.inOrder());\nconsole.log('Pre-order:', bst.preOrder());\nconsole.log('Post-order:', bst.postOrder());\nconsole.log('Level-order:', bst.levelOrder());\n\nconsole.log('\\nSearch operations:');\nconsole.log('Search 40:', bst.search(40));\nconsole.log('Search 90:', bst.search(90));\n\n// Delete operations\nconsole.log('\\nDeleting node 30...');\nbst.delete(30);\nconsole.log('In-order after deletion:', bst.inOrder());\n\nconsole.log('\\nTree after deletion:');\nbst.display();",
      "output": "Inserting values: 50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 65\n\nTree structure:\n└── 50\n    ├── 30\n    │   ├── 20\n    │   │   ├── 10\n    │   │   └── 25\n    │   └── 40\n    │       └── 35\n    └── 70\n        ├── 60\n        │   └── 65\n        └── 80\n\nTree statistics:\nSize: 11\nHeight: 3\nMinimum: 10\nMaximum: 80\nIs balanced: true\n\nTraversals:\nIn-order (sorted): [10, 20, 25, 30, 35, 40, 50, 60, 65, 70, 80]\nPre-order: [50, 30, 20, 10, 25, 40, 35, 70, 60, 65, 80]\nPost-order: [10, 25, 20, 35, 40, 30, 65, 60, 80, 70, 50]\nLevel-order: [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 65]\n\nSearch operations:\nSearch 40: true\nSearch 90: false\n\nDeleting node 30...\nIn-order after deletion: [10, 20, 25, 35, 40, 50, 60, 65, 70, 80]\n\nTree after deletion:\n└── 50\n    ├── 35\n    │   ├── 20\n    │   │   ├── 10\n    │   │   └── 25\n    │   └── 40\n    └── 70\n        ├── 60\n        │   └── 65\n        └── 80"
    },
    {
      "id": 29,
      "title": "Form Validation Framework",
      "code": "// Comprehensive form validation framework\nclass Validator {\n    constructor() {\n        this.rules = {\n            required: (value) => value !== null && value !== undefined && value !== '',\n            email: (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value),\n            phone: (value) => /^[\\+]?[0-9\\s\\-\\(\\)]{10,}$/.test(value),\n            url: (value) => /^https?:\\/\\/.+/.test(value),\n            minLength: (min) => (value) => value && value.length >= min,\n            maxLength: (max) => (value) => value && value.length <= max,\n            min: (min) => (value) => Number(value) >= min,\n            max: (max) => (value) => Number(value) <= max,\n            pattern: (regex) => (value) => regex.test(value),\n            custom: (fn) => fn,\n            match: (field) => (value, formData) => value === formData[field]\n        };\n        \n        this.messages = {\n            required: 'This field is required',\n            email: 'Please enter a valid email address',\n            phone: 'Please enter a valid phone number',\n            url: 'Please enter a valid URL',\n            minLength: (min) => `Minimum length is ${min} characters`,\n            maxLength: (max) => `Maximum length is ${max} characters`,\n            min: (min) => `Minimum value is ${min}`,\n            max: (max) => `Maximum value is ${max}`,\n            pattern: 'Please enter a valid format',\n            match: (field) => `Must match ${field}`\n        };\n    }\n    \n    // Add custom rule\n    addRule(name, validator, message) {\n        this.rules[name] = validator;\n        this.messages[name] = message;\n    }\n    \n    // Validate single field\n    validateField(value, rules, formData = {}) {\n        const errors = [];\n        \n        for (const rule of rules) {\n            let ruleName, ruleParams, validator;\n            \n            if (typeof rule === 'string') {\n                ruleName = rule;\n                validator = this.rules[ruleName];\n            } else if (typeof rule === 'object') {\n                ruleName = Object.keys(rule)[0];\n                ruleParams = rule[ruleName];\n                validator = typeof this.rules[ruleName] === 'function' \n                    ? this.rules[ruleName](ruleParams) \n                    : this.rules[ruleName];\n            }\n            \n            if (!validator) continue;\n            \n            let isValid;\n            if (ruleName === 'match') {\n                isValid = validator(value, formData);\n            } else {\n                isValid = validator(value);\n            }\n            \n            if (!isValid) {\n                const message = typeof this.messages[ruleName] === 'function'\n                    ? this.messages[ruleName](ruleParams)\n                    : this.messages[ruleName];\n                errors.push(message);\n            }\n        }\n        \n        return errors;\n    }\n    \n    // Validate entire form\n    validateForm(formData, schema) {\n        const errors = {};\n        let isValid = true;\n        \n        for (const [field, rules] of Object.entries(schema)) {\n            const fieldErrors = this.validateField(formData[field], rules, formData);\n            \n            if (fieldErrors.length > 0) {\n                errors[field] = fieldErrors;\n                isValid = false;\n            }\n        }\n        \n        return { isValid, errors };\n    }\n}\n\n// Form class with real-time validation\nclass Form {\n    constructor(schema, validator = new Validator()) {\n        this.schema = schema;\n        this.validator = validator;\n        this.data = {};\n        this.errors = {};\n        this.touched = {};\n    }\n    \n    // Set field value\n    setField(name, value) {\n        this.data[name] = value;\n        this.touched[name] = true;\n        \n        // Validate field in real-time if it has been touched\n        if (this.schema[name]) {\n            const fieldErrors = this.validator.validateField(value, this.schema[name], this.data);\n            \n            if (fieldErrors.length > 0) {\n                this.errors[name] = fieldErrors;\n            } else {\n                delete this.errors[name];\n            }\n        }\n    }\n    \n    // Get field value\n    getField(name) {\n        return this.data[name] || '';\n    }\n    \n    // Get field errors\n    getFieldErrors(name) {\n        return this.errors[name] || [];\n    }\n    \n    // Check if field has errors\n    hasFieldError(name) {\n        return this.errors[name] && this.errors[name].length > 0;\n    }\n    \n    // Validate entire form\n    validate() {\n        const result = this.validator.validateForm(this.data, this.schema);\n        this.errors = result.errors;\n        \n        // Mark all fields as touched\n        Object.keys(this.schema).forEach(field => {\n            this.touched[field] = true;\n        });\n        \n        return result.isValid;\n    }\n    \n    // Reset form\n    reset() {\n        this.data = {};\n        this.errors = {};\n        this.touched = {};\n    }\n    \n    // Get form data\n    getData() {\n        return { ...this.data };\n    }\n    \n    // Get all errors\n    getAllErrors() {\n        return { ...this.errors };\n    }\n    \n    // Check if form is valid\n    isValid() {\n        return Object.keys(this.errors).length === 0;\n    }\n}\n\n// Usage example\nconsole.log('=== Form Validation Demo ===');\n\n// Create validator with custom rules\nconst validator = new Validator();\n\n// Add custom password strength rule\nvalidator.addRule('strongPassword', (value) => {\n    const hasUpper = /[A-Z]/.test(value);\n    const hasLower = /[a-z]/.test(value);\n    const hasNumber = /\\d/.test(value);\n    const hasSpecial = /[!@#$%^&*(),.?\":{}|<>]/.test(value);\n    return hasUpper && hasLower && hasNumber && hasSpecial;\n}, 'Password must contain uppercase, lowercase, number and special character');\n\n// Define form schema\nconst registrationSchema = {\n    name: ['required', { minLength: 2 }],\n    email: ['required', 'email'],\n    phone: ['required', 'phone'],\n    age: ['required', { min: 18 }, { max: 120 }],\n    password: ['required', { minLength: 8 }, 'strongPassword'],\n    confirmPassword: ['required', { match: 'password' }],\n    website: ['url'],\n    bio: [{ maxLength: 500 }]\n};\n\n// Create form instance\nconst form = new Form(registrationSchema, validator);\n\n// Test form validation\nconsole.log('\\n=== Testing Form Validation ===');\n\n// Fill form with invalid data\nform.setField('name', 'A'); // Too short\nform.setField('email', 'invalid-email'); // Invalid email\nform.setField('phone', '123'); // Invalid phone\nform.setField('age', '15'); // Too young\nform.setField('password', 'weak'); // Weak password\nform.setField('confirmPassword', 'different'); // Doesn't match\nform.setField('website', 'not-a-url'); // Invalid URL\nform.setField('bio', 'A'.repeat(600)); // Too long\n\nconsole.log('Form data:', form.getData());\nconsole.log('Is form valid?', form.isValid());\nconsole.log('\\nField errors:');\nObject.keys(registrationSchema).forEach(field => {\n    const errors = form.getFieldErrors(field);\n    if (errors.length > 0) {\n        console.log(`${field}: ${errors.join(', ')}`);\n    }\n});\n\n// Fix the data\nconsole.log('\\n=== Fixing Form Data ===');\nform.setField('name', 'John Doe');\nform.setField('email', 'john@example.com');\nform.setField('phone', '+1-234-567-8900');\nform.setField('age', '25');\nform.setField('password', 'StrongP@ss123');\nform.setField('confirmPassword', 'StrongP@ss123');\nform.setField('website', 'https://johndoe.com');\nform.setField('bio', 'Software developer with 5 years of experience.');\n\nconsole.log('Form validation result:', form.validate());\nconsole.log('Is form valid?', form.isValid());\nif (form.isValid()) {\n    console.log('✓ Form is ready for submission!');\n    console.log('Final form data:', form.getData());\n}",
      "output": "=== Form Validation Demo ===\n\n=== Testing Form Validation ===\nForm data: {name: 'A', email: 'invalid-email', phone: '123', age: '15', password: 'weak', confirmPassword: 'different', website: 'not-a-url', bio: 'AAAAAAAAAAAA...'}\nIs form valid? false\n\nField errors:\nname: Minimum length is 2 characters\nemail: Please enter a valid email address\nphone: Please enter a valid phone number\nage: Minimum value is 18\npassword: Minimum length is 8 characters, Password must contain uppercase, lowercase, number and special character\nconfirmPassword: Must match password\nwebsite: Please enter a valid URL\nbio: Maximum length is 500 characters\n\n=== Fixing Form Data ===\nForm validation result: true\nIs form valid? true\n✓ Form is ready for submission!\nFinal form data: {name: 'John Doe', email: 'john@example.com', phone: '+1-234-567-8900', age: '25', password: 'StrongP@ss123', confirmPassword: 'StrongP@ss123', website: 'https://johndoe.com', bio: 'Software developer with 5 years of experience.'}"
    },
    {
      "id": 30,
      "title": "Image Processing Simulation",
      "code": "// Image processing simulation with filters and transformations\nclass ImageProcessor {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.pixels = this.createEmptyImage();\n        this.history = [];\n    }\n    \n    // Create empty image\n    createEmptyImage() {\n        const pixels = [];\n        for (let y = 0; y < this.height; y++) {\n            pixels[y] = [];\n            for (let x = 0; x < this.width; x++) {\n                pixels[y][x] = { r: 0, g: 0, b: 0, a: 255 };\n            }\n        }\n        return pixels;\n    }\n    \n    // Generate test pattern\n    generateTestPattern() {\n        this.saveState('Generate Test Pattern');\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                // Create a colorful gradient pattern\n                const r = Math.floor((x / this.width) * 255);\n                const g = Math.floor((y / this.height) * 255);\n                const b = Math.floor(((x + y) / (this.width + this.height)) * 255);\n                \n                this.pixels[y][x] = { r, g, b, a: 255 };\n            }\n        }\n    }\n    \n    // Apply grayscale filter\n    grayscale() {\n        this.saveState('Grayscale Filter');\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const pixel = this.pixels[y][x];\n                const gray = Math.floor(0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b);\n                this.pixels[y][x] = { r: gray, g: gray, b: gray, a: pixel.a };\n            }\n        }\n    }\n    \n    // Apply sepia filter\n    sepia() {\n        this.saveState('Sepia Filter');\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const pixel = this.pixels[y][x];\n                const r = Math.min(255, (pixel.r * 0.393) + (pixel.g * 0.769) + (pixel.b * 0.189));\n                const g = Math.min(255, (pixel.r * 0.349) + (pixel.g * 0.686) + (pixel.b * 0.168));\n                const b = Math.min(255, (pixel.r * 0.272) + (pixel.g * 0.534) + (pixel.b * 0.131));\n                \n                this.pixels[y][x] = { r: Math.floor(r), g: Math.floor(g), b: Math.floor(b), a: pixel.a };\n            }\n        }\n    }\n    \n    // Adjust brightness\n    brightness(factor) {\n        this.saveState(`Brightness ${factor > 0 ? '+' : ''}${Math.round(factor * 100)}%`);\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const pixel = this.pixels[y][x];\n                this.pixels[y][x] = {\n                    r: Math.max(0, Math.min(255, pixel.r + (pixel.r * factor))),\n                    g: Math.max(0, Math.min(255, pixel.g + (pixel.g * factor))),\n                    b: Math.max(0, Math.min(255, pixel.b + (pixel.b * factor))),\n                    a: pixel.a\n                };\n            }\n        }\n    }\n    \n    // Adjust contrast\n    contrast(factor) {\n        this.saveState(`Contrast ${Math.round(factor * 100)}%`);\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const pixel = this.pixels[y][x];\n                this.pixels[y][x] = {\n                    r: Math.max(0, Math.min(255, ((pixel.r - 128) * factor) + 128)),\n                    g: Math.max(0, Math.min(255, ((pixel.g - 128) * factor) + 128)),\n                    b: Math.max(0, Math.min(255, ((pixel.b - 128) * factor) + 128)),\n                    a: pixel.a\n                };\n            }\n        }\n    }\n    \n    // Apply blur filter (box blur)\n    blur(radius = 1) {\n        this.saveState(`Blur (radius: ${radius})`);\n        \n        const newPixels = this.createEmptyImage();\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                let totalR = 0, totalG = 0, totalB = 0, count = 0;\n                \n                for (let dy = -radius; dy <= radius; dy++) {\n                    for (let dx = -radius; dx <= radius; dx++) {\n                        const ny = y + dy;\n                        const nx = x + dx;\n                        \n                        if (ny >= 0 && ny < this.height && nx >= 0 && nx < this.width) {\n                            const pixel = this.pixels[ny][nx];\n                            totalR += pixel.r;\n                            totalG += pixel.g;\n                            totalB += pixel.b;\n                            count++;\n                        }\n                    }\n                }\n                \n                newPixels[y][x] = {\n                    r: Math.floor(totalR / count),\n                    g: Math.floor(totalG / count),\n                    b: Math.floor(totalB / count),\n                    a: this.pixels[y][x].a\n                };\n            }\n        }\n        \n        this.pixels = newPixels;\n    }\n    \n    // Apply edge detection\n    edgeDetection() {\n        this.saveState('Edge Detection');\n        \n        const newPixels = this.createEmptyImage();\n        \n        // Sobel edge detection kernel\n        const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];\n        const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];\n        \n        for (let y = 1; y < this.height - 1; y++) {\n            for (let x = 1; x < this.width - 1; x++) {\n                let gx = 0, gy = 0;\n                \n                for (let ky = 0; ky < 3; ky++) {\n                    for (let kx = 0; kx < 3; kx++) {\n                        const pixel = this.pixels[y + ky - 1][x + kx - 1];\n                        const gray = 0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b;\n                        \n                        gx += gray * sobelX[ky][kx];\n                        gy += gray * sobelY[ky][kx];\n                    }\n                }\n                \n                const magnitude = Math.sqrt(gx * gx + gy * gy);\n                const value = Math.min(255, Math.max(0, magnitude));\n                \n                newPixels[y][x] = { r: value, g: value, b: value, a: 255 };\n            }\n        }\n        \n        this.pixels = newPixels;\n    }\n    \n    // Invert colors\n    invert() {\n        this.saveState('Invert Colors');\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const pixel = this.pixels[y][x];\n                this.pixels[y][x] = {\n                    r: 255 - pixel.r,\n                    g: 255 - pixel.g,\n                    b: 255 - pixel.b,\n                    a: pixel.a\n                };\n            }\n        }\n    }\n    \n    // Get image statistics\n    getStatistics() {\n        let totalR = 0, totalG = 0, totalB = 0;\n        let minR = 255, maxR = 0;\n        let minG = 255, maxG = 0;\n        let minB = 255, maxB = 0;\n        \n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const pixel = this.pixels[y][x];\n                \n                totalR += pixel.r;\n                totalG += pixel.g;\n                totalB += pixel.b;\n                \n                minR = Math.min(minR, pixel.r);\n                maxR = Math.max(maxR, pixel.r);\n                minG = Math.min(minG, pixel.g);\n                maxG = Math.max(maxG, pixel.g);\n                minB = Math.min(minB, pixel.b);\n                maxB = Math.max(maxB, pixel.b);\n            }\n        }\n        \n        const totalPixels = this.width * this.height;\n        \n        return {\n            dimensions: { width: this.width, height: this.height },\n            totalPixels,\n            averageColor: {\n                r: Math.floor(totalR / totalPixels),\n                g: Math.floor(totalG / totalPixels),\n                b: Math.floor(totalB / totalPixels)\n            },\n            colorRange: {\n                r: { min: minR, max: maxR },\n                g: { min: minG, max: maxG },\n                b: { min: minB, max: maxB }\n            }\n        };\n    }\n    \n    // Save current state to history\n    saveState(operation) {\n        this.history.push({\n            operation,\n            timestamp: new Date().toISOString()\n        });\n    }\n    \n    // Get processing history\n    getHistory() {\n        return [...this.history];\n    }\n    \n    // Export image data as ASCII art (simplified)\n    exportAscii(chars = ' .:-=+*#%@') {\n        let ascii = '';\n        \n        for (let y = 0; y < this.height; y += 2) { // Skip every other row for aspect ratio\n            for (let x = 0; x < this.width; x++) {\n                const pixel = this.pixels[y][x];\n                const brightness = (pixel.r + pixel.g + pixel.b) / 3;\n                const charIndex = Math.floor((brightness / 255) * (chars.length - 1));\n                ascii += chars[charIndex];\n            }\n            ascii += '\\n';\n        }\n        \n        return ascii;\n    }\n}\n\n// Usage example\nconsole.log('=== Image Processing Demo ===');\n\n// Create a 20x10 image\nconst img = new ImageProcessor(20, 10);\n\n// Generate test pattern\nimg.generateTestPattern();\nconsole.log('\\nOriginal Image Statistics:');\nconsole.log(img.getStatistics());\n\n// Apply various filters\nconsole.log('\\n=== Applying Filters ===');\nimg.brightness(0.2); // Increase brightness by 20%\nimg.contrast(1.5); // Increase contrast by 50%\nimg.sepia();\n\nconsole.log('\\nAfter Sepia Filter:');\nconsole.log(img.getStatistics());\n\n// Show processing history\nconsole.log('\\nProcessing History:');\nimg.getHistory().forEach((entry, index) => {\n    console.log(`${index + 1}. ${entry.operation} at ${entry.timestamp.split('T')[1].split('.')[0]}`);\n});\n\n// Convert to grayscale and apply edge detection\nimg.grayscale();\nimg.edgeDetection();\n\nconsole.log('\\nFinal Processing Steps:');\nconst recentHistory = img.getHistory().slice(-3);\nrecentHistory.forEach((entry, index) => {\n    console.log(`${index + 1}. ${entry.operation}`);\n});\n\nconsole.log('\\nFinal Image Statistics:');\nconsole.log(img.getStatistics());\n\n// Export as ASCII (simplified version)\nconsole.log('\\nASCII Art Preview (10x5 sample):');\nconst smallImg = new ImageProcessor(10, 5);\nsmallImg.generateTestPattern();\nsmallImg.grayscale();\nconsole.log(smallImg.exportAscii());",
      "output": "=== Image Processing Demo ===\n\nOriginal Image Statistics:\n{\n  dimensions: { width: 20, height: 10 },\n  totalPixels: 200,\n  averageColor: { r: 127, g: 127, b: 127 },\n  colorRange: {\n    r: { min: 0, max: 255 },\n    g: { min: 0, max: 255 },\n    b: { min: 0, max: 255 }\n  }\n}\n\n=== Applying Filters ===\n\nAfter Sepia Filter:\n{\n  dimensions: { width: 20, height: 10 },\n  totalPixels: 200,\n  averageColor: { r: 196, g: 175, b: 136 },\n  colorRange: {\n    r: { min: 0, max: 255 },\n    g: { min: 0, max: 255 },\n    b: { min: 0, max: 255 }\n  }\n}\n\nProcessing History:\n1. Generate Test Pattern at 14:30:45\n2. Brightness +20% at 14:30:45\n3. Contrast 150% at 14:30:45\n4. Sepia Filter at 14:30:45\n\nFinal Processing Steps:\n1. Sepia Filter\n2. Grayscale Filter\n3. Edge Detection\n\nFinal Image Statistics:\n{\n  dimensions: { width: 20, height: 10 },\n  totalPixels: 200,\n  averageColor: { r: 45, g: 45, b: 45 },\n  colorRange: {\n    r: { min: 0, max: 255 },\n    g: { min: 0, max: 255 },\n    b: { min: 0, max: 255 }\n  }\n}\n\nASCII Art Preview (10x5 sample):\n .:-=+*#%@\n .:-=+*#%@\n .:-=+*#%@"
    },
    {
      "id": 31,
      "title": "Game Logic - Tic Tac Toe",
      "code": "// Complete Tic Tac Toe game implementation\nclass TicTacToe {\n    constructor() {\n        this.board = Array(3).fill().map(() => Array(3).fill(' '));\n        this.currentPlayer = 'X';\n        this.gameOver = false;\n        this.winner = null;\n        this.moves = 0;\n    }\n    \n    // Display the board\n    displayBoard() {\n        console.log('\\n   0   1   2');\n        for (let i = 0; i < 3; i++) {\n            console.log(`${i}  ${this.board[i].join(' | ')}`);\n            if (i < 2) console.log('  ---|---|---');\n        }\n        console.log('');\n    }\n    \n    // Make a move\n    makeMove(row, col) {\n        if (this.gameOver) {\n            console.log('Game is over!');\n            return false;\n        }\n        \n        if (row < 0 || row > 2 || col < 0 || col > 2) {\n            console.log('Invalid position!');\n            return false;\n        }\n        \n        if (this.board[row][col] !== ' ') {\n            console.log('Position already taken!');\n            return false;\n        }\n        \n        this.board[row][col] = this.currentPlayer;\n        this.moves++;\n        \n        if (this.checkWinner()) {\n            this.winner = this.currentPlayer;\n            this.gameOver = true;\n            console.log(`Player ${this.currentPlayer} wins!`);\n        } else if (this.moves === 9) {\n            this.gameOver = true;\n            console.log('It\\'s a tie!');\n        } else {\n            this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';\n        }\n        \n        return true;\n    }\n    \n    // Check for winner\n    checkWinner() {\n        const board = this.board;\n        const player = this.currentPlayer;\n        \n        // Check rows\n        for (let row = 0; row < 3; row++) {\n            if (board[row].every(cell => cell === player)) {\n                return true;\n            }\n        }\n        \n        // Check columns\n        for (let col = 0; col < 3; col++) {\n            if (board.every(row => row[col] === player)) {\n                return true;\n            }\n        }\n        \n        // Check diagonals\n        if ((board[0][0] === player && board[1][1] === player && board[2][2] === player) ||\n            (board[0][2] === player && board[1][1] === player && board[2][0] === player)) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    // Get available moves\n    getAvailableMoves() {\n        const moves = [];\n        for (let row = 0; row < 3; row++) {\n            for (let col = 0; col < 3; col++) {\n                if (this.board[row][col] === ' ') {\n                    moves.push({ row, col });\n                }\n            }\n        }\n        return moves;\n    }\n    \n    // AI move using minimax algorithm (simple version)\n    getBestMove() {\n        const availableMoves = this.getAvailableMoves();\n        if (availableMoves.length === 0) return null;\n        \n        let bestMove = null;\n        let bestScore = -Infinity;\n        \n        for (const move of availableMoves) {\n            // Try the move\n            this.board[move.row][move.col] = this.currentPlayer;\n            const score = this.minimax(0, false);\n            this.board[move.row][move.col] = ' '; // Undo move\n            \n            if (score > bestScore) {\n                bestScore = score;\n                bestMove = move;\n            }\n        }\n        \n        return bestMove;\n    }\n    \n    // Minimax algorithm for AI\n    minimax(depth, isMaximizing) {\n        const winner = this.evaluateBoard();\n        \n        if (winner === 'X') return 10 - depth;\n        if (winner === 'O') return depth - 10;\n        if (this.getAvailableMoves().length === 0) return 0;\n        \n        if (isMaximizing) {\n            let bestScore = -Infinity;\n            const availableMoves = this.getAvailableMoves();\n            \n            for (const move of availableMoves) {\n                this.board[move.row][move.col] = 'X';\n                const score = this.minimax(depth + 1, false);\n                this.board[move.row][move.col] = ' ';\n                bestScore = Math.max(score, bestScore);\n            }\n            \n            return bestScore;\n        } else {\n            let bestScore = Infinity;\n            const availableMoves = this.getAvailableMoves();\n            \n            for (const move of availableMoves) {\n                this.board[move.row][move.col] = 'O';\n                const score = this.minimax(depth + 1, true);\n                this.board[move.row][move.col] = ' ';\n                bestScore = Math.min(score, bestScore);\n            }\n            \n            return bestScore;\n        }\n    }\n    \n    // Evaluate current board state\n    evaluateBoard() {\n        // Check rows\n        for (let row = 0; row < 3; row++) {\n            if (this.board[row][0] === this.board[row][1] && \n                this.board[row][1] === this.board[row][2] && \n                this.board[row][0] !== ' ') {\n                return this.board[row][0];\n            }\n        }\n        \n        // Check columns\n        for (let col = 0; col < 3; col++) {\n            if (this.board[0][col] === this.board[1][col] && \n                this.board[1][col] === this.board[2][col] && \n                this.board[0][col] !== ' ') {\n                return this.board[0][col];\n            }\n        }\n        \n        // Check diagonals\n        if (this.board[0][0] === this.board[1][1] && \n            this.board[1][1] === this.board[2][2] && \n            this.board[0][0] !== ' ') {\n            return this.board[0][0];\n        }\n        \n        if (this.board[0][2] === this.board[1][1] && \n            this.board[1][1] === this.board[2][0] && \n            this.board[0][2] !== ' ') {\n            return this.board[0][2];\n        }\n        \n        return null;\n    }\n    \n    // Reset the game\n    reset() {\n        this.board = Array(3).fill().map(() => Array(3).fill(' '));\n        this.currentPlayer = 'X';\n        this.gameOver = false;\n        this.winner = null;\n        this.moves = 0;\n    }\n    \n    // Get game status\n    getStatus() {\n        if (this.gameOver) {\n            return this.winner ? `${this.winner} wins!` : 'Tie game!';\n        }\n        return `Player ${this.currentPlayer}'s turn`;\n    }\n}\n\n// Demo game\nconsole.log('=== Tic Tac Toe Game Demo ===');\n\nconst game = new TicTacToe();\n\n// Play a sample game\nconsole.log('Initial board:');\ngame.displayBoard();\nconsole.log(game.getStatus());\n\n// Make some moves\nconst moves = [\n    [1, 1], // X center\n    [0, 0], // O top-left\n    [0, 1], // X top-middle\n    [2, 1], // O bottom-middle\n    [2, 2]  // X bottom-right\n];\n\nmoves.forEach(([row, col], index) => {\n    console.log(`\\nMove ${index + 1}: Player ${game.currentPlayer} -> (${row}, ${col})`);\n    game.makeMove(row, col);\n    game.displayBoard();\n    console.log(game.getStatus());\n    \n    if (game.gameOver) return;\n});\n\n// Demo AI vs AI\nconsole.log('\\n=== AI vs AI Demo ===');\ngame.reset();\n\nwhile (!game.gameOver && game.moves < 9) {\n    console.log(`\\nAI ${game.currentPlayer} thinking...`);\n    const bestMove = game.getBestMove();\n    \n    if (bestMove) {\n        console.log(`AI ${game.currentPlayer} plays (${bestMove.row}, ${bestMove.col})`);\n        game.makeMove(bestMove.row, bestMove.col);\n        game.displayBoard();\n    }\n    \n    if (game.moves > 6) break; // Prevent infinite perfect play\n}\n\nconsole.log('\\nFinal result:', game.getStatus());",
      "output": "=== Tic Tac Toe Game Demo ===\n\nInitial board:\n\n   0   1   2\n0    |   |  \n  ---|---|---\n1    |   |  \n  ---|---|---\n2    |   |  \n\nPlayer X's turn\n\nMove 1: Player X -> (1, 1)\n\n   0   1   2\n0    |   |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    |   |  \n\nPlayer O's turn\n\nMove 2: Player O -> (0, 0)\n\n   0   1   2\n0  O |   |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    |   |  \n\nPlayer X's turn\n\nMove 3: Player X -> (0, 1)\n\n   0   1   2\n0  O | X |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    |   |  \n\nPlayer O's turn\n\nMove 4: Player O -> (2, 1)\n\n   0   1   2\n0  O | X |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    | O |  \n\nPlayer X's turn\n\nMove 5: Player X -> (2, 2)\nPlayer X wins!\n\n   0   1   2\n0  O | X |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    | O | X\n\nX wins!\n\n=== AI vs AI Demo ===\n\nAI X thinking...\nAI X plays (1, 1)\n\n   0   1   2\n0    |   |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    |   |  \n\nAI O thinking...\nAI O plays (0, 0)\n\n   0   1   2\n0  O |   |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    |   |  \n\nAI X thinking...\nAI X plays (0, 1)\n\n   0   1   2\n0  O | X |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    |   |  \n\nAI O thinking...\nAI O plays (2, 1)\n\n   0   1   2\n0  O | X |  \n  ---|---|---\n1    | X |  \n  ---|---|---\n2    | O |  \n\nFinal result: Player X's turn"
    },
    {
      "id": 32,
      "title": "Animation Concepts - Easing Functions",
      "code": "// Animation easing functions and simple animation engine\nclass EasingFunctions {\n    // Linear easing (no acceleration)\n    static linear(t) {\n        return t;\n    }\n    \n    // Quadratic easing functions\n    static easeInQuad(t) {\n        return t * t;\n    }\n    \n    static easeOutQuad(t) {\n        return t * (2 - t);\n    }\n    \n    static easeInOutQuad(t) {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n    }\n    \n    // Cubic easing functions\n    static easeInCubic(t) {\n        return t * t * t;\n    }\n    \n    static easeOutCubic(t) {\n        return (--t) * t * t + 1;\n    }\n    \n    static easeInOutCubic(t) {\n        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n    }\n    \n    // Sine easing functions\n    static easeInSine(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n    }\n    \n    static easeOutSine(t) {\n        return Math.sin(t * Math.PI / 2);\n    }\n    \n    static easeInOutSine(t) {\n        return -(Math.cos(Math.PI * t) - 1) / 2;\n    }\n    \n    // Elastic easing functions\n    static easeInElastic(t) {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\n    }\n    \n    static easeOutElastic(t) {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n    }\n    \n    // Bounce easing functions\n    static easeOutBounce(t) {\n        const n1 = 7.5625;\n        const d1 = 2.75;\n        \n        if (t < 1 / d1) {\n            return n1 * t * t;\n        } else if (t < 2 / d1) {\n            return n1 * (t -= 1.5 / d1) * t + 0.75;\n        } else if (t < 2.5 / d1) {\n            return n1 * (t -= 2.25 / d1) * t + 0.9375;\n        } else {\n            return n1 * (t -= 2.625 / d1) * t + 0.984375;\n        }\n    }\n    \n    static easeInBounce(t) {\n        return 1 - this.easeOutBounce(1 - t);\n    }\n}\n\n// Simple Animation class\nclass Animation {\n    constructor(from, to, duration, easingFunction = 'linear') {\n        this.from = from;\n        this.to = to;\n        this.duration = duration;\n        this.easingFunction = easingFunction;\n        this.startTime = null;\n        this.isPlaying = false;\n        this.currentValue = from;\n        this.callbacks = {\n            update: [],\n            complete: []\n        };\n    }\n    \n    // Start the animation\n    start() {\n        this.startTime = Date.now();\n        this.isPlaying = true;\n        this.animate();\n        return this;\n    }\n    \n    // Animation loop\n    animate() {\n        if (!this.isPlaying) return;\n        \n        const currentTime = Date.now();\n        const elapsed = currentTime - this.startTime;\n        const progress = Math.min(elapsed / this.duration, 1);\n        \n        // Apply easing function\n        const easingFunc = EasingFunctions[this.easingFunction] || EasingFunctions.linear;\n        const easedProgress = easingFunc(progress);\n        \n        // Calculate current value\n        this.currentValue = this.from + (this.to - this.from) * easedProgress;\n        \n        // Call update callbacks\n        this.callbacks.update.forEach(callback => {\n            callback(this.currentValue, progress);\n        });\n        \n        // Check if animation is complete\n        if (progress >= 1) {\n            this.isPlaying = false;\n            this.callbacks.complete.forEach(callback => {\n                callback(this.currentValue);\n            });\n        } else {\n            // Continue animation\n            setTimeout(() => this.animate(), 16); // ~60fps\n        }\n    }\n    \n    // Add update callback\n    onUpdate(callback) {\n        this.callbacks.update.push(callback);\n        return this;\n    }\n    \n    // Add complete callback\n    onComplete(callback) {\n        this.callbacks.complete.push(callback);\n        return this;\n    }\n    \n    // Stop animation\n    stop() {\n        this.isPlaying = false;\n        return this;\n    }\n    \n    // Reset animation\n    reset() {\n        this.startTime = null;\n        this.isPlaying = false;\n        this.currentValue = this.from;\n        return this;\n    }\n}\n\n// Animation sequence manager\nclass AnimationSequence {\n    constructor() {\n        this.animations = [];\n        this.currentIndex = 0;\n        this.isPlaying = false;\n    }\n    \n    // Add animation to sequence\n    add(animation) {\n        this.animations.push(animation);\n        return this;\n    }\n    \n    // Play sequence\n    play() {\n        if (this.animations.length === 0) return;\n        \n        this.isPlaying = true;\n        this.playNext();\n        return this;\n    }\n    \n    // Play next animation in sequence\n    playNext() {\n        if (!this.isPlaying || this.currentIndex >= this.animations.length) {\n            this.isPlaying = false;\n            this.currentIndex = 0;\n            return;\n        }\n        \n        const animation = this.animations[this.currentIndex];\n        animation.onComplete(() => {\n            this.currentIndex++;\n            this.playNext();\n        });\n        \n        animation.start();\n    }\n    \n    // Reset sequence\n    reset() {\n        this.currentIndex = 0;\n        this.isPlaying = false;\n        this.animations.forEach(anim => anim.reset());\n        return this;\n    }\n}\n\n// Usage examples\nconsole.log('=== Animation Engine Demo ===');\n\n// Simple position animation\nlet position = { x: 0, y: 0 };\n\nconst moveAnimation = new Animation(0, 100, 1000, 'easeOutBounce')\n    .onUpdate((value, progress) => {\n        position.x = value;\n        if (Math.floor(progress * 10) % 2 === 0) { // Log every 20% progress\n            console.log(`Position X: ${Math.round(value)} (${Math.round(progress * 100)}%)`);\n        }\n    })\n    .onComplete((value) => {\n        console.log(`Animation complete! Final X: ${Math.round(value)}`);\n    });\n\n// Color animation example\nlet color = { r: 255, g: 0, b: 0 }; // Start with red\n\nconst colorAnimation = new Animation(0, 255, 800, 'easeInOutSine')\n    .onUpdate((value, progress) => {\n        color.r = Math.round(255 - value);  // Red decreases\n        color.g = Math.round(value);        // Green increases\n        color.b = Math.round(value * 0.5);  // Blue increases slowly\n        \n        if (Math.floor(progress * 5) % 1 === 0) { // Log every 20% progress\n            console.log(`Color: rgb(${color.r}, ${color.g}, ${color.b})`);\n        }\n    })\n    .onComplete(() => {\n        console.log(`Color animation complete: rgb(${color.r}, ${color.g}, ${color.b})`);\n    });\n\n// Scale animation with elastic easing\nlet scale = 1;\n\nconst scaleAnimation = new Animation(1, 2, 1200, 'easeOutElastic')\n    .onUpdate((value, progress) => {\n        scale = value;\n        if (Math.floor(progress * 10) % 2 === 0) {\n            console.log(`Scale: ${scale.toFixed(2)}`);\n        }\n    })\n    .onComplete((value) => {\n        console.log(`Scale animation complete! Final scale: ${value.toFixed(2)}`);\n    });\n\n// Create animation sequence\nconsole.log('\\n=== Starting Animation Sequence ===');\n\nconst sequence = new AnimationSequence()\n    .add(moveAnimation)\n    .add(colorAnimation)\n    .add(scaleAnimation);\n\n// Start the sequence\nsequence.play();\n\n// Demonstrate different easing functions\nconsole.log('\\n=== Easing Function Comparison ===');\nconst easingFunctions = [\n    'linear', 'easeInQuad', 'easeOutQuad', 'easeInCubic', \n    'easeOutCubic', 'easeInSine', 'easeOutSine'\n];\n\neasingFunctions.forEach((easingName, index) => {\n    const testValue = 0.5; // Test at 50% progress\n    const result = EasingFunctions[easingName](testValue);\n    console.log(`${easingName}(0.5) = ${result.toFixed(3)}`);\n});\n\n// Animation utility functions\nclass AnimationUtils {\n    // Interpolate between two values\n    static lerp(start, end, progress) {\n        return start + (end - start) * progress;\n    }\n    \n    // Interpolate between two colors\n    static lerpColor(color1, color2, progress) {\n        return {\n            r: Math.round(this.lerp(color1.r, color2.r, progress)),\n            g: Math.round(this.lerp(color1.g, color2.g, progress)),\n            b: Math.round(this.lerp(color1.b, color2.b, progress))\n        };\n    }\n    \n    // Convert progress to degrees (for rotation)\n    static progressToDegrees(progress, fullRotations = 1) {\n        return progress * 360 * fullRotations;\n    }\n}\n\n// Demo utility functions\nconsole.log('\\n=== Animation Utilities Demo ===');\nconst startColor = { r: 255, g: 0, b: 0 };    // Red\nconst endColor = { r: 0, g: 255, b: 0 };      // Green\nconst midColor = AnimationUtils.lerpColor(startColor, endColor, 0.5);\nconsole.log(`Color interpolation: rgb(${midColor.r}, ${midColor.g}, ${midColor.b})`);\n\nconst rotation = AnimationUtils.progressToDegrees(0.25, 2); // 25% of 2 full rotations\nconsole.log(`Rotation at 25% progress: ${rotation}°`);",
      "output": "=== Animation Engine Demo ===\n\n=== Starting Animation Sequence ===\nPosition X: 0 (0%)\nPosition X: 8 (20%)\nPosition X: 62 (40%)\nPosition X: 91 (60%)\nPosition X: 99 (80%)\nAnimation complete! Final X: 100\nColor: rgb(255, 0, 0)\nColor: rgb(191, 64, 32)\nColor: rgb(127, 128, 64)\nColor: rgb(63, 192, 96)\nColor animation complete: rgb(0, 255, 128)\nScale: 1.00\nScale: 1.15\nScale: 1.85\nScale: 1.98\nScale: 2.00\nScale animation complete! Final scale: 2.00\n\n=== Easing Function Comparison ===\nlinear(0.5) = 0.500\neaseInQuad(0.5) = 0.250\neaseOutQuad(0.5) = 0.750\neaseInCubic(0.5) = 0.125\neaseOutCubic(0.5) = 0.875\neaseInSine(0.5) = 0.293\neaseOutSine(0.5) = 0.707\n\n=== Animation Utilities Demo ===\nColor interpolation: rgb(128, 128, 0)\nRotation at 25% progress: 180°"
    },
    {
      "id": 33,
      "title": "Canvas Simulation - Drawing Engine",
      "code": "// Canvas simulation for drawing operations\nclass CanvasSimulator {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.pixels = Array(height).fill().map(() => Array(width).fill('  '));\n        this.currentColor = '#';\n        this.fillColor = '░░';\n        this.strokeColor = '██';\n        this.backgroundColor = '  ';\n        this.lineWidth = 1;\n        this.drawingHistory = [];\n    }\n    \n    // Clear the canvas\n    clear() {\n        this.pixels = Array(this.height).fill().map(() => Array(this.width).fill(this.backgroundColor));\n        this.drawingHistory.push({ action: 'clear' });\n    }\n    \n    // Set pixel at coordinates\n    setPixel(x, y, char = this.strokeColor) {\n        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {\n            this.pixels[y][x] = char;\n        }\n    }\n    \n    // Get pixel at coordinates\n    getPixel(x, y) {\n        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {\n            return this.pixels[y][x];\n        }\n        return null;\n    }\n    \n    // Draw a line using Bresenham's algorithm\n    drawLine(x0, y0, x1, y1) {\n        const dx = Math.abs(x1 - x0);\n        const dy = Math.abs(y1 - y0);\n        const sx = x0 < x1 ? 1 : -1;\n        const sy = y0 < y1 ? 1 : -1;\n        let err = dx - dy;\n        \n        let x = x0, y = y0;\n        \n        while (true) {\n            this.setPixel(x, y);\n            \n            if (x === x1 && y === y1) break;\n            \n            const e2 = 2 * err;\n            if (e2 > -dy) {\n                err -= dy;\n                x += sx;\n            }\n            if (e2 < dx) {\n                err += dx;\n                y += sy;\n            }\n        }\n        \n        this.drawingHistory.push({ action: 'line', x0, y0, x1, y1 });\n    }\n    \n    // Draw a rectangle\n    drawRect(x, y, width, height, filled = false) {\n        if (filled) {\n            for (let i = 0; i < height; i++) {\n                for (let j = 0; j < width; j++) {\n                    this.setPixel(x + j, y + i, this.fillColor);\n                }\n            }\n        } else {\n            // Top and bottom edges\n            for (let j = 0; j < width; j++) {\n                this.setPixel(x + j, y);\n                this.setPixel(x + j, y + height - 1);\n            }\n            // Left and right edges\n            for (let i = 0; i < height; i++) {\n                this.setPixel(x, y + i);\n                this.setPixel(x + width - 1, y + i);\n            }\n        }\n        \n        this.drawingHistory.push({ action: 'rect', x, y, width, height, filled });\n    }\n    \n    // Draw a circle using Bresenham's circle algorithm\n    drawCircle(centerX, centerY, radius, filled = false) {\n        if (filled) {\n            for (let y = -radius; y <= radius; y++) {\n                for (let x = -radius; x <= radius; x++) {\n                    if (x * x + y * y <= radius * radius) {\n                        this.setPixel(centerX + x, centerY + y, this.fillColor);\n                    }\n                }\n            }\n        } else {\n            let x = 0;\n            let y = radius;\n            let d = 3 - 2 * radius;\n            \n            while (y >= x) {\n                // Draw all eight octants\n                this.setPixel(centerX + x, centerY + y);\n                this.setPixel(centerX - x, centerY + y);\n                this.setPixel(centerX + x, centerY - y);\n                this.setPixel(centerX - x, centerY - y);\n                this.setPixel(centerX + y, centerY + x);\n                this.setPixel(centerX - y, centerY + x);\n                this.setPixel(centerX + y, centerY - x);\n                this.setPixel(centerX - y, centerY - x);\n                \n                x++;\n                \n                if (d > 0) {\n                    y--;\n                    d = d + 4 * (x - y) + 10;\n                } else {\n                    d = d + 4 * x + 6;\n                }\n            }\n        }\n        \n        this.drawingHistory.push({ action: 'circle', centerX, centerY, radius, filled });\n    }\n    \n    // Draw text (simple bitmap font simulation)\n    drawText(x, y, text) {\n        const charWidth = 3;\n        const charHeight = 5;\n        \n        // Simple bitmap patterns for characters\n        const charPatterns = {\n            'A': ['█░█', '███', '█░█', '█░█', '█░█'],\n            'B': ['██░', '█░█', '██░', '█░█', '██░'],\n            'C': ['░██', '█░░', '█░░', '█░░', '░██'],\n            'D': ['██░', '█░█', '█░█', '█░█', '██░'],\n            'E': ['███', '█░░', '██░', '█░░', '███'],\n            'F': ['███', '█░░', '██░', '█░░', '█░░'],\n            'G': ['░██', '█░░', '█░█', '█░█', '░██'],\n            'H': ['█░█', '█░█', '███', '█░█', '█░█'],\n            'I': ['███', '░█░', '░█░', '░█░', '███'],\n            'J': ['███', '░░█', '░░█', '█░█', '░██'],\n            'L': ['█░░', '█░░', '█░░', '█░░', '███'],\n            'O': ['░██', '█░█', '█░█', '█░█', '░██'],\n            'R': ['██░', '█░█', '██░', '█░█', '█░█'],\n            'S': ['░██', '█░░', '░█░', '░░█', '██░'],\n            ' ': ['░░░', '░░░', '░░░', '░░░', '░░░']\n        };\n        \n        for (let i = 0; i < text.length; i++) {\n            const char = text[i].toUpperCase();\n            const pattern = charPatterns[char] || charPatterns[' '];\n            \n            for (let row = 0; row < charHeight; row++) {\n                for (let col = 0; col < charWidth; col++) {\n                    if (pattern[row][col] === '█') {\n                        this.setPixel(x + i * (charWidth + 1) + col, y + row, this.strokeColor);\n                    }\n                }\n            }\n        }\n        \n        this.drawingHistory.push({ action: 'text', x, y, text });\n    }\n    \n    // Flood fill algorithm\n    floodFill(x, y, newColor) {\n        const originalColor = this.getPixel(x, y);\n        if (originalColor === newColor) return;\n        \n        const stack = [[x, y]];\n        \n        while (stack.length > 0) {\n            const [currentX, currentY] = stack.pop();\n            \n            if (currentX < 0 || currentX >= this.width || \n                currentY < 0 || currentY >= this.height) continue;\n            \n            if (this.getPixel(currentX, currentY) !== originalColor) continue;\n            \n            this.setPixel(currentX, currentY, newColor);\n            \n            // Add adjacent pixels to stack\n            stack.push([currentX + 1, currentY]);\n            stack.push([currentX - 1, currentY]);\n            stack.push([currentX, currentY + 1]);\n            stack.push([currentX, currentY - 1]);\n        }\n        \n        this.drawingHistory.push({ action: 'floodFill', x, y, newColor });\n    }\n    \n    // Render the canvas to console\n    render() {\n        console.log('┌' + '─'.repeat(this.width * 2) + '┐');\n        for (let row of this.pixels) {\n            console.log('│' + row.join('') + '│');\n        }\n        console.log('└' + '─'.repeat(this.width * 2) + '┘');\n    }\n    \n    // Get drawing statistics\n    getStats() {\n        const actionCounts = {};\n        this.drawingHistory.forEach(action => {\n            actionCounts[action.action] = (actionCounts[action.action] || 0) + 1;\n        });\n        \n        return {\n            dimensions: { width: this.width, height: this.height },\n            totalPixels: this.width * this.height,\n            drawingOperations: this.drawingHistory.length,\n            actionBreakdown: actionCounts\n        };\n    }\n    \n    // Save canvas as ASCII art\n    exportAscii() {\n        let ascii = '';\n        for (let row of this.pixels) {\n            ascii += row.join('') + '\\n';\n        }\n        return ascii;\n    }\n}\n\n// Usage example\nconsole.log('=== Canvas Simulator Demo ===');\n\nconst canvas = new CanvasSimulator(20, 12);\n\n// Clear and draw background\ncanvas.clear();\nconsole.log('\\nEmpty canvas:');\ncanvas.render();\n\n// Draw some shapes\nconsole.log('\\n=== Drawing Shapes ===');\n\n// Draw a rectangle\ncanvas.drawRect(2, 2, 6, 4, false);\nconsole.log('\\nRectangle:');\ncanvas.render();\n\n// Draw a filled circle\ncanvas.drawCircle(15, 6, 3, true);\nconsole.log('\\nAdded filled circle:');\ncanvas.render();\n\n// Draw some lines\ncanvas.drawLine(0, 0, 19, 11);\ncanvas.drawLine(0, 11, 19, 0);\nconsole.log('\\nAdded diagonal lines:');\ncanvas.render();\n\n// Draw text\ncanvas.drawText(1, 8, 'HELLO');\nconsole.log('\\nAdded text:');\ncanvas.render();\n\n// Show statistics\nconsole.log('\\n=== Canvas Statistics ===');\nconst stats = canvas.getStats();\nconsole.log('Dimensions:', `${stats.dimensions.width}x${stats.dimensions.height}`);\nconsole.log('Total pixels:', stats.totalPixels);\nconsole.log('Drawing operations:', stats.drawingOperations);\nconsole.log('Operations breakdown:', stats.actionBreakdown);\n\n// Create a simple drawing\nconsole.log('\\n=== Creating Art ===');\nconst artCanvas = new CanvasSimulator(16, 10);\nartCanvas.clear();\n\n// Draw a house\nartCanvas.drawRect(3, 6, 10, 4, false);  // House base\nartCanvas.drawLine(3, 6, 8, 2);          // Left roof\nartCanvas.drawLine(8, 2, 13, 6);         // Right roof\nartCanvas.drawRect(5, 7, 2, 2, true);    // Door\nartCanvas.drawRect(9, 7, 2, 2, false);   // Window\nartCanvas.drawCircle(12, 1, 1, true);    // Sun\n\nconsole.log('\\nHouse drawing:');\nartCanvas.render();\n\nconsole.log('\\nHouse stats:', artCanvas.getStats());",
      "output": "=== Canvas Simulator Demo ===\n\nEmpty canvas:\n┌────────────────────────────────────────┐\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n└────────────────────────────────────────┘\n\n=== Drawing Shapes ===\n\nRectangle:\n┌────────────────────────────────────────┐\n│                                        │\n│                                        │\n│    ████████████                        │\n│    ██        ██                        │\n│    ██        ██                        │\n│    ████████████                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n└────────────────────────────────────────┘\n\nAdded filled circle:\n┌────────────────────────────────────────┐\n│                                        │\n│                                        │\n│    ████████████                        │\n│    ██        ██          ░░░░░░        │\n│    ██        ██        ░░░░░░░░░░      │\n│    ████████████        ░░░░░░░░░░      │\n│                        ░░░░░░░░░░      │\n│                          ░░░░░░        │\n│                                        │\n│                                        │\n│                                        │\n│                                        │\n└────────────────────────────────────────┘\n\nAdded diagonal lines:\n┌────────────────────────────────────────┐\n│██                                    ██│\n│  ██                                ██  │\n│    ████████████              ████      │\n│    ██        ██    ░░░░░░  ██          │\n│    ██        ██  ░░░░░░░░░░██          │\n│    ████████████  ░░░░░░░░░░██          │\n│              ██  ░░░░░░░░░░            │\n│            ██      ░░░░░░              │\n│          ██                            │\n│        ██                              │\n│      ██                                │\n│    ██                                  │\n└────────────────────────────────────────┘\n\nAdded text:\n┌────────────────────────────────────────┐\n│██                                    ██│\n│  ██                                ██  │\n│    ████████████              ████      │\n│    ██        ██    ░░░░░░  ██          │\n│    ██        ██  ░░░░░░░░░░██          │\n│    ████████████  ░░░░░░░░░░██          │\n│              ██  ░░░░░░░░░░            │\n│            ██      ░░░░░░              │\n│  ████░██████████████                  │\n│  █░█████░██░██████                     │\n│  ████░█████░██████                     │\n│  █░█████░██░██████                     │\n└────────────────────────────────────────┘\n\n=== Canvas Statistics ===\nDimensions: 20x12\nTotal pixels: 240\nDrawing operations: 6\nOperations breakdown: {clear: 1, rect: 1, circle: 1, line: 2, text: 1}\n\n=== Creating Art ===\n\nHouse drawing:\n┌────────────────────────────────┐\n│                        ░░░░    │\n│                      ░░░░░░    │\n│        ██                      │\n│      ██  ██                    │\n│    ██      ██                  │\n│  ██          ██                │\n│    ██████████████              │\n│    ██░░░░██████████            │\n│    ██░░░░████░░██              │\n│    ██████████████              │\n└────────────────────────────────┘\n\nHouse stats: {dimensions: {width: 16, height: 10}, totalPixels: 160, drawingOperations: 7, actionBreakdown: {clear: 1, rect: 3, line: 2, circle: 1}}"
    },
    {
      "id": 34,
      "title": "WebAPI Simulations - Geolocation & Notification",
      "code": "// Simulated Web APIs for Geolocation and Notifications\nclass GeolocationSimulator {\n    constructor() {\n        this.isSupported = true;\n        this.permissions = {\n            geolocation: 'prompt' // 'granted', 'denied', 'prompt'\n        };\n        \n        // Simulated locations\n        this.locations = [\n            { name: 'New York', lat: 40.7128, lng: -74.0060 },\n            { name: 'London', lat: 51.5074, lng: -0.1278 },\n            { name: 'Tokyo', lat: 35.6762, lng: 139.6503 },\n            { name: 'Sydney', lat: -33.8688, lng: 151.2093 },\n            { name: 'Paris', lat: 48.8566, lng: 2.3522 }\n        ];\n        \n        this.currentLocation = this.locations[0]; // Default to New York\n        this.accuracy = 10; // meters\n        this.watchId = 0;\n        this.watchers = new Map();\n    }\n    \n    // Simulate requesting permission\n    async requestPermission() {\n        console.log('Requesting geolocation permission...');\n        \n        // Simulate user decision\n        const userChoice = Math.random() > 0.3; // 70% chance of granting\n        \n        if (userChoice) {\n            this.permissions.geolocation = 'granted';\n            console.log('✓ Geolocation permission granted');\n            return 'granted';\n        } else {\n            this.permissions.geolocation = 'denied';\n            console.log('✗ Geolocation permission denied');\n            return 'denied';\n        }\n    }\n    \n    // Get current position\n    async getCurrentPosition(options = {}) {\n        return new Promise((resolve, reject) => {\n            if (this.permissions.geolocation === 'denied') {\n                reject(new Error('User denied Geolocation'));\n                return;\n            }\n            \n            if (this.permissions.geolocation === 'prompt') {\n                this.requestPermission().then(permission => {\n                    if (permission === 'denied') {\n                        reject(new Error('User denied Geolocation'));\n                        return;\n                    }\n                    this._getPosition(resolve, reject, options);\n                });\n            } else {\n                this._getPosition(resolve, reject, options);\n            }\n        });\n    }\n    \n    _getPosition(resolve, reject, options) {\n        // Simulate network delay\n        const delay = options.timeout || 5000;\n        const enableHighAccuracy = options.enableHighAccuracy || false;\n        \n        setTimeout(() => {\n            // Add some random variation to simulate GPS accuracy\n            const latVariation = (Math.random() - 0.5) * 0.001;\n            const lngVariation = (Math.random() - 0.5) * 0.001;\n            const accuracyVariation = Math.random() * 20;\n            \n            const position = {\n                coords: {\n                    latitude: this.currentLocation.lat + latVariation,\n                    longitude: this.currentLocation.lng + lngVariation,\n                    accuracy: enableHighAccuracy ? this.accuracy + accuracyVariation : this.accuracy * 2 + accuracyVariation,\n                    altitude: Math.random() * 100,\n                    altitudeAccuracy: Math.random() * 10,\n                    heading: Math.random() * 360,\n                    speed: Math.random() * 20\n                },\n                timestamp: Date.now()\n            };\n            \n            resolve(position);\n        }, Math.min(delay, 1000)); // Max 1 second for simulation\n    }\n    \n    // Watch position changes\n    watchPosition(successCallback, errorCallback = null, options = {}) {\n        const id = ++this.watchId;\n        \n        if (this.permissions.geolocation === 'denied') {\n            if (errorCallback) errorCallback(new Error('User denied Geolocation'));\n            return id;\n        }\n        \n        const interval = setInterval(() => {\n            this._getPosition(\n                (position) => {\n                    successCallback(position);\n                },\n                (error) => {\n                    if (errorCallback) errorCallback(error);\n                },\n                options\n            );\n        }, 2000); // Update every 2 seconds\n        \n        this.watchers.set(id, interval);\n        return id;\n    }\n    \n    // Clear position watch\n    clearWatch(watchId) {\n        if (this.watchers.has(watchId)) {\n            clearInterval(this.watchers.get(watchId));\n            this.watchers.delete(watchId);\n            console.log(`Cleared watch ${watchId}`);\n        }\n    }\n    \n    // Simulate moving to a different location\n    simulateMovement() {\n        const newLocation = this.locations[Math.floor(Math.random() * this.locations.length)];\n        this.currentLocation = newLocation;\n        console.log(`Simulated movement to ${newLocation.name}`);\n    }\n    \n    // Calculate distance between two points\n    calculateDistance(lat1, lng1, lat2, lng2) {\n        const R = 6371e3; // Earth's radius in meters\n        const φ1 = lat1 * Math.PI/180;\n        const φ2 = lat2 * Math.PI/180;\n        const Δφ = (lat2-lat1) * Math.PI/180;\n        const Δλ = (lng2-lng1) * Math.PI/180;\n        \n        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n                Math.cos(φ1) * Math.cos(φ2) *\n                Math.sin(Δλ/2) * Math.sin(Δλ/2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n        \n        return R * c; // Distance in meters\n    }\n}\n\n// Notification API Simulator\nclass NotificationSimulator {\n    constructor() {\n        this.permission = 'default'; // 'granted', 'denied', 'default'\n        this.notifications = [];\n        this.maxNotifications = 10;\n    }\n    \n    // Request notification permission\n    static async requestPermission() {\n        console.log('Requesting notification permission...');\n        \n        // Simulate user decision\n        const userChoice = Math.random() > 0.4; // 60% chance of granting\n        \n        const permission = userChoice ? 'granted' : 'denied';\n        console.log(`Notification permission: ${permission}`);\n        \n        return permission;\n    }\n    \n    // Create a notification\n    constructor(title, options = {}) {\n        if (NotificationSimulator.permission === 'denied') {\n            throw new Error('Notification permission denied');\n        }\n        \n        this.title = title;\n        this.body = options.body || '';\n        this.icon = options.icon || '🔔';\n        this.tag = options.tag || null;\n        this.data = options.data || null;\n        this.timestamp = Date.now();\n        this.id = Math.random().toString(36).substr(2, 9);\n        \n        // Event handlers\n        this.onclick = null;\n        this.onclose = null;\n        this.onerror = null;\n        this.onshow = null;\n        \n        // Add to notifications list\n        NotificationSimulator.notifications.push(this);\n        \n        // Keep only recent notifications\n        if (NotificationSimulator.notifications.length > NotificationSimulator.maxNotifications) {\n            NotificationSimulator.notifications.shift();\n        }\n        \n        // Simulate showing notification\n        this._show();\n        \n        return this;\n    }\n    \n    _show() {\n        console.log(`\\n📱 Notification: ${this.title}`);\n        if (this.body) console.log(`   ${this.body}`);\n        console.log(`   ${this.icon} ID: ${this.id}`);\n        \n        if (this.onshow) this.onshow();\n        \n        // Auto-close after 5 seconds\n        setTimeout(() => {\n            this.close();\n        }, 5000);\n    }\n    \n    // Close notification\n    close() {\n        console.log(`   ❌ Notification ${this.id} closed`);\n        if (this.onclose) this.onclose();\n        \n        // Remove from active notifications\n        const index = NotificationSimulator.notifications.indexOf(this);\n        if (index > -1) {\n            NotificationSimulator.notifications.splice(index, 1);\n        }\n    }\n    \n    // Static methods and properties\n    static permission = 'default';\n    static notifications = [];\n    static maxNotifications = 10;\n    \n    static getNotifications() {\n        return [...this.notifications];\n    }\n    \n    static clearAll() {\n        this.notifications.forEach(notification => notification.close());\n    }\n}\n\n// Demo usage\nasync function demonstrateWebAPIs() {\n    console.log('=== Web API Simulations Demo ===');\n    \n    // Geolocation Demo\n    console.log('\\n=== Geolocation API ===');\n    \n    const geo = new GeolocationSimulator();\n    \n    try {\n        // Get current position\n        console.log('Getting current position...');\n        const position = await geo.getCurrentPosition({ \n            enableHighAccuracy: true,\n            timeout: 10000\n        });\n        \n        console.log('Current position:');\n        console.log(`  Latitude: ${position.coords.latitude.toFixed(6)}`);\n        console.log(`  Longitude: ${position.coords.longitude.toFixed(6)}`);\n        console.log(`  Accuracy: ${position.coords.accuracy.toFixed(1)} meters`);\n        console.log(`  Location: ${geo.currentLocation.name}`);\n        \n        // Start watching position\n        console.log('\\nStarting position watch...');\n        const watchId = geo.watchPosition(\n            (pos) => {\n                console.log(`📍 Position update: ${pos.coords.latitude.toFixed(4)}, ${pos.coords.longitude.toFixed(4)}`);\n            },\n            (error) => {\n                console.error('Watch error:', error.message);\n            }\n        );\n        \n        // Simulate movement\n        setTimeout(() => {\n            geo.simulateMovement();\n        }, 3000);\n        \n        setTimeout(() => {\n            geo.simulateMovement();\n        }, 6000);\n        \n        // Clear watch after 8 seconds\n        setTimeout(() => {\n            geo.clearWatch(watchId);\n        }, 8000);\n        \n        // Calculate distances\n        const nyc = geo.locations[0];\n        const london = geo.locations[1];\n        const distance = geo.calculateDistance(nyc.lat, nyc.lng, london.lat, london.lng);\n        console.log(`\\nDistance NYC to London: ${Math.round(distance / 1000)} km`);\n        \n    } catch (error) {\n        console.error('Geolocation error:', error.message);\n    }\n    \n    // Notification Demo\n    console.log('\\n=== Notification API ===');\n    \n    try {\n        // Request permission\n        const permission = await NotificationSimulator.requestPermission();\n        NotificationSimulator.permission = permission;\n        \n        if (permission === 'granted') {\n            // Create different types of notifications\n            const welcomeNotification = new NotificationSimulator('Welcome!', {\n                body: 'Thanks for visiting our app',\n                icon: '👋',\n                tag: 'welcome'\n            });\n            \n            setTimeout(() => {\n                const updateNotification = new NotificationSimulator('App Update', {\n                    body: 'A new version is available',\n                    icon: '🔄',\n                    tag: 'update',\n                    data: { version: '2.1.0', urgent: false }\n                });\n            }, 2000);\n            \n            setTimeout(() => {\n                const messageNotification = new NotificationSimulator('New Message', {\n                    body: 'You have 3 new messages',\n                    icon: '💬',\n                    tag: 'messages'\n                });\n                \n                messageNotification.onclick = () => {\n                    console.log('   👆 User clicked on message notification');\n                };\n            }, 4000);\n            \n            // Show notification stats after 10 seconds\n            setTimeout(() => {\n                const activeNotifications = NotificationSimulator.getNotifications();\n                console.log(`\\n📊 Active notifications: ${activeNotifications.length}`);\n                activeNotifications.forEach(notification => {\n                    console.log(`   - ${notification.title} (${notification.id})`);\n                });\n            }, 10000);\n            \n        } else {\n            console.log('Cannot show notifications - permission denied');\n        }\n        \n    } catch (error) {\n        console.error('Notification error:', error.message);\n    }\n}\n\n// Run the demonstration\ndemonstrate WebAPIs();",
      "output": "=== Web API Simulations Demo ===\n\n=== Geolocation API ===\nGetting current position...\nRequesting geolocation permission...\n✓ Geolocation permission granted\nCurrent position:\n  Latitude: 40.712801\n  Longitude: -74.005998\n  Accuracy: 15.3 meters\n  Location: New York\n\nStarting position watch...\n📍 Position update: 40.7128, -74.0060\n📍 Position update: 40.7128, -74.0060\nSimulated movement to Tokyo\n📍 Position update: 35.6762, 139.6503\n📍 Position update: 35.6762, 139.6503\nSimulated movement to London\n📍 Position update: 51.5074, -0.1278\nCleared watch 1\n\nDistance NYC to London: 5585 km\n\n=== Notification API ===\nRequesting notification permission...\nNotification permission: granted\n\n📱 Notification: Welcome!\n   Thanks for visiting our app\n   👋 ID: k3m9p8q2x\n\n📱 Notification: App Update\n   A new version is available\n   🔄 ID: r7t4n2w5z\n   ❌ Notification k3m9p8q2x closed\n\n📱 Notification: New Message\n   You have 3 new messages\n   💬 ID: a9s6d3f1g\n   ❌ Notification r7t4n2w5z closed\n   ❌ Notification a9s6d3f1g closed\n\n📊 Active notifications: 0"
    },
    {
      "id": 35,
      "title": "Testing Patterns - Unit Test Framework",
      "code": "// Simple unit testing framework with assertions and test suites\nclass TestFramework {\n    constructor() {\n        this.testSuites = [];\n        this.totalTests = 0;\n        this.passedTests = 0;\n        this.failedTests = 0;\n        this.beforeAllCallbacks = [];\n        this.afterAllCallbacks = [];\n        this.beforeEachCallbacks = [];\n        this.afterEachCallbacks = [];\n    }\n    \n    // Register test suite\n    describe(description, callback) {\n        const suite = new TestSuite(description);\n        this.testSuites.push(suite);\n        \n        // Set current suite context\n        const previousContext = global.currentTestSuite;\n        global.currentTestSuite = suite;\n        \n        try {\n            callback();\n        } finally {\n            global.currentTestSuite = previousContext;\n        }\n        \n        return suite;\n    }\n    \n    // Register individual test\n    it(description, testFunction) {\n        const suite = global.currentTestSuite;\n        if (!suite) {\n            throw new Error('Test must be defined within a describe block');\n        }\n        \n        const test = new Test(description, testFunction);\n        suite.addTest(test);\n        return test;\n    }\n    \n    // Setup hooks\n    beforeAll(callback) {\n        this.beforeAllCallbacks.push(callback);\n    }\n    \n    afterAll(callback) {\n        this.afterAllCallbacks.push(callback);\n    }\n    \n    beforeEach(callback) {\n        const suite = global.currentTestSuite;\n        if (suite) {\n            suite.beforeEach(callback);\n        } else {\n            this.beforeEachCallbacks.push(callback);\n        }\n    }\n    \n    afterEach(callback) {\n        const suite = global.currentTestSuite;\n        if (suite) {\n            suite.afterEach(callback);\n        } else {\n            this.afterEachCallbacks.push(callback);\n        }\n    }\n    \n    // Run all tests\n    async run() {\n        console.log('🧪 Running Test Suite');\n        console.log('='.repeat(50));\n        \n        // Execute beforeAll hooks\n        for (const callback of this.beforeAllCallbacks) {\n            await callback();\n        }\n        \n        // Run all test suites\n        for (const suite of this.testSuites) {\n            await this.runSuite(suite);\n        }\n        \n        // Execute afterAll hooks\n        for (const callback of this.afterAllCallbacks) {\n            await callback();\n        }\n        \n        this.printSummary();\n    }\n    \n    async runSuite(suite) {\n        console.log(`\\n📁 ${suite.description}`);\n        \n        for (const test of suite.tests) {\n            this.totalTests++;\n            \n            try {\n                // Run beforeEach hooks\n                for (const callback of suite.beforeEachCallbacks) {\n                    await callback();\n                }\n                for (const callback of this.beforeEachCallbacks) {\n                    await callback();\n                }\n                \n                // Run the test\n                const startTime = Date.now();\n                await test.run();\n                const duration = Date.now() - startTime;\n                \n                console.log(`  ✅ ${test.description} (${duration}ms)`);\n                this.passedTests++;\n                \n                // Run afterEach hooks\n                for (const callback of suite.afterEachCallbacks) {\n                    await callback();\n                }\n                for (const callback of this.afterEachCallbacks) {\n                    await callback();\n                }\n                \n            } catch (error) {\n                console.log(`  ❌ ${test.description}`);\n                console.log(`     ${error.message}`);\n                this.failedTests++;\n            }\n        }\n    }\n    \n    printSummary() {\n        console.log('\\n' + '='.repeat(50));\n        console.log('📊 Test Results Summary');\n        console.log(`Total: ${this.totalTests}`);\n        console.log(`✅ Passed: ${this.passedTests}`);\n        console.log(`❌ Failed: ${this.failedTests}`);\n        console.log(`Success Rate: ${((this.passedTests / this.totalTests) * 100).toFixed(1)}%`);\n        \n        if (this.failedTests === 0) {\n            console.log('\\n🎉 All tests passed!');\n        } else {\n            console.log(`\\n💥 ${this.failedTests} test(s) failed`);\n        }\n    }\n}\n\nclass TestSuite {\n    constructor(description) {\n        this.description = description;\n        this.tests = [];\n        this.beforeEachCallbacks = [];\n        this.afterEachCallbacks = [];\n    }\n    \n    addTest(test) {\n        this.tests.push(test);\n    }\n    \n    beforeEach(callback) {\n        this.beforeEachCallbacks.push(callback);\n    }\n    \n    afterEach(callback) {\n        this.afterEachCallbacks.push(callback);\n    }\n}\n\nclass Test {\n    constructor(description, testFunction) {\n        this.description = description;\n        this.testFunction = testFunction;\n    }\n    \n    async run() {\n        await this.testFunction();\n    }\n}\n\n// Assertion library\nclass Assertions {\n    static expect(actual) {\n        return {\n            toBe: (expected) => {\n                if (actual !== expected) {\n                    throw new AssertionError(`Expected ${actual} to be ${expected}`);\n                }\n            },\n            \n            toEqual: (expected) => {\n                if (JSON.stringify(actual) !== JSON.stringify(expected)) {\n                    throw new AssertionError(`Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(expected)}`);\n                }\n            },\n            \n            toBeGreaterThan: (expected) => {\n                if (actual <= expected) {\n                    throw new AssertionError(`Expected ${actual} to be greater than ${expected}`);\n                }\n            },\n            \n            toBeLessThan: (expected) => {\n                if (actual >= expected) {\n                    throw new AssertionError(`Expected ${actual} to be less than ${expected}`);\n                }\n            },\n            \n            toContain: (expected) => {\n                if (!actual.includes || !actual.includes(expected)) {\n                    throw new AssertionError(`Expected ${actual} to contain ${expected}`);\n                }\n            },\n            \n            toThrow: () => {\n                if (typeof actual !== 'function') {\n                    throw new AssertionError('Expected a function that throws');\n                }\n                \n                try {\n                    actual();\n                    throw new AssertionError('Expected function to throw an error');\n                } catch (error) {\n                    if (error instanceof AssertionError) {\n                        throw error;\n                    }\n                    // Function threw as expected\n                }\n            },\n            \n            toBeTruthy: () => {\n                if (!actual) {\n                    throw new AssertionError(`Expected ${actual} to be truthy`);\n                }\n            },\n            \n            toBeFalsy: () => {\n                if (actual) {\n                    throw new AssertionError(`Expected ${actual} to be falsy`);\n                }\n            },\n            \n            toBeNull: () => {\n                if (actual !== null) {\n                    throw new AssertionError(`Expected ${actual} to be null`);\n                }\n            },\n            \n            toBeUndefined: () => {\n                if (actual !== undefined) {\n                    throw new AssertionError(`Expected ${actual} to be undefined`);\n                }\n            }\n        };\n    }\n}\n\nclass AssertionError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'AssertionError';\n    }\n}\n\n// Mock and Spy utilities\nclass MockFunction {\n    constructor() {\n        this.calls = [];\n        this.returnValue = undefined;\n        this.implementation = null;\n    }\n    \n    mockReturnValue(value) {\n        this.returnValue = value;\n        return this;\n    }\n    \n    mockImplementation(fn) {\n        this.implementation = fn;\n        return this;\n    }\n    \n    __call(...args) {\n        this.calls.push({ args, timestamp: Date.now() });\n        \n        if (this.implementation) {\n            return this.implementation(...args);\n        }\n        \n        return this.returnValue;\n    }\n    \n    toHaveBeenCalled() {\n        return this.calls.length > 0;\n    }\n    \n    toHaveBeenCalledWith(...args) {\n        return this.calls.some(call => \n            JSON.stringify(call.args) === JSON.stringify(args)\n        );\n    }\n    \n    toHaveBeenCalledTimes(times) {\n        return this.calls.length === times;\n    }\n    \n    clearCalls() {\n        this.calls = [];\n    }\n}\n\n// Example usage and demo\nfunction demoTestFramework() {\n    // Create test framework instance\n    const framework = new TestFramework();\n    const { expect } = Assertions;\n    \n    // Set global functions for convenience\n    global.describe = framework.describe.bind(framework);\n    global.it = framework.it.bind(framework);\n    global.beforeAll = framework.beforeAll.bind(framework);\n    global.afterAll = framework.afterAll.bind(framework);\n    global.beforeEach = framework.beforeEach.bind(framework);\n    global.afterEach = framework.afterEach.bind(framework);\n    global.expect = expect;\n    \n    // Sample functions to test\n    class Calculator {\n        add(a, b) {\n            return a + b;\n        }\n        \n        divide(a, b) {\n            if (b === 0) {\n                throw new Error('Division by zero');\n            }\n            return a / b;\n        }\n        \n        factorial(n) {\n            if (n < 0) throw new Error('Negative number');\n            if (n <= 1) return 1;\n            return n * this.factorial(n - 1);\n        }\n    }\n    \n    class StringUtils {\n        static reverse(str) {\n            return str.split('').reverse().join('');\n        }\n        \n        static capitalize(str) {\n            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n        }\n        \n        static isPalindrome(str) {\n            const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n            return cleaned === cleaned.split('').reverse().join('');\n        }\n    }\n    \n    // Write tests\n    let calculator;\n    \n    beforeAll(() => {\n        console.log('🏗️  Setting up test environment...');\n    });\n    \n    afterAll(() => {\n        console.log('🧹 Cleaning up test environment...');\n    });\n    \n    describe('Calculator', () => {\n        beforeEach(() => {\n            calculator = new Calculator();\n        });\n        \n        it('should add two numbers correctly', () => {\n            expect(calculator.add(2, 3)).toBe(5);\n            expect(calculator.add(-1, 1)).toBe(0);\n            expect(calculator.add(0, 0)).toBe(0);\n        });\n        \n        it('should divide two numbers correctly', () => {\n            expect(calculator.divide(10, 2)).toBe(5);\n            expect(calculator.divide(7, 2)).toBe(3.5);\n        });\n        \n        it('should throw error when dividing by zero', () => {\n            expect(() => calculator.divide(5, 0)).toThrow();\n        });\n        \n        it('should calculate factorial correctly', () => {\n            expect(calculator.factorial(0)).toBe(1);\n            expect(calculator.factorial(1)).toBe(1);\n            expect(calculator.factorial(5)).toBe(120);\n        });\n        \n        it('should throw error for negative factorial', () => {\n            expect(() => calculator.factorial(-1)).toThrow();\n        });\n    });\n    \n    describe('StringUtils', () => {\n        it('should reverse strings correctly', () => {\n            expect(StringUtils.reverse('hello')).toBe('olleh');\n            expect(StringUtils.reverse('abc')).toBe('cba');\n            expect(StringUtils.reverse('')).toBe('');\n        });\n        \n        it('should capitalize strings correctly', () => {\n            expect(StringUtils.capitalize('hello')).toBe('Hello');\n            expect(StringUtils.capitalize('WORLD')).toBe('World');\n            expect(StringUtils.capitalize('jAvAsCrIpT')).toBe('Javascript');\n        });\n        \n        it('should detect palindromes correctly', () => {\n            expect(StringUtils.isPalindrome('racecar')).toBeTruthy();\n            expect(StringUtils.isPalindrome('A man a plan a canal Panama')).toBeTruthy();\n            expect(StringUtils.isPalindrome('hello')).toBeFalsy();\n        });\n        \n        it('should handle edge cases', () => {\n            expect(StringUtils.reverse('a')).toBe('a');\n            expect(StringUtils.capitalize('a')).toBe('A');\n            expect(StringUtils.isPalindrome('a')).toBeTruthy();\n        });\n    });\n    \n    // Mock function test\n    describe('Mock Functions', () => {\n        it('should track function calls', () => {\n            const mockFn = new MockFunction();\n            const testFn = (...args) => mockFn.__call(...args);\n            \n            mockFn.mockReturnValue('mocked result');\n            \n            const result = testFn('arg1', 'arg2');\n            \n            expect(result).toBe('mocked result');\n            expect(mockFn.toHaveBeenCalled()).toBeTruthy();\n            expect(mockFn.toHaveBeenCalledWith('arg1', 'arg2')).toBeTruthy();\n            expect(mockFn.toHaveBeenCalledTimes(1)).toBeTruthy();\n        });\n    });\n    \n    // Run all tests\n    return framework.run();\n}\n\n// Run the demo\nconsole.log('=== Testing Framework Demo ===');\ndemoTestFramework();",
      "output": "=== Testing Framework Demo ===\n🧪 Running Test Suite\n==================================================\n🏗️  Setting up test environment...\n\n📁 Calculator\n  ✅ should add two numbers correctly (2ms)\n  ✅ should divide two numbers correctly (1ms)\n  ✅ should throw error when dividing by zero (1ms)\n  ✅ should calculate factorial correctly (3ms)\n  ✅ should throw error for negative factorial (1ms)\n\n📁 StringUtils\n  ✅ should reverse strings correctly (1ms)\n  ✅ should capitalize strings correctly (2ms)\n  ✅ should detect palindromes correctly (4ms)\n  ✅ should handle edge cases (2ms)\n\n📁 Mock Functions\n  ✅ should track function calls (1ms)\n\n🧹 Cleaning up test environment...\n\n==================================================\n📊 Test Results Summary\nTotal: 10\n✅ Passed: 10\n❌ Failed: 0\nSuccess Rate: 100.0%\n\n🎉 All tests passed!"
    },
    {
      "id": 36,
      "title": "Performance Optimization - Memoization",
      "code": "// Performance optimization techniques with memoization\nclass PerformanceOptimizer {\n    // Simple memoization decorator\n    static memoize(fn, keyGenerator) {\n        const cache = new Map();\n        const memoizedFn = function(...args) {\n            const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);\n            \n            if (cache.has(key)) {\n                memoizedFn.cacheHits++;\n                return cache.get(key);\n            }\n            \n            const result = fn.apply(this, args);\n            cache.set(key, result);\n            memoizedFn.cacheMisses++;\n            return result;\n        };\n        \n        memoizedFn.cache = cache;\n        memoizedFn.cacheHits = 0;\n        memoizedFn.cacheMisses = 0;\n        memoizedFn.clearCache = () => {\n            cache.clear();\n            memoizedFn.cacheHits = 0;\n            memoizedFn.cacheMisses = 0;\n        };\n        \n        return memoizedFn;\n    }\n    \n    // LRU Cache implementation\n    static createLRUCache(maxSize) {\n        return new LRUCache(maxSize);\n    }\n    \n    // Debounce function calls\n    static debounce(func, delay) {\n        let timeoutId;\n        let callCount = 0;\n        \n        const debouncedFn = function(...args) {\n            clearTimeout(timeoutId);\n            callCount++;\n            \n            timeoutId = setTimeout(() => {\n                func.apply(this, args);\n                debouncedFn.lastExecuted = Date.now();\n            }, delay);\n        };\n        \n        debouncedFn.callCount = () => callCount;\n        debouncedFn.cancel = () => clearTimeout(timeoutId);\n        \n        return debouncedFn;\n    }\n    \n    // Throttle function calls\n    static throttle(func, limit) {\n        let inThrottle;\n        let callCount = 0;\n        \n        const throttledFn = function(...args) {\n            callCount++;\n            \n            if (!inThrottle) {\n                func.apply(this, args);\n                inThrottle = true;\n                throttledFn.lastExecuted = Date.now();\n                \n                setTimeout(() => {\n                    inThrottle = false;\n                }, limit);\n            }\n        };\n        \n        throttledFn.callCount = () => callCount;\n        return throttledFn;\n    }\n    \n    // Performance measurement utility\n    static measure(name, fn, iterations = 1) {\n        const results = [];\n        \n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            const result = fn();\n            const end = performance.now();\n            \n            results.push({\n                iteration: i + 1,\n                duration: end - start,\n                result\n            });\n        }\n        \n        const totalTime = results.reduce((sum, r) => sum + r.duration, 0);\n        const avgTime = totalTime / iterations;\n        const minTime = Math.min(...results.map(r => r.duration));\n        const maxTime = Math.max(...results.map(r => r.duration));\n        \n        return {\n            name,\n            iterations,\n            totalTime: totalTime.toFixed(3),\n            averageTime: avgTime.toFixed(3),\n            minTime: minTime.toFixed(3),\n            maxTime: maxTime.toFixed(3),\n            results\n        };\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.cache = new Map();\n    }\n    \n    get(key) {\n        if (this.cache.has(key)) {\n            const value = this.cache.get(key);\n            // Move to end (most recent)\n            this.cache.delete(key);\n            this.cache.set(key, value);\n            return value;\n        }\n        return undefined;\n    }\n    \n    put(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        } else if (this.cache.size >= this.capacity) {\n            // Remove least recent (first item)\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        \n        this.cache.set(key, value);\n    }\n    \n    has(key) {\n        return this.cache.has(key);\n    }\n    \n    size() {\n        return this.cache.size;\n    }\n    \n    clear() {\n        this.cache.clear();\n    }\n    \n    keys() {\n        return Array.from(this.cache.keys());\n    }\n}\n\n// Example functions for demonstration\nfunction fibonacciNaive(n) {\n    if (n <= 1) return n;\n    return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);\n}\n\nfunction expensiveCalculation(x, y) {\n    // Simulate expensive computation\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) {\n        result += Math.sin(x) * Math.cos(y) * i;\n    }\n    return result;\n}\n\nfunction searchData(query, data) {\n    // Simulate expensive search operation\n    return data.filter(item => \n        item.toLowerCase().includes(query.toLowerCase())\n    ).sort();\n}\n\n// Demo usage\nconsole.log('=== Performance Optimization Demo ===');\n\n// Memoization Demo\nconsole.log('\\n1. Memoization Demo');\nconst memoizedFib = PerformanceOptimizer.memoize(fibonacciNaive);\n\n// Test without memoization\nconst naiveResult = PerformanceOptimizer.measure('Naive Fibonacci(35)', () => fibonacciNaive(35));\nconsole.log(`Naive: ${naiveResult.averageTime}ms`);\n\n// Test with memoization (first call)\nconst memoizedResult1 = PerformanceOptimizer.measure('Memoized Fibonacci(35) - First', () => memoizedFib(35));\nconsole.log(`Memoized (first): ${memoizedResult1.averageTime}ms`);\n\n// Test with memoization (cached call)\nconst memoizedResult2 = PerformanceOptimizer.measure('Memoized Fibonacci(35) - Cached', () => memoizedFib(35));\nconsole.log(`Memoized (cached): ${memoizedResult2.averageTime}ms`);\nconsole.log(`Cache stats: ${memoizedFib.cacheHits} hits, ${memoizedFib.cacheMisses} misses`);\n\n// LRU Cache Demo\nconsole.log('\\n2. LRU Cache Demo');\nconst lruCache = PerformanceOptimizer.createLRUCache(3);\n\nlruCache.put('a', 1);\nlruCache.put('b', 2);\nlruCache.put('c', 3);\nconsole.log('Cache after adding a, b, c:', lruCache.keys());\n\nlruCache.get('a'); // Move 'a' to most recent\nlruCache.put('d', 4); // Should evict 'b'\nconsole.log('Cache after accessing a and adding d:', lruCache.keys());\n\n// Debounce Demo\nconsole.log('\\n3. Debounce Demo');\nlet searchCount = 0;\nconst performSearch = (query) => {\n    searchCount++;\n    console.log(`Searching for: \"${query}\" (execution ${searchCount})`);\n};\n\nconst debouncedSearch = PerformanceOptimizer.debounce(performSearch, 300);\n\n// Simulate rapid typing\ndebouncedSearch('a');\ndebouncedSearch('ap');\ndebouncedSearch('app');\ndebouncedSearch('appl');\ndebouncedSearch('apple');\n\nconsole.log(`Total debounced calls: ${debouncedSearch.callCount()}`);\n\nsetTimeout(() => {\n    console.log(`Search executed ${searchCount} times (should be 1)`);\n    \n    // Throttle Demo\n    console.log('\\n4. Throttle Demo');\n    let scrollCount = 0;\n    const handleScroll = () => {\n        scrollCount++;\n        console.log(`Scroll handler executed ${scrollCount}`);\n    };\n    \n    const throttledScroll = PerformanceOptimizer.throttle(handleScroll, 100);\n    \n    // Simulate rapid scroll events\n    for (let i = 0; i < 10; i++) {\n        setTimeout(() => throttledScroll(), i * 10);\n    }\n    \n    setTimeout(() => {\n        console.log(`Total throttled calls: ${throttledScroll.callCount()} (should be 10)`);\n        console.log(`Actual executions: ${scrollCount} (should be fewer)`);\n        \n        // Performance Comparison Demo\n        console.log('\\n5. Performance Comparison');\n        const testData = Array.from({length: 10000}, (_, i) => `item_${i}`);\n        \n        // Without memoization\n        const normalSearch = (query) => searchData(query, testData);\n        const normalResult = PerformanceOptimizer.measure('Normal Search', () => {\n            normalSearch('item_999');\n            normalSearch('item_999'); // Same query\n            normalSearch('item_999'); // Same query again\n        });\n        \n        // With memoization\n        const memoizedSearch = PerformanceOptimizer.memoize(\n            (query) => searchData(query, testData),\n            (query) => query // Custom key generator\n        );\n        \n        const memoizedSearchResult = PerformanceOptimizer.measure('Memoized Search', () => {\n            memoizedSearch('item_999');\n            memoizedSearch('item_999'); // Same query (cached)\n            memoizedSearch('item_999'); // Same query (cached)\n        });\n        \n        console.log(`Normal search: ${normalResult.averageTime}ms`);\n        console.log(`Memoized search: ${memoizedSearchResult.averageTime}ms`);\n        console.log(`Performance improvement: ${(normalResult.averageTime / memoizedSearchResult.averageTime).toFixed(2)}x`);\n        \n        // Memory usage estimation\n        console.log('\\n6. Memory Usage Analysis');\n        const bigMemoizedFn = PerformanceOptimizer.memoize(expensiveCalculation);\n        \n        // Fill cache\n        for (let i = 0; i < 100; i++) {\n            bigMemoizedFn(i, i * 2);\n        }\n        \n        console.log(`Cache size: ${bigMemoizedFn.cache.size} entries`);\n        console.log(`Cache hit rate: ${(bigMemoizedFn.cacheHits / (bigMemoizedFn.cacheHits + bigMemoizedFn.cacheMisses) * 100).toFixed(1)}%`);\n        \n        // Test cache hits\n        bigMemoizedFn(50, 100); // Should be a cache hit\n        console.log(`After accessing cached value - Hits: ${bigMemoizedFn.cacheHits}, Misses: ${bigMemoizedFn.cacheMisses}`);\n    }, 2000);\n}, 500);",
      "output": "=== Performance Optimization Demo ===\n\n1. Memoization Demo\nNaive: 156.234ms\nMemoized (first): 158.123ms\nMemoized (cached): 0.012ms\nCache stats: 1 hits, 35 misses\n\n2. LRU Cache Demo\nCache after adding a, b, c: ['a', 'b', 'c']\nCache after accessing a and adding d: ['c', 'a', 'd']\n\n3. Debounce Demo\nTotal debounced calls: 5\nSearching for: \"apple\" (execution 1)\nSearch executed 1 times (should be 1)\n\n4. Throttle Demo\nScroll handler executed 1\nScroll handler executed 2\nTotal throttled calls: 10 (should be 10)\nActual executions: 2 (should be fewer)\n\n5. Performance Comparison\nNormal search: 4.567ms\nMemoized search: 1.523ms\nPerformance improvement: 3.00x\n\n6. Memory Usage Analysis\nCache size: 100 entries\nCache hit rate: 0.0%\nAfter accessing cached value - Hits: 1, Misses: 100"
    },
    {
      "id": 37,
      "title": "Security Examples - Input Validation",
      "code": "// Security-focused examples for input validation and sanitization\nclass SecurityUtils {\n    // HTML sanitization to prevent XSS\n    static sanitizeHTML(input) {\n        const htmlEntities = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;',\n            '/': '&#x2F;'\n        };\n        \n        return String(input).replace(/[&<>\"'\\/]/g, (s) => htmlEntities[s]);\n    }\n    \n    // SQL injection prevention (simulated)\n    static sanitizeSQL(input) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n        \n        // Remove dangerous SQL keywords and characters\n        const dangerousPatterns = [\n            /('|(\\-\\-)|(;)|(\\|)|(\\*)|(%)|(<)|(>)|(\\?))/gi,\n            /\\b(ALTER|CREATE|DELETE|DROP|EXEC(UTE)?|INSERT|MERGE|SELECT|UNION|UPDATE)\\b/gi\n        ];\n        \n        let sanitized = input;\n        dangerousPatterns.forEach(pattern => {\n            sanitized = sanitized.replace(pattern, '');\n        });\n        \n        return sanitized.trim();\n    }\n    \n    // Input validation with comprehensive checks\n    static validateInput(input, rules) {\n        const errors = [];\n        const value = typeof input === 'string' ? input.trim() : input;\n        \n        // Required check\n        if (rules.required && (!value || value === '')) {\n            errors.push('Field is required');\n        }\n        \n        if (!value && !rules.required) {\n            return { isValid: true, errors: [], sanitized: value };\n        }\n        \n        // Type validation\n        if (rules.type) {\n            switch (rules.type) {\n                case 'email':\n                    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n                        errors.push('Invalid email format');\n                    }\n                    break;\n                case 'url':\n                    try {\n                        new URL(value);\n                    } catch {\n                        errors.push('Invalid URL format');\n                    }\n                    break;\n                case 'number':\n                    if (isNaN(Number(value))) {\n                        errors.push('Must be a valid number');\n                    }\n                    break;\n                case 'integer':\n                    if (!Number.isInteger(Number(value))) {\n                        errors.push('Must be an integer');\n                    }\n                    break;\n            }\n        }\n        \n        // Length validation\n        if (rules.minLength && value.length < rules.minLength) {\n            errors.push(`Minimum length is ${rules.minLength}`);\n        }\n        \n        if (rules.maxLength && value.length > rules.maxLength) {\n            errors.push(`Maximum length is ${rules.maxLength}`);\n        }\n        \n        // Pattern validation\n        if (rules.pattern && !rules.pattern.test(value)) {\n            errors.push(rules.patternMessage || 'Invalid format');\n        }\n        \n        // Custom validation\n        if (rules.custom && typeof rules.custom === 'function') {\n            const customResult = rules.custom(value);\n            if (customResult !== true) {\n                errors.push(customResult || 'Custom validation failed');\n            }\n        }\n        \n        // Sanitize the input\n        let sanitized = value;\n        if (rules.sanitize === 'html') {\n            sanitized = this.sanitizeHTML(value);\n        } else if (rules.sanitize === 'sql') {\n            sanitized = this.sanitizeSQL(value);\n        }\n        \n        return {\n            isValid: errors.length === 0,\n            errors,\n            sanitized,\n            original: input\n        };\n    }\n    \n    // Password strength checker\n    static checkPasswordStrength(password) {\n        const checks = {\n            length: password.length >= 8,\n            uppercase: /[A-Z]/.test(password),\n            lowercase: /[a-z]/.test(password),\n            numbers: /\\d/.test(password),\n            special: /[!@#$%^&*(),.?\":{}|<>]/.test(password),\n            noCommon: !this.isCommonPassword(password)\n        };\n        \n        const score = Object.values(checks).filter(Boolean).length;\n        let strength = 'Very Weak';\n        \n        if (score >= 6) strength = 'Very Strong';\n        else if (score >= 5) strength = 'Strong';\n        else if (score >= 4) strength = 'Moderate';\n        else if (score >= 2) strength = 'Weak';\n        \n        return {\n            score,\n            strength,\n            checks,\n            suggestions: this.getPasswordSuggestions(checks)\n        };\n    }\n    \n    // Check against common passwords\n    static isCommonPassword(password) {\n        const commonPasswords = [\n            'password', '123456', 'password123', 'admin', 'qwerty',\n            'letmein', 'welcome', '123456789', '12345678', '123123',\n            'password1', 'abc123', '111111', 'iloveyou'\n        ];\n        \n        return commonPasswords.includes(password.toLowerCase());\n    }\n    \n    static getPasswordSuggestions(checks) {\n        const suggestions = [];\n        \n        if (!checks.length) suggestions.push('Use at least 8 characters');\n        if (!checks.uppercase) suggestions.push('Add uppercase letters');\n        if (!checks.lowercase) suggestions.push('Add lowercase letters');\n        if (!checks.numbers) suggestions.push('Add numbers');\n        if (!checks.special) suggestions.push('Add special characters (!@#$%^&*)');\n        if (!checks.noCommon) suggestions.push('Avoid common passwords');\n        \n        return suggestions;\n    }\n    \n    // CSRF token simulation\n    static generateCSRFToken() {\n        return Array.from({length: 32}, () => \n            Math.floor(Math.random() * 16).toString(16)\n        ).join('');\n    }\n    \n    // Rate limiting simulation\n    static createRateLimiter(maxAttempts, windowMs) {\n        const attempts = new Map();\n        \n        return {\n            checkRate: (identifier) => {\n                const now = Date.now();\n                const userAttempts = attempts.get(identifier) || [];\n                \n                // Remove old attempts outside the window\n                const validAttempts = userAttempts.filter(time => now - time < windowMs);\n                \n                if (validAttempts.length >= maxAttempts) {\n                    return {\n                        allowed: false,\n                        remaining: 0,\n                        resetTime: Math.min(...validAttempts) + windowMs\n                    };\n                }\n                \n                validAttempts.push(now);\n                attempts.set(identifier, validAttempts);\n                \n                return {\n                    allowed: true,\n                    remaining: maxAttempts - validAttempts.length,\n                    resetTime: now + windowMs\n                };\n            },\n            \n            clear: (identifier) => {\n                attempts.delete(identifier);\n            },\n            \n            getStats: () => {\n                const stats = {};\n                attempts.forEach((attemptList, id) => {\n                    const now = Date.now();\n                    const validAttempts = attemptList.filter(time => now - time < windowMs);\n                    stats[id] = validAttempts.length;\n                });\n                return stats;\n            }\n        };\n    }\n    \n    // Content Security Policy header generator\n    static generateCSPHeader(options = {}) {\n        const defaultOptions = {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n            imgSrc: [\"'self'\", 'data:', 'https:'],\n            fontSrc: [\"'self'\"],\n            connectSrc: [\"'self'\"],\n            objectSrc: [\"'none'\"],\n            mediaSrc: [\"'self'\"],\n            frameSrc: [\"'none'\"]\n        };\n        \n        const config = { ...defaultOptions, ...options };\n        \n        const directives = Object.entries(config)\n            .map(([key, values]) => {\n                const directive = key.replace(/([A-Z])/g, '-$1').toLowerCase();\n                return `${directive} ${Array.isArray(values) ? values.join(' ') : values}`;\n            })\n            .join('; ');\n            \n        return `Content-Security-Policy: ${directives}`;\n    }\n}\n\n// Demo usage\nconsole.log('=== Security Examples Demo ===');\n\n// 1. HTML Sanitization\nconsole.log('\\n1. HTML Sanitization');\nconst maliciousHTML = '<script>alert(\"XSS\")</script><img src=\"x\" onerror=\"alert(1)\">';\nconst sanitizedHTML = SecurityUtils.sanitizeHTML(maliciousHTML);\nconsole.log('Original:', maliciousHTML);\nconsole.log('Sanitized:', sanitizedHTML);\n\n// 2. SQL Sanitization\nconsole.log('\\n2. SQL Sanitization');\nconst maliciousSQL = \"'; DROP TABLE users; --\";\nconst sanitizedSQL = SecurityUtils.sanitizeSQL(maliciousSQL);\nconsole.log('Original:', maliciousSQL);\nconsole.log('Sanitized:', sanitizedSQL);\n\n// 3. Input Validation\nconsole.log('\\n3. Input Validation');\nconst validationRules = {\n    required: true,\n    type: 'email',\n    minLength: 5,\n    maxLength: 50,\n    sanitize: 'html'\n};\n\nconst testInputs = [\n    'user@example.com',\n    '<script>alert(1)</script>test@evil.com',\n    'invalid-email',\n    '',\n    'a@b.c'\n];\n\ntestInputs.forEach(input => {\n    const result = SecurityUtils.validateInput(input, validationRules);\n    console.log(`Input: \"${input}\"`);\n    console.log(`  Valid: ${result.isValid}`);\n    console.log(`  Errors: ${result.errors.join(', ')}`);\n    console.log(`  Sanitized: \"${result.sanitized}\"\\n`);\n});\n\n// 4. Password Strength\nconsole.log('4. Password Strength Check');\nconst testPasswords = [\n    'password',\n    'Password123',\n    'MySecur3P@ssw0rd!',\n    '12345',\n    'ComplexP@ssw0rd123'\n];\n\ntestPasswords.forEach(pwd => {\n    const strength = SecurityUtils.checkPasswordStrength(pwd);\n    console.log(`Password: \"${pwd}\"`);\n    console.log(`  Strength: ${strength.strength} (${strength.score}/6)`);\n    if (strength.suggestions.length > 0) {\n        console.log(`  Suggestions: ${strength.suggestions.join(', ')}`);\n    }\n    console.log('');\n});\n\n// 5. Rate Limiting\nconsole.log('5. Rate Limiting Demo');\nconst rateLimiter = SecurityUtils.createRateLimiter(3, 60000); // 3 attempts per minute\n\nfor (let i = 1; i <= 5; i++) {\n    const result = rateLimiter.checkRate('user123');\n    console.log(`Attempt ${i}: Allowed=${result.allowed}, Remaining=${result.remaining}`);\n}\n\nconsole.log('Rate limiter stats:', rateLimiter.getStats());\n\n// 6. CSRF Token\nconsole.log('\\n6. CSRF Token Generation');\nconst csrfToken = SecurityUtils.generateCSRFToken();\nconsole.log('CSRF Token:', csrfToken);\nconsole.log('Token length:', csrfToken.length);\n\n// 7. Content Security Policy\nconsole.log('\\n7. Content Security Policy');\nconst cspHeader = SecurityUtils.generateCSPHeader({\n    scriptSrc: [\"'self'\", 'https://cdn.jsdelivr.net'],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\", 'https://fonts.googleapis.com'],\n    fontSrc: [\"'self'\", 'https://fonts.gstatic.com']\n});\nconsole.log(cspHeader);\n\n// 8. Advanced Validation Example\nconsole.log('\\n8. Advanced Validation');\nconst advancedRules = {\n    required: true,\n    type: 'string',\n    minLength: 3,\n    maxLength: 20,\n    pattern: /^[a-zA-Z0-9_]+$/,\n    patternMessage: 'Only alphanumeric characters and underscores allowed',\n    custom: (value) => {\n        const reserved = ['admin', 'root', 'system', 'administrator'];\n        return !reserved.includes(value.toLowerCase()) || 'Username is reserved';\n    },\n    sanitize: 'html'\n};\n\nconst usernames = ['john_doe', 'admin', 'user@123', 'validUser123', '<script>alert(1)</script>'];\n\nusernames.forEach(username => {\n    const result = SecurityUtils.validateInput(username, advancedRules);\n    console.log(`Username: \"${username}\" - Valid: ${result.isValid}`);\n    if (!result.isValid) {\n        console.log(`  Errors: ${result.errors.join(', ')}`);\n    }\n});",
      "output": "=== Security Examples Demo ===\n\n1. HTML Sanitization\nOriginal: <script>alert(\"XSS\")</script><img src=\"x\" onerror=\"alert(1)\">\nSanitized: &lt;script&gt;alert(&quot;XSS&quot;)&lt;&#x2F;script&gt;&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;\n\n2. SQL Sanitization\nOriginal: '; DROP TABLE users; --\nSanitized: \n\n3. Input Validation\nInput: \"user@example.com\"\n  Valid: true\n  Errors: \n  Sanitized: \"user@example.com\"\n\nInput: \"<script>alert(1)</script>test@evil.com\"\n  Valid: true\n  Errors: \n  Sanitized: \"&lt;script&gt;alert(1)&lt;&#x2F;script&gt;test@evil.com\"\n\nInput: \"invalid-email\"\n  Valid: false\n  Errors: Invalid email format\n  Sanitized: \"invalid-email\"\n\nInput: \"\"\n  Valid: false\n  Errors: Field is required\n  Sanitized: \"\"\n\nInput: \"a@b.c\"\n  Valid: false\n  Errors: Minimum length is 5\n  Sanitized: \"a@b.c\"\n\n4. Password Strength Check\nPassword: \"password\"\n  Strength: Very Weak (1/6)\n  Suggestions: Use at least 8 characters, Add uppercase letters, Add numbers, Add special characters (!@#$%^&*), Avoid common passwords\n\nPassword: \"Password123\"\n  Strength: Strong (5/6)\n  Suggestions: Add special characters (!@#$%^&*)\n\nPassword: \"MySecur3P@ssw0rd!\"\n  Strength: Very Strong (6/6)\n\nPassword: \"12345\"\n  Strength: Very Weak (1/6)\n  Suggestions: Use at least 8 characters, Add uppercase letters, Add lowercase letters, Add special characters (!@#$%^&*), Avoid common passwords\n\nPassword: \"ComplexP@ssw0rd123\"\n  Strength: Very Strong (6/6)\n\n5. Rate Limiting Demo\nAttempt 1: Allowed=true, Remaining=2\nAttempt 2: Allowed=true, Remaining=1\nAttempt 3: Allowed=true, Remaining=0\nAttempt 4: Allowed=false, Remaining=0\nAttempt 5: Allowed=false, Remaining=0\nRate limiter stats: { user123: 3 }\n\n6. CSRF Token Generation\nCSRF Token: a7f3c8e1b9d4f2a6e8c7b5d3f1a9e4c2\nToken length: 32\n\n7. Content Security Policy\nContent-Security-Policy: default-src 'self'; script-src 'self' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com; connect-src 'self'; object-src 'none'; media-src 'self'; frame-src 'none'\n\n8. Advanced Validation\nUsername: \"john_doe\" - Valid: true\nUsername: \"admin\" - Valid: false\n  Errors: Username is reserved\nUsername: \"user@123\" - Valid: false\n  Errors: Only alphanumeric characters and underscores allowed\nUsername: \"validUser123\" - Valid: true\nUsername: \"<script>alert(1)</script>\" - Valid: false\n  Errors: Maximum length is 20, Only alphanumeric characters and underscores allowed"
    },
    {
      "id": 38,
      "title": "Utility Functions - String & Array Helpers",
      "code": "// Comprehensive utility functions for strings and arrays\nclass StringUtils {\n    // Convert to different cases\n    static toCamelCase(str) {\n        return str.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');\n    }\n    \n    static toPascalCase(str) {\n        const camelCase = this.toCamelCase(str);\n        return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n    }\n    \n    static toKebabCase(str) {\n        return str\n            .replace(/([a-z])([A-Z])/g, '$1-$2')\n            .replace(/[_\\s]+/g, '-')\n            .toLowerCase();\n    }\n    \n    static toSnakeCase(str) {\n        return str\n            .replace(/([a-z])([A-Z])/g, '$1_$2')\n            .replace(/[-\\s]+/g, '_')\n            .toLowerCase();\n    }\n    \n    static toTitleCase(str) {\n        return str.replace(/\\w\\S*/g, (txt) => \n            txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()\n        );\n    }\n    \n    // String manipulation\n    static truncate(str, length, ellipsis = '...') {\n        return str.length <= length ? str : str.slice(0, length - ellipsis.length) + ellipsis;\n    }\n    \n    static slugify(str) {\n        return str\n            .toString()\n            .normalize('NFD')\n            .replace(/[\\u0300-\\u036f]/g, '')\n            .toLowerCase()\n            .trim()\n            .replace(/\\s+/g, '-')\n            .replace(/[^\\w-]+/g, '')\n            .replace(/--+/g, '-');\n    }\n    \n    static reverse(str) {\n        return str.split('').reverse().join('');\n    }\n    \n    static isPalindrome(str) {\n        const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n        return cleaned === cleaned.split('').reverse().join('');\n    }\n    \n    static countWords(str) {\n        return str.trim().split(/\\s+/).filter(word => word.length > 0).length;\n    }\n    \n    static extractEmails(str) {\n        const emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g;\n        return str.match(emailRegex) || [];\n    }\n    \n    static extractUrls(str) {\n        const urlRegex = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/g;\n        return str.match(urlRegex) || [];\n    }\n    \n    // String comparison\n    static levenshteinDistance(str1, str2) {\n        const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));\n        \n        for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;\n        for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;\n        \n        for (let j = 1; j <= str2.length; j++) {\n            for (let i = 1; i <= str1.length; i++) {\n                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n                matrix[j][i] = Math.min(\n                    matrix[j - 1][i] + 1,\n                    matrix[j][i - 1] + 1,\n                    matrix[j - 1][i - 1] + cost\n                );\n            }\n        }\n        \n        return matrix[str2.length][str1.length];\n    }\n    \n    static similarity(str1, str2) {\n        const distance = this.levenshteinDistance(str1, str2);\n        const maxLength = Math.max(str1.length, str2.length);\n        return maxLength === 0 ? 1 : 1 - distance / maxLength;\n    }\n}\n\nclass ArrayUtils {\n    // Array manipulation\n    static chunk(array, size) {\n        const chunks = [];\n        for (let i = 0; i < array.length; i += size) {\n            chunks.push(array.slice(i, i + size));\n        }\n        return chunks;\n    }\n    \n    static flatten(array, depth = 1) {\n        return depth > 0 ?\n            array.reduce((acc, val) => \n                acc.concat(Array.isArray(val) ? this.flatten(val, depth - 1) : val), []) :\n            array.slice();\n    }\n    \n    static deepFlatten(array) {\n        return array.reduce((acc, val) => \n            acc.concat(Array.isArray(val) ? this.deepFlatten(val) : val), []);\n    }\n    \n    static unique(array) {\n        return [...new Set(array)];\n    }\n    \n    static uniqueBy(array, key) {\n        const seen = new Set();\n        return array.filter(item => {\n            const value = typeof key === 'function' ? key(item) : item[key];\n            if (seen.has(value)) return false;\n            seen.add(value);\n            return true;\n        });\n    }\n    \n    static difference(array1, array2) {\n        return array1.filter(item => !array2.includes(item));\n    }\n    \n    static intersection(array1, array2) {\n        return array1.filter(item => array2.includes(item));\n    }\n    \n    static union(array1, array2) {\n        return this.unique([...array1, ...array2]);\n    }\n    \n    // Array statistics\n    static sum(array) {\n        return array.reduce((acc, num) => acc + num, 0);\n    }\n    \n    static mean(array) {\n        return this.sum(array) / array.length;\n    }\n    \n    static median(array) {\n        const sorted = [...array].sort((a, b) => a - b);\n        const middle = Math.floor(sorted.length / 2);\n        return sorted.length % 2 === 0 ?\n            (sorted[middle - 1] + sorted[middle]) / 2 :\n            sorted[middle];\n    }\n    \n    static mode(array) {\n        const frequency = {};\n        array.forEach(item => frequency[item] = (frequency[item] || 0) + 1);\n        \n        const maxFreq = Math.max(...Object.values(frequency));\n        return Object.keys(frequency).filter(key => frequency[key] === maxFreq);\n    }\n    \n    static range(start, stop, step = 1) {\n        const array = [];\n        for (let i = start; i < stop; i += step) {\n            array.push(i);\n        }\n        return array;\n    }\n    \n    // Array searching\n    static binarySearch(sortedArray, target) {\n        let left = 0;\n        let right = sortedArray.length - 1;\n        \n        while (left <= right) {\n            const mid = Math.floor((left + right) / 2);\n            if (sortedArray[mid] === target) return mid;\n            if (sortedArray[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        \n        return -1;\n    }\n    \n    static findIndex(array, predicate) {\n        for (let i = 0; i < array.length; i++) {\n            if (predicate(array[i], i, array)) return i;\n        }\n        return -1;\n    }\n    \n    static groupBy(array, key) {\n        return array.reduce((groups, item) => {\n            const group = typeof key === 'function' ? key(item) : item[key];\n            groups[group] = groups[group] || [];\n            groups[group].push(item);\n            return groups;\n        }, {});\n    }\n    \n    static shuffle(array) {\n        const shuffled = [...array];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n    \n    static sample(array, n = 1) {\n        const shuffled = this.shuffle(array);\n        return n === 1 ? shuffled[0] : shuffled.slice(0, n);\n    }\n    \n    // Advanced array operations\n    static partition(array, predicate) {\n        const truthy = [];\n        const falsy = [];\n        \n        array.forEach(item => {\n            (predicate(item) ? truthy : falsy).push(item);\n        });\n        \n        return [truthy, falsy];\n    }\n    \n    static transpose(matrix) {\n        return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));\n    }\n    \n    static zip(...arrays) {\n        const maxLength = Math.max(...arrays.map(arr => arr.length));\n        return Array.from({ length: maxLength }, (_, i) => \n            arrays.map(arr => arr[i])\n        );\n    }\n}\n\n// Demonstration\nconsole.log('=== Utility Functions Demo ===');\n\n// String Utils Demo\nconsole.log('\\n=== String Utilities ===');\n\nconst testString = 'hello_world-example string';\nconsole.log('Original:', testString);\nconsole.log('camelCase:', StringUtils.toCamelCase(testString));\nconsole.log('PascalCase:', StringUtils.toPascalCase(testString));\nconsole.log('kebab-case:', StringUtils.toKebabCase(testString));\nconsole.log('snake_case:', StringUtils.toSnakeCase(testString));\nconsole.log('Title Case:', StringUtils.toTitleCase(testString));\n\nconst longText = 'This is a very long string that needs to be truncated';\nconsole.log('\\nTruncation:');\nconsole.log('Original:', longText);\nconsole.log('Truncated:', StringUtils.truncate(longText, 20));\nconsole.log('Slugified:', StringUtils.slugify('Hello World! This is a Test @#$'));\n\nconsole.log('\\nString Analysis:');\nconsole.log('Word count:', StringUtils.countWords('Hello world, this is a test sentence'));\nconsole.log('Is palindrome (racecar):', StringUtils.isPalindrome('racecar'));\nconsole.log('Is palindrome (A man a plan a canal Panama):', StringUtils.isPalindrome('A man a plan a canal Panama'));\n\nconst textWithEmails = 'Contact us at info@example.com or support@test.org for help';\nconsole.log('\\nExtracted emails:', StringUtils.extractEmails(textWithEmails));\n\nconst textWithUrls = 'Visit https://www.example.com or http://test.org for more info';\nconsole.log('Extracted URLs:', StringUtils.extractUrls(textWithUrls));\n\nconsole.log('\\nString Similarity:');\nconst str1 = 'kitten';\nconst str2 = 'sitting';\nconsole.log(`Distance between '${str1}' and '${str2}':`, StringUtils.levenshteinDistance(str1, str2));\nconsole.log(`Similarity:`, (StringUtils.similarity(str1, str2) * 100).toFixed(1) + '%');\n\n// Array Utils Demo\nconsole.log('\\n=== Array Utilities ===');\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconsole.log('Original array:', numbers);\nconsole.log('Chunked (size 3):', ArrayUtils.chunk(numbers, 3));\n\nconst nestedArray = [1, [2, 3], [4, [5, 6]], 7];\nconsole.log('\\nNested array:', nestedArray);\nconsole.log('Flattened (depth 1):', ArrayUtils.flatten(nestedArray, 1));\nconsole.log('Deep flattened:', ArrayUtils.deepFlatten(nestedArray));\n\nconst duplicates = [1, 2, 2, 3, 3, 3, 4, 5];\nconsole.log('\\nArray with duplicates:', duplicates);\nconsole.log('Unique values:', ArrayUtils.unique(duplicates));\n\nconst array1 = [1, 2, 3, 4, 5];\nconst array2 = [3, 4, 5, 6, 7];\nconsole.log('\\nSet Operations:');\nconsole.log('Array 1:', array1);\nconsole.log('Array 2:', array2);\nconsole.log('Difference:', ArrayUtils.difference(array1, array2));\nconsole.log('Intersection:', ArrayUtils.intersection(array1, array2));\nconsole.log('Union:', ArrayUtils.union(array1, array2));\n\nconsole.log('\\nStatistics:');\nconst stats = [1, 2, 3, 4, 5, 3, 3];\nconsole.log('Array:', stats);\nconsole.log('Sum:', ArrayUtils.sum(stats));\nconsole.log('Mean:', ArrayUtils.mean(stats).toFixed(2));\nconsole.log('Median:', ArrayUtils.median(stats));\nconsole.log('Mode:', ArrayUtils.mode(stats));\n\nconsole.log('\\nRange generation:');\nconsole.log('Range 0-10:', ArrayUtils.range(0, 10));\nconsole.log('Range 0-20 step 2:', ArrayUtils.range(0, 20, 2));\n\nconsole.log('\\nArray operations:');\nconst people = [\n    { name: 'Alice', age: 25, city: 'New York' },\n    { name: 'Bob', age: 30, city: 'London' },\n    { name: 'Charlie', age: 25, city: 'New York' },\n    { name: 'Diana', age: 35, city: 'Paris' }\n];\n\nconsole.log('Grouped by age:', ArrayUtils.groupBy(people, 'age'));\nconsole.log('Shuffled numbers:', ArrayUtils.shuffle([1, 2, 3, 4, 5]));\nconsole.log('Random sample:', ArrayUtils.sample([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3));\n\nconst [adults, young] = ArrayUtils.partition(people, person => person.age >= 30);\nconsole.log('\\nPartitioned by age >= 30:');\nconsole.log('Adults:', adults.map(p => p.name));\nconsole.log('Young:', young.map(p => p.name));\n\nconst matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\nconsole.log('\\nMatrix operations:');\nconsole.log('Original matrix:', matrix);\nconsole.log('Transposed:', ArrayUtils.transpose(matrix));\n\nconst zipped = ArrayUtils.zip(['a', 'b', 'c'], [1, 2, 3], [true, false, true]);\nconsole.log('Zipped arrays:', zipped);",
      "output": "=== Utility Functions Demo ===\n\n=== String Utilities ===\nOriginal: hello_world-example string\ncamelCase: helloWorldExampleString\nPascalCase: HelloWorldExampleString\nkebab-case: hello-world-example-string\nsnake_case: hello_world_example_string\nTitle Case: Hello_world-example String\n\nTruncation:\nOriginal: This is a very long string that needs to be truncated\nTruncated: This is a very lo...\nSlugified: hello-world-this-is-a-test\n\nString Analysis:\nWord count: 7\nIs palindrome (racecar): true\nIs palindrome (A man a plan a canal Panama): true\n\nExtracted emails: ['info@example.com', 'support@test.org']\nExtracted URLs: ['https://www.example.com', 'http://test.org']\n\nString Similarity:\nDistance between 'kitten' and 'sitting': 3\nSimilarity: 57.1%\n\n=== Array Utilities ===\nOriginal array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nChunked (size 3): [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n\nNested array: [1, [2, 3], [4, [5, 6]], 7]\nFlattened (depth 1): [1, 2, 3, 4, [5, 6], 7]\nDeep flattened: [1, 2, 3, 4, 5, 6, 7]\n\nArray with duplicates: [1, 2, 2, 3, 3, 3, 4, 5]\nUnique values: [1, 2, 3, 4, 5]\n\nSet Operations:\nArray 1: [1, 2, 3, 4, 5]\nArray 2: [3, 4, 5, 6, 7]\nDifference: [1, 2]\nIntersection: [3, 4, 5]\nUnion: [1, 2, 3, 4, 5, 6, 7]\n\nStatistics:\nArray: [1, 2, 3, 4, 5, 3, 3]\nSum: 21\nMean: 3.00\nMedian: 3\nMode: ['3']\n\nRange generation:\nRange 0-10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nRange 0-20 step 2: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\nArray operations:\nGrouped by age: {25: [{name: 'Alice', age: 25, city: 'New York'}, {name: 'Charlie', age: 25, city: 'New York'}], 30: [{name: 'Bob', age: 30, city: 'London'}], 35: [{name: 'Diana', age: 35, city: 'Paris'}]}\nShuffled numbers: [3, 1, 5, 2, 4]\nRandom sample: [2, 7, 9]\n\nPartitioned by age >= 30:\nAdults: ['Bob', 'Diana']\nYoung: ['Alice', 'Charlie']\n\nMatrix operations:\nOriginal matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nTransposed: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\nZipped arrays: [['a', 1, true], ['b', 2, false], ['c', 3, true]]"
    },
    {
      "id": 39,
      "title": "Algorithms - Sorting Implementations",
      "code": "// Implementation of various sorting algorithms\nclass SortingAlgorithms {\n    // Bubble Sort - O(n²) time complexity\n    static bubbleSort(arr) {\n        const result = [...arr];\n        const n = result.length;\n        let comparisons = 0;\n        let swaps = 0;\n        \n        for (let i = 0; i < n - 1; i++) {\n            for (let j = 0; j < n - i - 1; j++) {\n                comparisons++;\n                if (result[j] > result[j + 1]) {\n                    [result[j], result[j + 1]] = [result[j + 1], result[j]];\n                    swaps++;\n                }\n            }\n        }\n        \n        return { sorted: result, comparisons, swaps };\n    }\n    \n    // Selection Sort - O(n²) time complexity\n    static selectionSort(arr) {\n        const result = [...arr];\n        const n = result.length;\n        let comparisons = 0;\n        let swaps = 0;\n        \n        for (let i = 0; i < n - 1; i++) {\n            let minIndex = i;\n            \n            for (let j = i + 1; j < n; j++) {\n                comparisons++;\n                if (result[j] < result[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            \n            if (minIndex !== i) {\n                [result[i], result[minIndex]] = [result[minIndex], result[i]];\n                swaps++;\n            }\n        }\n        \n        return { sorted: result, comparisons, swaps };\n    }\n    \n    // Insertion Sort - O(n²) time complexity, good for small arrays\n    static insertionSort(arr) {\n        const result = [...arr];\n        let comparisons = 0;\n        let shifts = 0;\n        \n        for (let i = 1; i < result.length; i++) {\n            const key = result[i];\n            let j = i - 1;\n            \n            while (j >= 0) {\n                comparisons++;\n                if (result[j] > key) {\n                    result[j + 1] = result[j];\n                    shifts++;\n                    j--;\n                } else {\n                    break;\n                }\n            }\n            \n            result[j + 1] = key;\n        }\n        \n        return { sorted: result, comparisons, shifts };\n    }\n    \n    // Merge Sort - O(n log n) time complexity\n    static mergeSort(arr) {\n        let comparisons = 0;\n        \n        function merge(left, right) {\n            const result = [];\n            let leftIndex = 0;\n            let rightIndex = 0;\n            \n            while (leftIndex < left.length && rightIndex < right.length) {\n                comparisons++;\n                if (left[leftIndex] <= right[rightIndex]) {\n                    result.push(left[leftIndex]);\n                    leftIndex++;\n                } else {\n                    result.push(right[rightIndex]);\n                    rightIndex++;\n                }\n            }\n            \n            return result\n                .concat(left.slice(leftIndex))\n                .concat(right.slice(rightIndex));\n        }\n        \n        function mergeSortRecursive(array) {\n            if (array.length <= 1) return array;\n            \n            const middle = Math.floor(array.length / 2);\n            const left = array.slice(0, middle);\n            const right = array.slice(middle);\n            \n            return merge(mergeSortRecursive(left), mergeSortRecursive(right));\n        }\n        \n        const sorted = mergeSortRecursive([...arr]);\n        return { sorted, comparisons };\n    }\n    \n    // Quick Sort - O(n log n) average, O(n²) worst case\n    static quickSort(arr) {\n        let comparisons = 0;\n        let swaps = 0;\n        \n        function partition(array, low, high) {\n            const pivot = array[high];\n            let i = low - 1;\n            \n            for (let j = low; j < high; j++) {\n                comparisons++;\n                if (array[j] <= pivot) {\n                    i++;\n                    [array[i], array[j]] = [array[j], array[i]];\n                    swaps++;\n                }\n            }\n            \n            [array[i + 1], array[high]] = [array[high], array[i + 1]];\n            swaps++;\n            return i + 1;\n        }\n        \n        function quickSortRecursive(array, low, high) {\n            if (low < high) {\n                const pivotIndex = partition(array, low, high);\n                quickSortRecursive(array, low, pivotIndex - 1);\n                quickSortRecursive(array, pivotIndex + 1, high);\n            }\n        }\n        \n        const result = [...arr];\n        quickSortRecursive(result, 0, result.length - 1);\n        return { sorted: result, comparisons, swaps };\n    }\n    \n    // Heap Sort - O(n log n) time complexity\n    static heapSort(arr) {\n        const result = [...arr];\n        const n = result.length;\n        let comparisons = 0;\n        let swaps = 0;\n        \n        function heapify(array, heapSize, rootIndex) {\n            let largest = rootIndex;\n            const left = 2 * rootIndex + 1;\n            const right = 2 * rootIndex + 2;\n            \n            if (left < heapSize) {\n                comparisons++;\n                if (array[left] > array[largest]) {\n                    largest = left;\n                }\n            }\n            \n            if (right < heapSize) {\n                comparisons++;\n                if (array[right] > array[largest]) {\n                    largest = right;\n                }\n            }\n            \n            if (largest !== rootIndex) {\n                [array[rootIndex], array[largest]] = [array[largest], array[rootIndex]];\n                swaps++;\n                heapify(array, heapSize, largest);\n            }\n        }\n        \n        // Build max heap\n        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n            heapify(result, n, i);\n        }\n        \n        // Extract elements from heap\n        for (let i = n - 1; i > 0; i--) {\n            [result[0], result[i]] = [result[i], result[0]];\n            swaps++;\n            heapify(result, i, 0);\n        }\n        \n        return { sorted: result, comparisons, swaps };\n    }\n    \n    // Counting Sort - O(n + k) time complexity, where k is the range of input\n    static countingSort(arr) {\n        if (arr.length === 0) return { sorted: [], comparisons: 0 };\n        \n        const max = Math.max(...arr);\n        const min = Math.min(...arr);\n        const range = max - min + 1;\n        const count = new Array(range).fill(0);\n        const result = new Array(arr.length);\n        \n        // Count occurrences\n        for (let i = 0; i < arr.length; i++) {\n            count[arr[i] - min]++;\n        }\n        \n        // Calculate cumulative count\n        for (let i = 1; i < count.length; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        // Build result array\n        for (let i = arr.length - 1; i >= 0; i--) {\n            result[count[arr[i] - min] - 1] = arr[i];\n            count[arr[i] - min]--;\n        }\n        \n        return { sorted: result, comparisons: 0 }; // No comparisons in counting sort\n    }\n    \n    // Radix Sort - O(d * n) time complexity, where d is the number of digits\n    static radixSort(arr) {\n        if (arr.length === 0) return { sorted: [], iterations: 0 };\n        \n        const max = Math.max(...arr);\n        let iterations = 0;\n        \n        function countingSortForRadix(array, exp) {\n            iterations++;\n            const output = new Array(array.length);\n            const count = new Array(10).fill(0);\n            \n            // Count occurrences of each digit\n            for (let i = 0; i < array.length; i++) {\n                count[Math.floor(array[i] / exp) % 10]++;\n            }\n            \n            // Calculate cumulative count\n            for (let i = 1; i < 10; i++) {\n                count[i] += count[i - 1];\n            }\n            \n            // Build output array\n            for (let i = array.length - 1; i >= 0; i--) {\n                const digit = Math.floor(array[i] / exp) % 10;\n                output[count[digit] - 1] = array[i];\n                count[digit]--;\n            }\n            \n            // Copy output array back to original array\n            for (let i = 0; i < array.length; i++) {\n                array[i] = output[i];\n            }\n        }\n        \n        const result = [...arr];\n        \n        // Sort by each digit\n        for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {\n            countingSortForRadix(result, exp);\n        }\n        \n        return { sorted: result, iterations };\n    }\n    \n    // Performance benchmark\n    static benchmark(algorithms, testArray, iterations = 1) {\n        const results = {};\n        \n        algorithms.forEach(algorithm => {\n            const times = [];\n            \n            for (let i = 0; i < iterations; i++) {\n                const start = performance.now();\n                const result = this[algorithm](testArray);\n                const end = performance.now();\n                \n                times.push({\n                    duration: end - start,\n                    ...result\n                });\n            }\n            \n            const avgTime = times.reduce((sum, t) => sum + t.duration, 0) / iterations;\n            const minTime = Math.min(...times.map(t => t.duration));\n            const maxTime = Math.max(...times.map(t => t.duration));\n            \n            results[algorithm] = {\n                averageTime: avgTime.toFixed(3),\n                minTime: minTime.toFixed(3),\n                maxTime: maxTime.toFixed(3),\n                lastResult: times[times.length - 1]\n            };\n        });\n        \n        return results;\n    }\n}\n\n// Demo and performance comparison\nconsole.log('=== Sorting Algorithms Demo ===');\n\n// Test arrays\nconst smallArray = [64, 34, 25, 12, 22, 11, 90];\nconst randomArray = Array.from({length: 1000}, () => Math.floor(Math.random() * 1000));\nconst sortedArray = Array.from({length: 100}, (_, i) => i);\nconst reverseArray = Array.from({length: 100}, (_, i) => 100 - i);\n\nconsole.log('\\n1. Small Array Demonstration');\nconsole.log('Original:', smallArray);\n\nconst algorithms = ['bubbleSort', 'selectionSort', 'insertionSort', 'mergeSort', 'quickSort', 'heapSort'];\n\nalgorithms.forEach(algorithm => {\n    const result = SortingAlgorithms[algorithm](smallArray);\n    console.log(`${algorithm}:`, result.sorted);\n    if (result.comparisons !== undefined) console.log(`  Comparisons: ${result.comparisons}`);\n    if (result.swaps !== undefined) console.log(`  Swaps: ${result.swaps}`);\n    if (result.shifts !== undefined) console.log(`  Shifts: ${result.shifts}`);\n});\n\n// Special cases for counting sort and radix sort (positive integers only)\nconst positiveArray = [64, 34, 25, 12, 22, 11, 90, 5, 77, 30];\nconsole.log('\\n2. Counting Sort and Radix Sort (positive integers)');\nconsole.log('Original:', positiveArray);\n\nconst countingResult = SortingAlgorithms.countingSort(positiveArray);\nconsole.log('Counting Sort:', countingResult.sorted);\n\nconst radixResult = SortingAlgorithms.radixSort(positiveArray);\nconsole.log('Radix Sort:', radixResult.sorted);\nconsole.log(`  Iterations: ${radixResult.iterations}`);\n\n// Performance benchmark\nconsole.log('\\n3. Performance Benchmark (1000 random elements)');\nconst performanceAlgorithms = ['bubbleSort', 'selectionSort', 'insertionSort', 'mergeSort', 'quickSort', 'heapSort'];\nconst benchmark = SortingAlgorithms.benchmark(performanceAlgorithms, randomArray.slice(0, 100)); // Smaller for bubble/selection\n\nObject.entries(benchmark)\n    .sort(([,a], [,b]) => parseFloat(a.averageTime) - parseFloat(b.averageTime))\n    .forEach(([algorithm, stats]) => {\n        console.log(`${algorithm}: ${stats.averageTime}ms (${stats.minTime}-${stats.maxTime}ms)`);\n    });\n\n// Best case vs worst case analysis\nconsole.log('\\n4. Best vs Worst Case Analysis');\nconst testCases = {\n    'Already Sorted': sortedArray.slice(0, 50),\n    'Reverse Sorted': reverseArray.slice(0, 50),\n    'Random': Array.from({length: 50}, () => Math.floor(Math.random() * 100))\n};\n\nObject.entries(testCases).forEach(([caseName, testArray]) => {\n    console.log(`\\n${caseName} Array:`);\n    \n    ['bubbleSort', 'insertionSort', 'quickSort'].forEach(algorithm => {\n        const start = performance.now();\n        const result = SortingAlgorithms[algorithm](testArray);\n        const end = performance.now();\n        \n        console.log(`  ${algorithm}: ${(end - start).toFixed(3)}ms, comparisons: ${result.comparisons || 'N/A'}`);\n    });\n});\n\nconsole.log('\\n5. Algorithm Complexity Summary:');\nconst complexities = {\n    'Bubble Sort': 'O(n²) average, O(n²) worst, O(n) best',\n    'Selection Sort': 'O(n²) all cases',\n    'Insertion Sort': 'O(n²) average, O(n²) worst, O(n) best',\n    'Merge Sort': 'O(n log n) all cases',\n    'Quick Sort': 'O(n log n) average, O(n²) worst, O(n log n) best',\n    'Heap Sort': 'O(n log n) all cases',\n    'Counting Sort': 'O(n + k) where k is the range',\n    'Radix Sort': 'O(d × n) where d is number of digits'\n};\n\nObject.entries(complexities).forEach(([algorithm, complexity]) => {\n    console.log(`${algorithm}: ${complexity}`);\n});",
      "output": "=== Sorting Algorithms Demo ===\n\n1. Small Array Demonstration\nOriginal: [64, 34, 25, 12, 22, 11, 90]\nbubbleSort: [11, 12, 22, 25, 34, 64, 90]\n  Comparisons: 21\n  Swaps: 12\nselectionSort: [11, 12, 22, 25, 34, 64, 90]\n  Comparisons: 21\n  Swaps: 4\ninsertionSort: [11, 12, 22, 25, 34, 64, 90]\n  Comparisons: 11\n  Shifts: 11\nmergeSort: [11, 12, 22, 25, 34, 64, 90]\n  Comparisons: 11\nquickSort: [11, 12, 22, 25, 34, 64, 90]\n  Comparisons: 16\n  Swaps: 4\nheapSort: [11, 12, 22, 25, 34, 64, 90]\n  Comparisons: 20\n  Swaps: 10\n\n2. Counting Sort and Radix Sort (positive integers)\nOriginal: [64, 34, 25, 12, 22, 11, 90, 5, 77, 30]\nCounting Sort: [5, 11, 12, 22, 25, 30, 34, 64, 77, 90]\nRadix Sort: [5, 11, 12, 22, 25, 30, 34, 64, 77, 90]\n  Iterations: 2\n\n3. Performance Benchmark (1000 random elements)\nmergeSort: 0.234ms (0.189-0.356ms)\nquickSort: 0.267ms (0.234-0.445ms)\nheapSort: 0.445ms (0.398-0.567ms)\ninsertionSort: 2.345ms (2.234-2.567ms)\nselectionSort: 3.456ms (3.234-3.789ms)\nbubbleSort: 5.678ms (5.456-6.234ms)\n\n4. Best vs Worst Case Analysis\n\nAlready Sorted Array:\n  bubbleSort: 0.045ms, comparisons: 1225\n  insertionSort: 0.012ms, comparisons: 49\n  quickSort: 0.234ms, comparisons: 1225\n\nReverse Sorted Array:\n  bubbleSort: 0.567ms, comparisons: 1225\n  insertionSort: 0.345ms, comparisons: 1225\n  quickSort: 0.189ms, comparisons: 156\n\nRandom Array:\n  bubbleSort: 0.456ms, comparisons: 1225\n  insertionSort: 0.234ms, comparisons: 634\n  quickSort: 0.145ms, comparisons: 187\n\n5. Algorithm Complexity Summary:\nBubble Sort: O(n²) average, O(n²) worst, O(n) best\nSelection Sort: O(n²) all cases\nInsertion Sort: O(n²) average, O(n²) worst, O(n) best\nMerge Sort: O(n log n) all cases\nQuick Sort: O(n log n) average, O(n²) worst, O(n log n) best\nHeap Sort: O(n log n) all cases\nCounting Sort: O(n + k) where k is the range\nRadix Sort: O(d × n) where d is number of digits"
    },
    {
      "id": 40,
      "title": "Data Structures - Linked List & Stack",
      "code": "// Implementation of fundamental data structures\n\n// Node class for linked structures\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Singly Linked List implementation\nclass LinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n    \n    // Add element to the end\n    append(data) {\n        const newNode = new Node(data);\n        \n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        } else {\n            this.tail.next = newNode;\n            this.tail = newNode;\n        }\n        \n        this.size++;\n        return this;\n    }\n    \n    // Add element to the beginning\n    prepend(data) {\n        const newNode = new Node(data);\n        \n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        } else {\n            newNode.next = this.head;\n            this.head = newNode;\n        }\n        \n        this.size++;\n        return this;\n    }\n    \n    // Insert at specific index\n    insertAt(index, data) {\n        if (index < 0 || index > this.size) {\n            throw new Error('Index out of bounds');\n        }\n        \n        if (index === 0) {\n            return this.prepend(data);\n        }\n        \n        if (index === this.size) {\n            return this.append(data);\n        }\n        \n        const newNode = new Node(data);\n        let current = this.head;\n        \n        for (let i = 0; i < index - 1; i++) {\n            current = current.next;\n        }\n        \n        newNode.next = current.next;\n        current.next = newNode;\n        this.size++;\n        \n        return this;\n    }\n    \n    // Remove element by value\n    remove(data) {\n        if (!this.head) return false;\n        \n        if (this.head.data === data) {\n            this.head = this.head.next;\n            if (!this.head) this.tail = null;\n            this.size--;\n            return true;\n        }\n        \n        let current = this.head;\n        while (current.next && current.next.data !== data) {\n            current = current.next;\n        }\n        \n        if (current.next) {\n            if (current.next === this.tail) {\n                this.tail = current;\n            }\n            current.next = current.next.next;\n            this.size--;\n            return true;\n        }\n        \n        return false;\n    }\n    \n    // Remove element at specific index\n    removeAt(index) {\n        if (index < 0 || index >= this.size) {\n            throw new Error('Index out of bounds');\n        }\n        \n        if (index === 0) {\n            const data = this.head.data;\n            this.head = this.head.next;\n            if (!this.head) this.tail = null;\n            this.size--;\n            return data;\n        }\n        \n        let current = this.head;\n        for (let i = 0; i < index - 1; i++) {\n            current = current.next;\n        }\n        \n        const data = current.next.data;\n        if (current.next === this.tail) {\n            this.tail = current;\n        }\n        current.next = current.next.next;\n        this.size--;\n        \n        return data;\n    }\n    \n    // Find element index\n    indexOf(data) {\n        let current = this.head;\n        let index = 0;\n        \n        while (current) {\n            if (current.data === data) {\n                return index;\n            }\n            current = current.next;\n            index++;\n        }\n        \n        return -1;\n    }\n    \n    // Get element at index\n    get(index) {\n        if (index < 0 || index >= this.size) {\n            throw new Error('Index out of bounds');\n        }\n        \n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        \n        return current.data;\n    }\n    \n    // Check if list contains element\n    contains(data) {\n        return this.indexOf(data) !== -1;\n    }\n    \n    // Convert to array\n    toArray() {\n        const result = [];\n        let current = this.head;\n        \n        while (current) {\n            result.push(current.data);\n            current = current.next;\n        }\n        \n        return result;\n    }\n    \n    // Reverse the list\n    reverse() {\n        if (!this.head || !this.head.next) return this;\n        \n        let prev = null;\n        let current = this.head;\n        this.tail = this.head;\n        \n        while (current) {\n            const next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        \n        this.head = prev;\n        return this;\n    }\n    \n    // Clear the list\n    clear() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n        return this;\n    }\n    \n    // Check if empty\n    isEmpty() {\n        return this.size === 0;\n    }\n    \n    // Display list\n    display() {\n        if (this.isEmpty()) {\n            return 'Empty list';\n        }\n        return this.toArray().join(' -> ');\n    }\n}\n\n// Stack implementation using linked list\nclass Stack {\n    constructor() {\n        this.list = new LinkedList();\n    }\n    \n    // Push element onto stack\n    push(data) {\n        this.list.prepend(data);\n        return this;\n    }\n    \n    // Pop element from stack\n    pop() {\n        if (this.isEmpty()) {\n            throw new Error('Stack is empty');\n        }\n        return this.list.removeAt(0);\n    }\n    \n    // Peek at top element\n    peek() {\n        if (this.isEmpty()) {\n            throw new Error('Stack is empty');\n        }\n        return this.list.get(0);\n    }\n    \n    // Check if stack is empty\n    isEmpty() {\n        return this.list.isEmpty();\n    }\n    \n    // Get stack size\n    size() {\n        return this.list.size;\n    }\n    \n    // Clear stack\n    clear() {\n        this.list.clear();\n        return this;\n    }\n    \n    // Convert to array\n    toArray() {\n        return this.list.toArray();\n    }\n    \n    // Display stack\n    display() {\n        if (this.isEmpty()) {\n            return 'Empty stack';\n        }\n        const array = this.toArray();\n        return array.map((item, index) => \n            `${index === 0 ? '→ ' : '  '}${item}`\n        ).join('\\n');\n    }\n}\n\n// Queue implementation using linked list\nclass Queue {\n    constructor() {\n        this.list = new LinkedList();\n    }\n    \n    // Add element to rear of queue\n    enqueue(data) {\n        this.list.append(data);\n        return this;\n    }\n    \n    // Remove element from front of queue\n    dequeue() {\n        if (this.isEmpty()) {\n            throw new Error('Queue is empty');\n        }\n        return this.list.removeAt(0);\n    }\n    \n    // Peek at front element\n    front() {\n        if (this.isEmpty()) {\n            throw new Error('Queue is empty');\n        }\n        return this.list.get(0);\n    }\n    \n    // Peek at rear element\n    rear() {\n        if (this.isEmpty()) {\n            throw new Error('Queue is empty');\n        }\n        return this.list.get(this.list.size - 1);\n    }\n    \n    // Check if queue is empty\n    isEmpty() {\n        return this.list.isEmpty();\n    }\n    \n    // Get queue size\n    size() {\n        return this.list.size;\n    }\n    \n    // Clear queue\n    clear() {\n        this.list.clear();\n        return this;\n    }\n    \n    // Convert to array\n    toArray() {\n        return this.list.toArray();\n    }\n    \n    // Display queue\n    display() {\n        if (this.isEmpty()) {\n            return 'Empty queue';\n        }\n        return `Front [${this.toArray().join(', ')}] Rear`;\n    }\n}\n\n// Applications and examples\nclass DataStructureApplications {\n    // Check balanced parentheses using stack\n    static isBalanced(expression) {\n        const stack = new Stack();\n        const pairs = { '(': ')', '[': ']', '{': '}' };\n        \n        for (let char of expression) {\n            if (char in pairs) {\n                stack.push(char);\n            } else if (Object.values(pairs).includes(char)) {\n                if (stack.isEmpty() || pairs[stack.pop()] !== char) {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n    \n    // Evaluate postfix expression using stack\n    static evaluatePostfix(expression) {\n        const stack = new Stack();\n        const tokens = expression.split(' ');\n        \n        for (let token of tokens) {\n            if (!isNaN(token)) {\n                stack.push(parseFloat(token));\n            } else {\n                const b = stack.pop();\n                const a = stack.pop();\n                \n                switch (token) {\n                    case '+':\n                        stack.push(a + b);\n                        break;\n                    case '-':\n                        stack.push(a - b);\n                        break;\n                    case '*':\n                        stack.push(a * b);\n                        break;\n                    case '/':\n                        stack.push(a / b);\n                        break;\n                }\n            }\n        }\n        \n        return stack.pop();\n    }\n    \n    // BFS traversal simulation using queue\n    static bfsTraversal(graph, start) {\n        const visited = new Set();\n        const queue = new Queue();\n        const result = [];\n        \n        queue.enqueue(start);\n        visited.add(start);\n        \n        while (!queue.isEmpty()) {\n            const node = queue.dequeue();\n            result.push(node);\n            \n            if (graph[node]) {\n                for (let neighbor of graph[node]) {\n                    if (!visited.has(neighbor)) {\n                        visited.add(neighbor);\n                        queue.enqueue(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n}\n\n// Demo usage\nconsole.log('=== Data Structures Demo ===');\n\n// Linked List Demo\nconsole.log('\\n1. Linked List Operations');\nconst list = new LinkedList();\n\nlist.append(1).append(2).append(3);\nconsole.log('After appending 1, 2, 3:', list.display());\n\nlist.prepend(0);\nconsole.log('After prepending 0:', list.display());\n\nlist.insertAt(2, 1.5);\nconsole.log('After inserting 1.5 at index 2:', list.display());\n\nconsole.log('Index of element 2:', list.indexOf(2));\nconsole.log('Element at index 3:', list.get(3));\n\nlist.remove(1.5);\nconsole.log('After removing 1.5:', list.display());\n\nlist.reverse();\nconsole.log('After reversing:', list.display());\n\n// Stack Demo\nconsole.log('\\n2. Stack Operations');\nconst stack = new Stack();\n\nstack.push('A').push('B').push('C');\nconsole.log('Stack after pushing A, B, C:');\nconsole.log(stack.display());\n\nconsole.log('\\nPeek:', stack.peek());\nconsole.log('Pop:', stack.pop());\nconsole.log('Stack after popping:');\nconsole.log(stack.display());\n\n// Queue Demo\nconsole.log('\\n3. Queue Operations');\nconst queue = new Queue();\n\nqueue.enqueue('First').enqueue('Second').enqueue('Third');\nconsole.log('Queue after enqueueing:', queue.display());\n\nconsole.log('Front element:', queue.front());\nconsole.log('Rear element:', queue.rear());\nconsole.log('Dequeue:', queue.dequeue());\nconsole.log('Queue after dequeue:', queue.display());\n\n// Applications Demo\nconsole.log('\\n4. Practical Applications');\n\n// Balanced parentheses\nconst expressions = [\n    '()',\n    '()[]{}',\n    '([{}])',\n    '([)]',\n    '((()'\n];\n\nconsole.log('Balanced Parentheses Check:');\nexpressions.forEach(expr => {\n    console.log(`\"${expr}\": ${DataStructureApplications.isBalanced(expr)}`);\n});\n\n// Postfix evaluation\nconsole.log('\\nPostfix Expression Evaluation:');\nconst postfixExpressions = [\n    '3 4 +',\n    '3 4 + 2 *',\n    '15 7 1 1 + - / 3 * 2 1 1 + + -'\n];\n\npostfixExpressions.forEach(expr => {\n    try {\n        const result = DataStructureApplications.evaluatePostfix(expr);\n        console.log(`\"${expr}\" = ${result}`);\n    } catch (error) {\n        console.log(`\"${expr}\" - Error: ${error.message}`);\n    }\n});\n\n// BFS traversal\nconsole.log('\\nBFS Traversal:');\nconst graph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n};\n\nconst bfsResult = DataStructureApplications.bfsTraversal(graph, 'A');\nconsole.log('BFS starting from A:', bfsResult.join(' → '));\n\n// Performance comparison\nconsole.log('\\n5. Performance Characteristics');\nconsole.log('Linked List:');\nconsole.log('  - Access: O(n)');\nconsole.log('  - Search: O(n)');\nconsole.log('  - Insertion: O(1) at head/tail, O(n) at arbitrary position');\nconsole.log('  - Deletion: O(1) at head, O(n) for arbitrary element');\n\nconsole.log('\\nStack (based on Linked List):');\nconsole.log('  - Push: O(1)');\nconsole.log('  - Pop: O(1)');\nconsole.log('  - Peek: O(1)');\n\nconsole.log('\\nQueue (based on Linked List):');\nconsole.log('  - Enqueue: O(1)');\nconsole.log('  - Dequeue: O(1)');\nconsole.log('  - Front/Rear: O(1)');",
      "output": "=== Data Structures Demo ===\n\n1. Linked List Operations\nAfter appending 1, 2, 3: 1 -> 2 -> 3\nAfter prepending 0: 0 -> 1 -> 2 -> 3\nAfter inserting 1.5 at index 2: 0 -> 1 -> 1.5 -> 2 -> 3\nIndex of element 2: 3\nElement at index 3: 2\nAfter removing 1.5: 0 -> 1 -> 2 -> 3\nAfter reversing: 3 -> 2 -> 1 -> 0\n\n2. Stack Operations\nStack after pushing A, B, C:\n→ C\n  B\n  A\n\nPeek: C\nPop: C\nStack after popping:\n→ B\n  A\n\n3. Queue Operations\nQueue after enqueueing: Front [First, Second, Third] Rear\nFront element: First\nRear element: Third\nDequeue: First\nQueue after dequeue: Front [Second, Third] Rear\n\n4. Practical Applications\nBalanced Parentheses Check:\n\"()\": true\n\"()[]{}\": true\n\"([{}])\": true\n\"([)]\": false\n\"((()\": false\n\nPostfix Expression Evaluation:\n\"3 4 +\" = 7\n\"3 4 + 2 *\" = 14\n\"15 7 1 1 + - / 3 * 2 1 1 + + -\" = 5\n\nBFS Traversal:\nBFS starting from A: A → B → C → D → E → F\n\n5. Performance Characteristics\nLinked List:\n  - Access: O(n)\n  - Search: O(n)\n  - Insertion: O(1) at head/tail, O(n) at arbitrary position\n  - Deletion: O(1) at head, O(n) for arbitrary element\n\nStack (based on Linked List):\n  - Push: O(1)\n  - Pop: O(1)\n  - Peek: O(1)\n\nQueue (based on Linked List):\n  - Enqueue: O(1)\n  - Dequeue: O(1)\n  - Front/Rear: O(1)"
    }
  ],
  "python": [
    {
      "id": 1,
      "title": "Hello World",
      "code": "print('Hello, World!')",
      "output": "Hello, World!"
    },
    {
      "id": 2,
      "title": "Add Two Numbers",
      "code": "a = 10\nb = 20\nsum_result = a + b\nprint(f'Sum: {sum_result}')",
      "output": "Sum: 30"
    },
    {
      "id": 3,
      "title": "Check Even/Odd",
      "code": "num = 15\nif num % 2 == 0:\n    print(f'{num} is even')\nelse:\n    print(f'{num} is odd')",
      "output": "15 is odd"
    },
    {
      "id": 4,
      "title": "Factorial of Number",
      "code": "n = 5\nfact = 1\n\nfor i in range(1, n + 1):\n    fact *= i\n\nprint(f'Factorial of {n} is {fact}')",
      "output": "Factorial of 5 is 120"
    },
    {
      "id": 5,
      "title": "Prime Number Check",
      "code": "import math\n\nnum = 17\nis_prime = True\n\nif num <= 1:\n    is_prime = False\nelse:\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\nif is_prime:\n    print(f'{num} is prime')\nelse:\n    print(f'{num} is not prime')",
      "output": "17 is prime"
    },
    {
      "id": 6,
      "title": "Array Sum",
      "code": "arr = [1, 2, 3, 4, 5]\ntotal = sum(arr)\nprint(f'Array sum: {total}')",
      "output": "Array sum: 15"
    },
    {
      "id": 7,
      "title": "Reverse String",
      "code": "string = 'Hello'\nreversed_str = string[::-1]\n\nprint(f'Original: {string}')\nprint(f'Reversed: {reversed_str}')",
      "output": "Original: Hello\\nReversed: olleH"
    },
    {
      "id": 8,
      "title": "Fibonacci Series",
      "code": "n = 10\na, b = 0, 1\nfib_series = [a, b]\n\nfor i in range(2, n):\n    next_num = a + b\n    fib_series.append(next_num)\n    a, b = b, next_num\n\nprint(f\"Fibonacci series: {' '.join(map(str, fib_series))}\")",
      "output": "Fibonacci series: 0 1 1 2 3 5 8 13 21 34"
    },
    {
      "id": 9,
      "title": "Largest in Array",
      "code": "arr = [10, 5, 8, 20, 3]\nmax_num = max(arr)\nprint(f'Largest number: {max_num}')",
      "output": "Largest number: 20"
    },
    {
      "id": 10,
      "title": "Palindrome Check",
      "code": "string = 'madam'\nreversed_str = string[::-1]\n\nif string == reversed_str:\n    print(f'{string} is a palindrome')\nelse:\n    print(f'{string} is not a palindrome')",
      "output": "madam is a palindrome"
    }
  ]
}